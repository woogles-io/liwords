package memento

import (
	"bytes"
	_ "embed"
	"fmt"
	"image"
	"image/color"
	"image/gif"
	"image/png"
	"math"
	"sort"
	"strconv"
	"strings"
	"unicode"

	macondopb "github.com/domino14/macondo/gen/api/proto/macondo"

	"github.com/domino14/macondo/alphabet"
	"github.com/domino14/macondo/game"
)

// The "*" is a double-word with a star. Rework needed if the star isn't a double-word square.
// Also, we use runes for consistency.
var standardBoardConfig = [][]rune{
	[]rune("=  '   =   '  ="),
	[]rune(" -   \"   \"   - "),
	[]rune("  -   ' '   -  "),
	[]rune("'  -   '   -  '"),
	[]rune("    -     -    "),
	[]rune(" \"   \"   \"   \" "),
	[]rune("  '   ' '   '  "),
	[]rune("=  '   *   '  ="),
	[]rune("  '   ' '   '  "),
	[]rune(" \"   \"   \"   \" "),
	[]rune("    -     -    "),
	[]rune("'  -   '   -  '"),
	[]rune("  -   ' '   -  "),
	[]rune(" -   \"   \"   - "),
	[]rune("=  '   =   '  ="),
}

var superBoardConfig = [][]rune{
	[]rune("~  '   =  '  =   '  ~"),
	[]rune(" -  \"   -   -   \"  - "),
	[]rune("  -  ^   - -   ^  -  "),
	[]rune("'  =  '   =   '  =  '"),
	[]rune(" \"  -   \"   \"   -  \" "),
	[]rune("  ^  -   ' '   -  ^  "),
	[]rune("   '  -   '   -  '   "),
	[]rune("=      -     -      ="),
	[]rune(" -  \"   \"   \"   \"  - "),
	[]rune("  -  '   ' '   '  -  "),
	[]rune("'  =  '   *   '  =   "),
	[]rune("  -  '   ' '   '  -  "),
	[]rune(" -  \"   \"   \"   \"  - "),
	[]rune("=      -     -      ="),
	[]rune("   '  -   '   -  '   "),
	[]rune("  ^  -   ' '   -  ^  "),
	[]rune(" \"  -   \"   \"   -  \" "),
	[]rune("'  =  '   =   '  =  '"),
	[]rune("  -  ^   - -   ^  -  "),
	[]rune(" -  \"   -   -   \"  - "),
	[]rune("~  '   =  '  =   '  ~"),
}

// These files must be kept in sync with macondo's data/letterdistribution/.
//go:embed letterdistributions/english.csv
var englishLetterDistributionCSVBytes []byte

//go:embed letterdistributions/english_super.csv
var englishSuperLetterDistributionCSVBytes []byte

//go:embed letterdistributions/french.csv
var frenchLetterDistributionCSVBytes []byte

//go:embed letterdistributions/german.csv
var germanLetterDistributionCSVBytes []byte

//go:embed letterdistributions/norwegian.csv
var norwegianLetterDistributionCSVBytes []byte

// header should be pre-quantized to very few colors (ideally 8)
//go:embed header.png
var headerBytes []byte

// tiles should be pre-quantized to very few colors (ideally 48)
//go:embed tiles-english.png
var englishTilesBytes []byte

//go:embed tiles-french.png
var frenchTilesBytes []byte

//go:embed tiles-german.png
var germanTilesBytes []byte

//go:embed tiles-norwegian.png
var norwegianTilesBytes []byte

const squareDim = 68
const monospacedFontDimX = 24
const monospacedFontDimY = 60

// Content generated by /tile_images from the frontend.
type TilePainterTilesMeta struct {
	TilesBytes  []byte
	Tile0Src    map[rune][2]int
	Tile1Src    map[rune][2]int
	BoardSrc    map[rune][2]int
	TextXSrc    map[rune][2]int
	Text0Src    map[rune][2]int
	Text1Src    map[rune][2]int
	ExpDimXY    [2]int
	BoardConfig [][]rune
}

var tilesMeta = map[string]*TilePainterTilesMeta{
	"english": {
		TilesBytes: englishTilesBytes,
		Tile0Src: map[rune][2]int{
			'A': {0, 0}, 'B': {68, 0}, 'C': {136, 0}, 'D': {204, 0}, 'E': {272, 0},
			'F': {340, 0}, 'G': {408, 0}, 'H': {476, 0}, 'I': {544, 0}, 'J': {612, 0},
			'K': {680, 0}, 'L': {748, 0}, 'M': {816, 0}, 'N': {884, 0}, 'O': {952, 0},
			'P': {1020, 0}, 'Q': {1088, 0}, 'R': {1156, 0}, 'S': {1224, 0}, 'T': {1292, 0},
			'U': {0, 68}, 'V': {68, 68}, 'W': {136, 68}, 'X': {204, 68}, 'Y': {272, 68},
			'Z': {340, 68}, 'a': {408, 68}, 'b': {476, 68}, 'c': {544, 68}, 'd': {612, 68},
			'e': {680, 68}, 'f': {748, 68}, 'g': {816, 68}, 'h': {884, 68}, 'i': {952, 68},
			'j': {1020, 68}, 'k': {1088, 68}, 'l': {1156, 68}, 'm': {1224, 68}, 'n': {1292, 68},
			'o': {0, 136}, 'p': {68, 136}, 'q': {136, 136}, 'r': {204, 136}, 's': {272, 136},
			't': {340, 136}, 'u': {408, 136}, 'v': {476, 136}, 'w': {544, 136}, 'x': {612, 136},
			'y': {680, 136}, 'z': {748, 136}, '?': {816, 136},
		},
		Tile1Src: map[rune][2]int{
			'A': {884, 136}, 'B': {952, 136},
			'C': {1020, 136}, 'D': {1088, 136}, 'E': {1156, 136}, 'F': {1224, 136}, 'G': {1292, 136},
			'H': {0, 204}, 'I': {68, 204}, 'J': {136, 204}, 'K': {204, 204}, 'L': {272, 204},
			'M': {340, 204}, 'N': {408, 204}, 'O': {476, 204}, 'P': {544, 204}, 'Q': {612, 204},
			'R': {680, 204}, 'S': {748, 204}, 'T': {816, 204}, 'U': {884, 204}, 'V': {952, 204},
			'W': {1020, 204}, 'X': {1088, 204}, 'Y': {1156, 204}, 'Z': {1224, 204}, 'a': {1292, 204},
			'b': {0, 272}, 'c': {68, 272}, 'd': {136, 272}, 'e': {204, 272}, 'f': {272, 272},
			'g': {340, 272}, 'h': {408, 272}, 'i': {476, 272}, 'j': {544, 272}, 'k': {612, 272},
			'l': {680, 272}, 'm': {748, 272}, 'n': {816, 272}, 'o': {884, 272}, 'p': {952, 272},
			'q': {1020, 272}, 'r': {1088, 272}, 's': {1156, 272}, 't': {1224, 272}, 'u': {1292, 272},
			'v': {0, 340}, 'w': {68, 340}, 'x': {136, 340}, 'y': {204, 340}, 'z': {272, 340},
			'?': {340, 340},
		},
		BoardSrc: map[rune][2]int{
			'-': {408, 340}, '=': {476, 340}, '~': {544, 340}, '\'': {612, 340},
			'"': {680, 340}, '^': {748, 340}, '*': {816, 340}, ' ': {884, 340},
		},
		TextXSrc: map[rune][2]int{
			'0': {0, 408}, '1': {24, 408}, '2': {48, 408}, '3': {72, 408}, '4': {96, 408},
			'5': {120, 408}, '6': {144, 408}, '7': {168, 408}, '8': {192, 408}, '9': {216, 408},
			'A': {240, 408}, 'a': {264, 408}, 'B': {288, 408}, 'b': {312, 408}, 'C': {336, 408},
			'c': {360, 408}, 'D': {384, 408}, 'd': {408, 408}, 'E': {432, 408}, 'e': {456, 408},
			'F': {480, 408}, 'f': {504, 408}, 'G': {528, 408}, 'g': {552, 408}, 'H': {576, 408},
			'h': {600, 408}, 'I': {624, 408}, 'i': {648, 408}, 'J': {672, 408}, 'j': {696, 408},
			'K': {720, 408}, 'k': {744, 408}, 'L': {768, 408}, 'l': {792, 408}, 'M': {816, 408},
			'm': {840, 408}, 'N': {864, 408}, 'n': {888, 408}, 'O': {912, 408}, 'o': {936, 408},
			'P': {960, 408}, 'p': {984, 408}, 'Q': {1008, 408}, 'q': {1032, 408}, 'R': {1056, 408},
			'r': {1080, 408}, 'S': {1104, 408}, 's': {1128, 408}, 'T': {1152, 408}, 't': {1176, 408},
			'U': {1200, 408}, 'u': {1224, 408}, 'V': {1248, 408}, 'v': {1272, 408}, 'W': {1296, 408},
			'w': {1320, 408},
			'X': {0, 468}, 'x': {24, 468}, 'Y': {48, 468}, 'y': {72, 468}, 'Z': {96, 468},
			'z': {120, 468}, ' ': {144, 468}, '!': {168, 468}, '"': {192, 468}, '#': {216, 468},
			'$': {240, 468}, '%': {264, 468}, '&': {288, 468}, '\'': {312, 468}, '(': {336, 468},
			')': {360, 468}, '*': {384, 468}, '+': {408, 468}, ',': {432, 468}, '-': {456, 468},
			'.': {480, 468}, '/': {504, 468}, ':': {528, 468}, ';': {552, 468}, '<': {576, 468},
			'=': {600, 468}, '>': {624, 468}, '?': {648, 468}, '@': {672, 468}, '[': {696, 468},
			'\\': {720, 468}, ']': {744, 468}, '^': {768, 468}, '_': {792, 468}, '`': {816, 468},
			'{': {840, 468}, '|': {864, 468}, '}': {888, 468}, '~': {912, 468},
		},
		Text0Src: map[rune][2]int{
			'0': {936, 468},
			'1': {960, 468}, '2': {984, 468}, '3': {1008, 468}, '4': {1032, 468}, '5': {1056, 468},
			'6': {1080, 468}, '7': {1104, 468}, '8': {1128, 468}, '9': {1152, 468}, 'A': {1176, 468},
			'a': {1200, 468}, 'B': {1224, 468}, 'b': {1248, 468}, 'C': {1272, 468}, 'c': {1296, 468},
			'D': {1320, 468},
			'd': {0, 528}, 'E': {24, 528}, 'e': {48, 528}, 'F': {72, 528}, 'f': {96, 528},
			'G': {120, 528}, 'g': {144, 528}, 'H': {168, 528}, 'h': {192, 528}, 'I': {216, 528},
			'i': {240, 528}, 'J': {264, 528}, 'j': {288, 528}, 'K': {312, 528}, 'k': {336, 528},
			'L': {360, 528}, 'l': {384, 528}, 'M': {408, 528}, 'm': {432, 528}, 'N': {456, 528},
			'n': {480, 528}, 'O': {504, 528}, 'o': {528, 528}, 'P': {552, 528}, 'p': {576, 528},
			'Q': {600, 528}, 'q': {624, 528}, 'R': {648, 528}, 'r': {672, 528}, 'S': {696, 528},
			's': {720, 528}, 'T': {744, 528}, 't': {768, 528}, 'U': {792, 528}, 'u': {816, 528},
			'V': {840, 528}, 'v': {864, 528}, 'W': {888, 528}, 'w': {912, 528}, 'X': {936, 528},
			'x': {960, 528}, 'Y': {984, 528}, 'y': {1008, 528}, 'Z': {1032, 528}, 'z': {1056, 528},
			' ': {1080, 528}, '!': {1104, 528}, '"': {1128, 528}, '#': {1152, 528}, '$': {1176, 528},
			'%': {1200, 528}, '&': {1224, 528}, '\'': {1248, 528}, '(': {1272, 528}, ')': {1296, 528},
			'*': {1320, 528},
			'+': {0, 588}, ',': {24, 588}, '-': {48, 588}, '.': {72, 588}, '/': {96, 588},
			':': {120, 588}, ';': {144, 588}, '<': {168, 588}, '=': {192, 588}, '>': {216, 588},
			'?': {240, 588}, '@': {264, 588}, '[': {288, 588}, '\\': {312, 588}, ']': {336, 588},
			'^': {360, 588}, '_': {384, 588}, '`': {408, 588}, '{': {432, 588}, '|': {456, 588},
			'}': {480, 588}, '~': {504, 588},
		},
		Text1Src: map[rune][2]int{
			'0': {528, 588}, '1': {552, 588}, '2': {576, 588},
			'3': {600, 588}, '4': {624, 588}, '5': {648, 588}, '6': {672, 588}, '7': {696, 588},
			'8': {720, 588}, '9': {744, 588}, 'A': {768, 588}, 'a': {792, 588}, 'B': {816, 588},
			'b': {840, 588}, 'C': {864, 588}, 'c': {888, 588}, 'D': {912, 588}, 'd': {936, 588},
			'E': {960, 588}, 'e': {984, 588}, 'F': {1008, 588}, 'f': {1032, 588}, 'G': {1056, 588},
			'g': {1080, 588}, 'H': {1104, 588}, 'h': {1128, 588}, 'I': {1152, 588}, 'i': {1176, 588},
			'J': {1200, 588}, 'j': {1224, 588}, 'K': {1248, 588}, 'k': {1272, 588}, 'L': {1296, 588},
			'l': {1320, 588},
			'M': {0, 648}, 'm': {24, 648}, 'N': {48, 648}, 'n': {72, 648}, 'O': {96, 648},
			'o': {120, 648}, 'P': {144, 648}, 'p': {168, 648}, 'Q': {192, 648}, 'q': {216, 648},
			'R': {240, 648}, 'r': {264, 648}, 'S': {288, 648}, 's': {312, 648}, 'T': {336, 648},
			't': {360, 648}, 'U': {384, 648}, 'u': {408, 648}, 'V': {432, 648}, 'v': {456, 648},
			'W': {480, 648}, 'w': {504, 648}, 'X': {528, 648}, 'x': {552, 648}, 'Y': {576, 648},
			'y': {600, 648}, 'Z': {624, 648}, 'z': {648, 648}, ' ': {672, 648}, '!': {696, 648},
			'"': {720, 648}, '#': {744, 648}, '$': {768, 648}, '%': {792, 648}, '&': {816, 648},
			'\'': {840, 648}, '(': {864, 648}, ')': {888, 648}, '*': {912, 648}, '+': {936, 648},
			',': {960, 648}, '-': {984, 648}, '.': {1008, 648}, '/': {1032, 648}, ':': {1056, 648},
			';': {1080, 648}, '<': {1104, 648}, '=': {1128, 648}, '>': {1152, 648}, '?': {1176, 648},
			'@': {1200, 648}, '[': {1224, 648}, '\\': {1248, 648}, ']': {1272, 648}, '^': {1296, 648},
			'_': {1320, 648},
			'`': {0, 708}, '{': {24, 708}, '|': {48, 708}, '}': {72, 708}, '~': {96, 708},
		},
		ExpDimXY:    [2]int{1360, 768},
		BoardConfig: standardBoardConfig,
	},
	"english_super": {
		TilesBytes: englishTilesBytes,
		Tile0Src: map[rune][2]int{
			'A': {0, 0}, 'B': {68, 0}, 'C': {136, 0}, 'D': {204, 0}, 'E': {272, 0},
			'F': {340, 0}, 'G': {408, 0}, 'H': {476, 0}, 'I': {544, 0}, 'J': {612, 0},
			'K': {680, 0}, 'L': {748, 0}, 'M': {816, 0}, 'N': {884, 0}, 'O': {952, 0},
			'P': {1020, 0}, 'Q': {1088, 0}, 'R': {1156, 0}, 'S': {1224, 0}, 'T': {1292, 0},
			'U': {0, 68}, 'V': {68, 68}, 'W': {136, 68}, 'X': {204, 68}, 'Y': {272, 68},
			'Z': {340, 68}, 'a': {408, 68}, 'b': {476, 68}, 'c': {544, 68}, 'd': {612, 68},
			'e': {680, 68}, 'f': {748, 68}, 'g': {816, 68}, 'h': {884, 68}, 'i': {952, 68},
			'j': {1020, 68}, 'k': {1088, 68}, 'l': {1156, 68}, 'm': {1224, 68}, 'n': {1292, 68},
			'o': {0, 136}, 'p': {68, 136}, 'q': {136, 136}, 'r': {204, 136}, 's': {272, 136},
			't': {340, 136}, 'u': {408, 136}, 'v': {476, 136}, 'w': {544, 136}, 'x': {612, 136},
			'y': {680, 136}, 'z': {748, 136}, '?': {816, 136},
		},
		Tile1Src: map[rune][2]int{
			'A': {884, 136}, 'B': {952, 136},
			'C': {1020, 136}, 'D': {1088, 136}, 'E': {1156, 136}, 'F': {1224, 136}, 'G': {1292, 136},
			'H': {0, 204}, 'I': {68, 204}, 'J': {136, 204}, 'K': {204, 204}, 'L': {272, 204},
			'M': {340, 204}, 'N': {408, 204}, 'O': {476, 204}, 'P': {544, 204}, 'Q': {612, 204},
			'R': {680, 204}, 'S': {748, 204}, 'T': {816, 204}, 'U': {884, 204}, 'V': {952, 204},
			'W': {1020, 204}, 'X': {1088, 204}, 'Y': {1156, 204}, 'Z': {1224, 204}, 'a': {1292, 204},
			'b': {0, 272}, 'c': {68, 272}, 'd': {136, 272}, 'e': {204, 272}, 'f': {272, 272},
			'g': {340, 272}, 'h': {408, 272}, 'i': {476, 272}, 'j': {544, 272}, 'k': {612, 272},
			'l': {680, 272}, 'm': {748, 272}, 'n': {816, 272}, 'o': {884, 272}, 'p': {952, 272},
			'q': {1020, 272}, 'r': {1088, 272}, 's': {1156, 272}, 't': {1224, 272}, 'u': {1292, 272},
			'v': {0, 340}, 'w': {68, 340}, 'x': {136, 340}, 'y': {204, 340}, 'z': {272, 340},
			'?': {340, 340},
		},
		BoardSrc: map[rune][2]int{
			'-': {408, 340}, '=': {476, 340}, '~': {544, 340}, '\'': {612, 340},
			'"': {680, 340}, '^': {748, 340}, '*': {816, 340}, ' ': {884, 340},
		},
		TextXSrc: map[rune][2]int{
			'0': {0, 408}, '1': {24, 408}, '2': {48, 408}, '3': {72, 408}, '4': {96, 408},
			'5': {120, 408}, '6': {144, 408}, '7': {168, 408}, '8': {192, 408}, '9': {216, 408},
			'A': {240, 408}, 'a': {264, 408}, 'B': {288, 408}, 'b': {312, 408}, 'C': {336, 408},
			'c': {360, 408}, 'D': {384, 408}, 'd': {408, 408}, 'E': {432, 408}, 'e': {456, 408},
			'F': {480, 408}, 'f': {504, 408}, 'G': {528, 408}, 'g': {552, 408}, 'H': {576, 408},
			'h': {600, 408}, 'I': {624, 408}, 'i': {648, 408}, 'J': {672, 408}, 'j': {696, 408},
			'K': {720, 408}, 'k': {744, 408}, 'L': {768, 408}, 'l': {792, 408}, 'M': {816, 408},
			'm': {840, 408}, 'N': {864, 408}, 'n': {888, 408}, 'O': {912, 408}, 'o': {936, 408},
			'P': {960, 408}, 'p': {984, 408}, 'Q': {1008, 408}, 'q': {1032, 408}, 'R': {1056, 408},
			'r': {1080, 408}, 'S': {1104, 408}, 's': {1128, 408}, 'T': {1152, 408}, 't': {1176, 408},
			'U': {1200, 408}, 'u': {1224, 408}, 'V': {1248, 408}, 'v': {1272, 408}, 'W': {1296, 408},
			'w': {1320, 408},
			'X': {0, 468}, 'x': {24, 468}, 'Y': {48, 468}, 'y': {72, 468}, 'Z': {96, 468},
			'z': {120, 468}, ' ': {144, 468}, '!': {168, 468}, '"': {192, 468}, '#': {216, 468},
			'$': {240, 468}, '%': {264, 468}, '&': {288, 468}, '\'': {312, 468}, '(': {336, 468},
			')': {360, 468}, '*': {384, 468}, '+': {408, 468}, ',': {432, 468}, '-': {456, 468},
			'.': {480, 468}, '/': {504, 468}, ':': {528, 468}, ';': {552, 468}, '<': {576, 468},
			'=': {600, 468}, '>': {624, 468}, '?': {648, 468}, '@': {672, 468}, '[': {696, 468},
			'\\': {720, 468}, ']': {744, 468}, '^': {768, 468}, '_': {792, 468}, '`': {816, 468},
			'{': {840, 468}, '|': {864, 468}, '}': {888, 468}, '~': {912, 468},
		},
		Text0Src: map[rune][2]int{
			'0': {936, 468},
			'1': {960, 468}, '2': {984, 468}, '3': {1008, 468}, '4': {1032, 468}, '5': {1056, 468},
			'6': {1080, 468}, '7': {1104, 468}, '8': {1128, 468}, '9': {1152, 468}, 'A': {1176, 468},
			'a': {1200, 468}, 'B': {1224, 468}, 'b': {1248, 468}, 'C': {1272, 468}, 'c': {1296, 468},
			'D': {1320, 468},
			'd': {0, 528}, 'E': {24, 528}, 'e': {48, 528}, 'F': {72, 528}, 'f': {96, 528},
			'G': {120, 528}, 'g': {144, 528}, 'H': {168, 528}, 'h': {192, 528}, 'I': {216, 528},
			'i': {240, 528}, 'J': {264, 528}, 'j': {288, 528}, 'K': {312, 528}, 'k': {336, 528},
			'L': {360, 528}, 'l': {384, 528}, 'M': {408, 528}, 'm': {432, 528}, 'N': {456, 528},
			'n': {480, 528}, 'O': {504, 528}, 'o': {528, 528}, 'P': {552, 528}, 'p': {576, 528},
			'Q': {600, 528}, 'q': {624, 528}, 'R': {648, 528}, 'r': {672, 528}, 'S': {696, 528},
			's': {720, 528}, 'T': {744, 528}, 't': {768, 528}, 'U': {792, 528}, 'u': {816, 528},
			'V': {840, 528}, 'v': {864, 528}, 'W': {888, 528}, 'w': {912, 528}, 'X': {936, 528},
			'x': {960, 528}, 'Y': {984, 528}, 'y': {1008, 528}, 'Z': {1032, 528}, 'z': {1056, 528},
			' ': {1080, 528}, '!': {1104, 528}, '"': {1128, 528}, '#': {1152, 528}, '$': {1176, 528},
			'%': {1200, 528}, '&': {1224, 528}, '\'': {1248, 528}, '(': {1272, 528}, ')': {1296, 528},
			'*': {1320, 528},
			'+': {0, 588}, ',': {24, 588}, '-': {48, 588}, '.': {72, 588}, '/': {96, 588},
			':': {120, 588}, ';': {144, 588}, '<': {168, 588}, '=': {192, 588}, '>': {216, 588},
			'?': {240, 588}, '@': {264, 588}, '[': {288, 588}, '\\': {312, 588}, ']': {336, 588},
			'^': {360, 588}, '_': {384, 588}, '`': {408, 588}, '{': {432, 588}, '|': {456, 588},
			'}': {480, 588}, '~': {504, 588},
		},
		Text1Src: map[rune][2]int{
			'0': {528, 588}, '1': {552, 588}, '2': {576, 588},
			'3': {600, 588}, '4': {624, 588}, '5': {648, 588}, '6': {672, 588}, '7': {696, 588},
			'8': {720, 588}, '9': {744, 588}, 'A': {768, 588}, 'a': {792, 588}, 'B': {816, 588},
			'b': {840, 588}, 'C': {864, 588}, 'c': {888, 588}, 'D': {912, 588}, 'd': {936, 588},
			'E': {960, 588}, 'e': {984, 588}, 'F': {1008, 588}, 'f': {1032, 588}, 'G': {1056, 588},
			'g': {1080, 588}, 'H': {1104, 588}, 'h': {1128, 588}, 'I': {1152, 588}, 'i': {1176, 588},
			'J': {1200, 588}, 'j': {1224, 588}, 'K': {1248, 588}, 'k': {1272, 588}, 'L': {1296, 588},
			'l': {1320, 588},
			'M': {0, 648}, 'm': {24, 648}, 'N': {48, 648}, 'n': {72, 648}, 'O': {96, 648},
			'o': {120, 648}, 'P': {144, 648}, 'p': {168, 648}, 'Q': {192, 648}, 'q': {216, 648},
			'R': {240, 648}, 'r': {264, 648}, 'S': {288, 648}, 's': {312, 648}, 'T': {336, 648},
			't': {360, 648}, 'U': {384, 648}, 'u': {408, 648}, 'V': {432, 648}, 'v': {456, 648},
			'W': {480, 648}, 'w': {504, 648}, 'X': {528, 648}, 'x': {552, 648}, 'Y': {576, 648},
			'y': {600, 648}, 'Z': {624, 648}, 'z': {648, 648}, ' ': {672, 648}, '!': {696, 648},
			'"': {720, 648}, '#': {744, 648}, '$': {768, 648}, '%': {792, 648}, '&': {816, 648},
			'\'': {840, 648}, '(': {864, 648}, ')': {888, 648}, '*': {912, 648}, '+': {936, 648},
			',': {960, 648}, '-': {984, 648}, '.': {1008, 648}, '/': {1032, 648}, ':': {1056, 648},
			';': {1080, 648}, '<': {1104, 648}, '=': {1128, 648}, '>': {1152, 648}, '?': {1176, 648},
			'@': {1200, 648}, '[': {1224, 648}, '\\': {1248, 648}, ']': {1272, 648}, '^': {1296, 648},
			'_': {1320, 648},
			'`': {0, 708}, '{': {24, 708}, '|': {48, 708}, '}': {72, 708}, '~': {96, 708},
		},
		ExpDimXY:    [2]int{1360, 768},
		BoardConfig: superBoardConfig,
	},
	"french": {
		TilesBytes: frenchTilesBytes,
		Tile0Src: map[rune][2]int{
			'A': {0, 0}, 'B': {68, 0}, 'C': {136, 0}, 'D': {204, 0}, 'E': {272, 0},
			'F': {340, 0}, 'G': {408, 0}, 'H': {476, 0}, 'I': {544, 0}, 'J': {612, 0},
			'K': {680, 0}, 'L': {748, 0}, 'M': {816, 0}, 'N': {884, 0}, 'O': {952, 0},
			'P': {1020, 0}, 'Q': {1088, 0}, 'R': {1156, 0}, 'S': {1224, 0}, 'T': {1292, 0},
			'U': {0, 68}, 'V': {68, 68}, 'W': {136, 68}, 'X': {204, 68}, 'Y': {272, 68},
			'Z': {340, 68}, 'a': {408, 68}, 'b': {476, 68}, 'c': {544, 68}, 'd': {612, 68},
			'e': {680, 68}, 'f': {748, 68}, 'g': {816, 68}, 'h': {884, 68}, 'i': {952, 68},
			'j': {1020, 68}, 'k': {1088, 68}, 'l': {1156, 68}, 'm': {1224, 68}, 'n': {1292, 68},
			'o': {0, 136}, 'p': {68, 136}, 'q': {136, 136}, 'r': {204, 136}, 's': {272, 136},
			't': {340, 136}, 'u': {408, 136}, 'v': {476, 136}, 'w': {544, 136}, 'x': {612, 136},
			'y': {680, 136}, 'z': {748, 136}, '?': {816, 136},
		},
		Tile1Src: map[rune][2]int{
			'A': {884, 136}, 'B': {952, 136},
			'C': {1020, 136}, 'D': {1088, 136}, 'E': {1156, 136}, 'F': {1224, 136}, 'G': {1292, 136},
			'H': {0, 204}, 'I': {68, 204}, 'J': {136, 204}, 'K': {204, 204}, 'L': {272, 204},
			'M': {340, 204}, 'N': {408, 204}, 'O': {476, 204}, 'P': {544, 204}, 'Q': {612, 204},
			'R': {680, 204}, 'S': {748, 204}, 'T': {816, 204}, 'U': {884, 204}, 'V': {952, 204},
			'W': {1020, 204}, 'X': {1088, 204}, 'Y': {1156, 204}, 'Z': {1224, 204}, 'a': {1292, 204},
			'b': {0, 272}, 'c': {68, 272}, 'd': {136, 272}, 'e': {204, 272}, 'f': {272, 272},
			'g': {340, 272}, 'h': {408, 272}, 'i': {476, 272}, 'j': {544, 272}, 'k': {612, 272},
			'l': {680, 272}, 'm': {748, 272}, 'n': {816, 272}, 'o': {884, 272}, 'p': {952, 272},
			'q': {1020, 272}, 'r': {1088, 272}, 's': {1156, 272}, 't': {1224, 272}, 'u': {1292, 272},
			'v': {0, 340}, 'w': {68, 340}, 'x': {136, 340}, 'y': {204, 340}, 'z': {272, 340},
			'?': {340, 340},
		},
		BoardSrc: map[rune][2]int{
			'-': {408, 340}, '=': {476, 340}, '~': {544, 340}, '\'': {612, 340},
			'"': {680, 340}, '^': {748, 340}, '*': {816, 340}, ' ': {884, 340},
		},
		TextXSrc: map[rune][2]int{
			'0': {0, 408}, '1': {24, 408}, '2': {48, 408}, '3': {72, 408}, '4': {96, 408},
			'5': {120, 408}, '6': {144, 408}, '7': {168, 408}, '8': {192, 408}, '9': {216, 408},
			'A': {240, 408}, 'a': {264, 408}, 'B': {288, 408}, 'b': {312, 408}, 'C': {336, 408},
			'c': {360, 408}, 'D': {384, 408}, 'd': {408, 408}, 'E': {432, 408}, 'e': {456, 408},
			'F': {480, 408}, 'f': {504, 408}, 'G': {528, 408}, 'g': {552, 408}, 'H': {576, 408},
			'h': {600, 408}, 'I': {624, 408}, 'i': {648, 408}, 'J': {672, 408}, 'j': {696, 408},
			'K': {720, 408}, 'k': {744, 408}, 'L': {768, 408}, 'l': {792, 408}, 'M': {816, 408},
			'm': {840, 408}, 'N': {864, 408}, 'n': {888, 408}, 'O': {912, 408}, 'o': {936, 408},
			'P': {960, 408}, 'p': {984, 408}, 'Q': {1008, 408}, 'q': {1032, 408}, 'R': {1056, 408},
			'r': {1080, 408}, 'S': {1104, 408}, 's': {1128, 408}, 'T': {1152, 408}, 't': {1176, 408},
			'U': {1200, 408}, 'u': {1224, 408}, 'V': {1248, 408}, 'v': {1272, 408}, 'W': {1296, 408},
			'w': {1320, 408},
			'X': {0, 468}, 'x': {24, 468}, 'Y': {48, 468}, 'y': {72, 468}, 'Z': {96, 468},
			'z': {120, 468}, ' ': {144, 468}, '!': {168, 468}, '"': {192, 468}, '#': {216, 468},
			'$': {240, 468}, '%': {264, 468}, '&': {288, 468}, '\'': {312, 468}, '(': {336, 468},
			')': {360, 468}, '*': {384, 468}, '+': {408, 468}, ',': {432, 468}, '-': {456, 468},
			'.': {480, 468}, '/': {504, 468}, ':': {528, 468}, ';': {552, 468}, '<': {576, 468},
			'=': {600, 468}, '>': {624, 468}, '?': {648, 468}, '@': {672, 468}, '[': {696, 468},
			'\\': {720, 468}, ']': {744, 468}, '^': {768, 468}, '_': {792, 468}, '`': {816, 468},
			'{': {840, 468}, '|': {864, 468}, '}': {888, 468}, '~': {912, 468},
		},
		Text0Src: map[rune][2]int{
			'0': {936, 468},
			'1': {960, 468}, '2': {984, 468}, '3': {1008, 468}, '4': {1032, 468}, '5': {1056, 468},
			'6': {1080, 468}, '7': {1104, 468}, '8': {1128, 468}, '9': {1152, 468}, 'A': {1176, 468},
			'a': {1200, 468}, 'B': {1224, 468}, 'b': {1248, 468}, 'C': {1272, 468}, 'c': {1296, 468},
			'D': {1320, 468},
			'd': {0, 528}, 'E': {24, 528}, 'e': {48, 528}, 'F': {72, 528}, 'f': {96, 528},
			'G': {120, 528}, 'g': {144, 528}, 'H': {168, 528}, 'h': {192, 528}, 'I': {216, 528},
			'i': {240, 528}, 'J': {264, 528}, 'j': {288, 528}, 'K': {312, 528}, 'k': {336, 528},
			'L': {360, 528}, 'l': {384, 528}, 'M': {408, 528}, 'm': {432, 528}, 'N': {456, 528},
			'n': {480, 528}, 'O': {504, 528}, 'o': {528, 528}, 'P': {552, 528}, 'p': {576, 528},
			'Q': {600, 528}, 'q': {624, 528}, 'R': {648, 528}, 'r': {672, 528}, 'S': {696, 528},
			's': {720, 528}, 'T': {744, 528}, 't': {768, 528}, 'U': {792, 528}, 'u': {816, 528},
			'V': {840, 528}, 'v': {864, 528}, 'W': {888, 528}, 'w': {912, 528}, 'X': {936, 528},
			'x': {960, 528}, 'Y': {984, 528}, 'y': {1008, 528}, 'Z': {1032, 528}, 'z': {1056, 528},
			' ': {1080, 528}, '!': {1104, 528}, '"': {1128, 528}, '#': {1152, 528}, '$': {1176, 528},
			'%': {1200, 528}, '&': {1224, 528}, '\'': {1248, 528}, '(': {1272, 528}, ')': {1296, 528},
			'*': {1320, 528},
			'+': {0, 588}, ',': {24, 588}, '-': {48, 588}, '.': {72, 588}, '/': {96, 588},
			':': {120, 588}, ';': {144, 588}, '<': {168, 588}, '=': {192, 588}, '>': {216, 588},
			'?': {240, 588}, '@': {264, 588}, '[': {288, 588}, '\\': {312, 588}, ']': {336, 588},
			'^': {360, 588}, '_': {384, 588}, '`': {408, 588}, '{': {432, 588}, '|': {456, 588},
			'}': {480, 588}, '~': {504, 588},
		},
		Text1Src: map[rune][2]int{
			'0': {528, 588}, '1': {552, 588}, '2': {576, 588},
			'3': {600, 588}, '4': {624, 588}, '5': {648, 588}, '6': {672, 588}, '7': {696, 588},
			'8': {720, 588}, '9': {744, 588}, 'A': {768, 588}, 'a': {792, 588}, 'B': {816, 588},
			'b': {840, 588}, 'C': {864, 588}, 'c': {888, 588}, 'D': {912, 588}, 'd': {936, 588},
			'E': {960, 588}, 'e': {984, 588}, 'F': {1008, 588}, 'f': {1032, 588}, 'G': {1056, 588},
			'g': {1080, 588}, 'H': {1104, 588}, 'h': {1128, 588}, 'I': {1152, 588}, 'i': {1176, 588},
			'J': {1200, 588}, 'j': {1224, 588}, 'K': {1248, 588}, 'k': {1272, 588}, 'L': {1296, 588},
			'l': {1320, 588},
			'M': {0, 648}, 'm': {24, 648}, 'N': {48, 648}, 'n': {72, 648}, 'O': {96, 648},
			'o': {120, 648}, 'P': {144, 648}, 'p': {168, 648}, 'Q': {192, 648}, 'q': {216, 648},
			'R': {240, 648}, 'r': {264, 648}, 'S': {288, 648}, 's': {312, 648}, 'T': {336, 648},
			't': {360, 648}, 'U': {384, 648}, 'u': {408, 648}, 'V': {432, 648}, 'v': {456, 648},
			'W': {480, 648}, 'w': {504, 648}, 'X': {528, 648}, 'x': {552, 648}, 'Y': {576, 648},
			'y': {600, 648}, 'Z': {624, 648}, 'z': {648, 648}, ' ': {672, 648}, '!': {696, 648},
			'"': {720, 648}, '#': {744, 648}, '$': {768, 648}, '%': {792, 648}, '&': {816, 648},
			'\'': {840, 648}, '(': {864, 648}, ')': {888, 648}, '*': {912, 648}, '+': {936, 648},
			',': {960, 648}, '-': {984, 648}, '.': {1008, 648}, '/': {1032, 648}, ':': {1056, 648},
			';': {1080, 648}, '<': {1104, 648}, '=': {1128, 648}, '>': {1152, 648}, '?': {1176, 648},
			'@': {1200, 648}, '[': {1224, 648}, '\\': {1248, 648}, ']': {1272, 648}, '^': {1296, 648},
			'_': {1320, 648},
			'`': {0, 708}, '{': {24, 708}, '|': {48, 708}, '}': {72, 708}, '~': {96, 708},
		},
		ExpDimXY:    [2]int{1360, 768},
		BoardConfig: standardBoardConfig,
	},
	"german": {
		TilesBytes: germanTilesBytes,
		Tile0Src: map[rune][2]int{
			'A': {0, 0}, 'Ä': {68, 0}, 'B': {136, 0}, 'C': {204, 0}, 'D': {272, 0},
			'E': {340, 0}, 'F': {408, 0}, 'G': {476, 0}, 'H': {544, 0}, 'I': {612, 0},
			'J': {680, 0}, 'K': {748, 0}, 'L': {816, 0}, 'M': {884, 0}, 'N': {952, 0},
			'O': {1020, 0}, 'Ö': {1088, 0}, 'P': {1156, 0}, 'Q': {1224, 0}, 'R': {1292, 0},
			'S': {0, 68}, 'T': {68, 68}, 'U': {136, 68}, 'Ü': {204, 68}, 'V': {272, 68},
			'W': {340, 68}, 'X': {408, 68}, 'Y': {476, 68}, 'Z': {544, 68}, 'a': {612, 68},
			'ä': {680, 68}, 'b': {748, 68}, 'c': {816, 68}, 'd': {884, 68}, 'e': {952, 68},
			'f': {1020, 68}, 'g': {1088, 68}, 'h': {1156, 68}, 'i': {1224, 68}, 'j': {1292, 68},
			'k': {0, 136}, 'l': {68, 136}, 'm': {136, 136}, 'n': {204, 136}, 'o': {272, 136},
			'ö': {340, 136}, 'p': {408, 136}, 'q': {476, 136}, 'r': {544, 136}, 's': {612, 136},
			't': {680, 136}, 'u': {748, 136}, 'ü': {816, 136}, 'v': {884, 136}, 'w': {952, 136},
			'x': {1020, 136}, 'y': {1088, 136}, 'z': {1156, 136}, '?': {1224, 136},
		},
		Tile1Src: map[rune][2]int{
			'A': {1292, 136},
			'Ä': {0, 204}, 'B': {68, 204}, 'C': {136, 204}, 'D': {204, 204}, 'E': {272, 204},
			'F': {340, 204}, 'G': {408, 204}, 'H': {476, 204}, 'I': {544, 204}, 'J': {612, 204},
			'K': {680, 204}, 'L': {748, 204}, 'M': {816, 204}, 'N': {884, 204}, 'O': {952, 204},
			'Ö': {1020, 204}, 'P': {1088, 204}, 'Q': {1156, 204}, 'R': {1224, 204}, 'S': {1292, 204},
			'T': {0, 272}, 'U': {68, 272}, 'Ü': {136, 272}, 'V': {204, 272}, 'W': {272, 272},
			'X': {340, 272}, 'Y': {408, 272}, 'Z': {476, 272}, 'a': {544, 272}, 'ä': {612, 272},
			'b': {680, 272}, 'c': {748, 272}, 'd': {816, 272}, 'e': {884, 272}, 'f': {952, 272},
			'g': {1020, 272}, 'h': {1088, 272}, 'i': {1156, 272}, 'j': {1224, 272}, 'k': {1292, 272},
			'l': {0, 340}, 'm': {68, 340}, 'n': {136, 340}, 'o': {204, 340}, 'ö': {272, 340},
			'p': {340, 340}, 'q': {408, 340}, 'r': {476, 340}, 's': {544, 340}, 't': {612, 340},
			'u': {680, 340}, 'ü': {748, 340}, 'v': {816, 340}, 'w': {884, 340}, 'x': {952, 340},
			'y': {1020, 340}, 'z': {1088, 340}, '?': {1156, 340},
		},
		BoardSrc: map[rune][2]int{
			'-': {1224, 340}, '=': {1292, 340},
			'~': {0, 408}, '\'': {68, 408}, '"': {136, 408}, '^': {204, 408}, '*': {272, 408},
			' ': {340, 408},
		},
		TextXSrc: map[rune][2]int{
			'0': {0, 476}, '1': {24, 476}, '2': {48, 476}, '3': {72, 476}, '4': {96, 476},
			'5': {120, 476}, '6': {144, 476}, '7': {168, 476}, '8': {192, 476}, '9': {216, 476},
			'A': {240, 476}, 'a': {264, 476}, 'Ä': {288, 476}, 'ä': {312, 476}, 'B': {336, 476},
			'b': {360, 476}, 'C': {384, 476}, 'c': {408, 476}, 'D': {432, 476}, 'd': {456, 476},
			'E': {480, 476}, 'e': {504, 476}, 'F': {528, 476}, 'f': {552, 476}, 'G': {576, 476},
			'g': {600, 476}, 'H': {624, 476}, 'h': {648, 476}, 'I': {672, 476}, 'i': {696, 476},
			'J': {720, 476}, 'j': {744, 476}, 'K': {768, 476}, 'k': {792, 476}, 'L': {816, 476},
			'l': {840, 476}, 'M': {864, 476}, 'm': {888, 476}, 'N': {912, 476}, 'n': {936, 476},
			'O': {960, 476}, 'o': {984, 476}, 'Ö': {1008, 476}, 'ö': {1032, 476}, 'P': {1056, 476},
			'p': {1080, 476}, 'Q': {1104, 476}, 'q': {1128, 476}, 'R': {1152, 476}, 'r': {1176, 476},
			'S': {1200, 476}, 's': {1224, 476}, 'T': {1248, 476}, 't': {1272, 476}, 'U': {1296, 476},
			'u': {1320, 476},
			'Ü': {0, 536}, 'ü': {24, 536}, 'V': {48, 536}, 'v': {72, 536}, 'W': {96, 536},
			'w': {120, 536}, 'X': {144, 536}, 'x': {168, 536}, 'Y': {192, 536}, 'y': {216, 536},
			'Z': {240, 536}, 'z': {264, 536}, ' ': {288, 536}, '!': {312, 536}, '"': {336, 536},
			'#': {360, 536}, '$': {384, 536}, '%': {408, 536}, '&': {432, 536}, '\'': {456, 536},
			'(': {480, 536}, ')': {504, 536}, '*': {528, 536}, '+': {552, 536}, ',': {576, 536},
			'-': {600, 536}, '.': {624, 536}, '/': {648, 536}, ':': {672, 536}, ';': {696, 536},
			'<': {720, 536}, '=': {744, 536}, '>': {768, 536}, '?': {792, 536}, '@': {816, 536},
			'[': {840, 536}, '\\': {864, 536}, ']': {888, 536}, '^': {912, 536}, '_': {936, 536},
			'`': {960, 536}, '{': {984, 536}, '|': {1008, 536}, '}': {1032, 536}, '~': {1056, 536},
		},
		Text0Src: map[rune][2]int{
			'0': {1080, 536}, '1': {1104, 536}, '2': {1128, 536}, '3': {1152, 536}, '4': {1176, 536},
			'5': {1200, 536}, '6': {1224, 536}, '7': {1248, 536}, '8': {1272, 536}, '9': {1296, 536},
			'A': {1320, 536},
			'a': {0, 596}, 'Ä': {24, 596}, 'ä': {48, 596}, 'B': {72, 596}, 'b': {96, 596},
			'C': {120, 596}, 'c': {144, 596}, 'D': {168, 596}, 'd': {192, 596}, 'E': {216, 596},
			'e': {240, 596}, 'F': {264, 596}, 'f': {288, 596}, 'G': {312, 596}, 'g': {336, 596},
			'H': {360, 596}, 'h': {384, 596}, 'I': {408, 596}, 'i': {432, 596}, 'J': {456, 596},
			'j': {480, 596}, 'K': {504, 596}, 'k': {528, 596}, 'L': {552, 596}, 'l': {576, 596},
			'M': {600, 596}, 'm': {624, 596}, 'N': {648, 596}, 'n': {672, 596}, 'O': {696, 596},
			'o': {720, 596}, 'Ö': {744, 596}, 'ö': {768, 596}, 'P': {792, 596}, 'p': {816, 596},
			'Q': {840, 596}, 'q': {864, 596}, 'R': {888, 596}, 'r': {912, 596}, 'S': {936, 596},
			's': {960, 596}, 'T': {984, 596}, 't': {1008, 596}, 'U': {1032, 596}, 'u': {1056, 596},
			'Ü': {1080, 596}, 'ü': {1104, 596}, 'V': {1128, 596}, 'v': {1152, 596}, 'W': {1176, 596},
			'w': {1200, 596}, 'X': {1224, 596}, 'x': {1248, 596}, 'Y': {1272, 596}, 'y': {1296, 596},
			'Z': {1320, 596},
			'z': {0, 656}, ' ': {24, 656}, '!': {48, 656}, '"': {72, 656}, '#': {96, 656},
			'$': {120, 656}, '%': {144, 656}, '&': {168, 656}, '\'': {192, 656}, '(': {216, 656},
			')': {240, 656}, '*': {264, 656}, '+': {288, 656}, ',': {312, 656}, '-': {336, 656},
			'.': {360, 656}, '/': {384, 656}, ':': {408, 656}, ';': {432, 656}, '<': {456, 656},
			'=': {480, 656}, '>': {504, 656}, '?': {528, 656}, '@': {552, 656}, '[': {576, 656},
			'\\': {600, 656}, ']': {624, 656}, '^': {648, 656}, '_': {672, 656}, '`': {696, 656},
			'{': {720, 656}, '|': {744, 656}, '}': {768, 656}, '~': {792, 656},
		},
		Text1Src: map[rune][2]int{
			'0': {816, 656},
			'1': {840, 656}, '2': {864, 656}, '3': {888, 656}, '4': {912, 656}, '5': {936, 656},
			'6': {960, 656}, '7': {984, 656}, '8': {1008, 656}, '9': {1032, 656}, 'A': {1056, 656},
			'a': {1080, 656}, 'Ä': {1104, 656}, 'ä': {1128, 656}, 'B': {1152, 656}, 'b': {1176, 656},
			'C': {1200, 656}, 'c': {1224, 656}, 'D': {1248, 656}, 'd': {1272, 656}, 'E': {1296, 656},
			'e': {1320, 656},
			'F': {0, 716}, 'f': {24, 716}, 'G': {48, 716}, 'g': {72, 716}, 'H': {96, 716},
			'h': {120, 716}, 'I': {144, 716}, 'i': {168, 716}, 'J': {192, 716}, 'j': {216, 716},
			'K': {240, 716}, 'k': {264, 716}, 'L': {288, 716}, 'l': {312, 716}, 'M': {336, 716},
			'm': {360, 716}, 'N': {384, 716}, 'n': {408, 716}, 'O': {432, 716}, 'o': {456, 716},
			'Ö': {480, 716}, 'ö': {504, 716}, 'P': {528, 716}, 'p': {552, 716}, 'Q': {576, 716},
			'q': {600, 716}, 'R': {624, 716}, 'r': {648, 716}, 'S': {672, 716}, 's': {696, 716},
			'T': {720, 716}, 't': {744, 716}, 'U': {768, 716}, 'u': {792, 716}, 'Ü': {816, 716},
			'ü': {840, 716}, 'V': {864, 716}, 'v': {888, 716}, 'W': {912, 716}, 'w': {936, 716},
			'X': {960, 716}, 'x': {984, 716}, 'Y': {1008, 716}, 'y': {1032, 716}, 'Z': {1056, 716},
			'z': {1080, 716}, ' ': {1104, 716}, '!': {1128, 716}, '"': {1152, 716}, '#': {1176, 716},
			'$': {1200, 716}, '%': {1224, 716}, '&': {1248, 716}, '\'': {1272, 716}, '(': {1296, 716},
			')': {1320, 716},
			'*': {0, 776}, '+': {24, 776}, ',': {48, 776}, '-': {72, 776}, '.': {96, 776},
			'/': {120, 776}, ':': {144, 776}, ';': {168, 776}, '<': {192, 776}, '=': {216, 776},
			'>': {240, 776}, '?': {264, 776}, '@': {288, 776}, '[': {312, 776}, '\\': {336, 776},
			']': {360, 776}, '^': {384, 776}, '_': {408, 776}, '`': {432, 776}, '{': {456, 776},
			'|': {480, 776}, '}': {504, 776}, '~': {528, 776},
		},
		ExpDimXY:    [2]int{1360, 836},
		BoardConfig: standardBoardConfig,
	},
	"norwegian": {
		TilesBytes: norwegianTilesBytes,
		Tile0Src: map[rune][2]int{
			'A': {0, 0}, 'Ä': {68, 0}, 'B': {136, 0}, 'C': {204, 0}, 'D': {272, 0},
			'E': {340, 0}, 'F': {408, 0}, 'G': {476, 0}, 'H': {544, 0}, 'I': {612, 0},
			'J': {680, 0}, 'K': {748, 0}, 'L': {816, 0}, 'M': {884, 0}, 'N': {952, 0},
			'O': {1020, 0}, 'Ö': {1088, 0}, 'P': {1156, 0}, 'Q': {1224, 0}, 'R': {1292, 0},
			'S': {0, 68}, 'T': {68, 68}, 'U': {136, 68}, 'Ü': {204, 68}, 'V': {272, 68},
			'W': {340, 68}, 'X': {408, 68}, 'Y': {476, 68}, 'Z': {544, 68}, 'Æ': {612, 68},
			'Ø': {680, 68}, 'Å': {748, 68}, 'a': {816, 68}, 'ä': {884, 68}, 'b': {952, 68},
			'c': {1020, 68}, 'd': {1088, 68}, 'e': {1156, 68}, 'f': {1224, 68}, 'g': {1292, 68},
			'h': {0, 136}, 'i': {68, 136}, 'j': {136, 136}, 'k': {204, 136}, 'l': {272, 136},
			'm': {340, 136}, 'n': {408, 136}, 'o': {476, 136}, 'ö': {544, 136}, 'p': {612, 136},
			'q': {680, 136}, 'r': {748, 136}, 's': {816, 136}, 't': {884, 136}, 'u': {952, 136},
			'ü': {1020, 136}, 'v': {1088, 136}, 'w': {1156, 136}, 'x': {1224, 136}, 'y': {1292, 136},
			'z': {0, 204}, 'æ': {68, 204}, 'ø': {136, 204}, 'å': {204, 204}, '?': {272, 204},
		},
		Tile1Src: map[rune][2]int{
			'A': {340, 204}, 'Ä': {408, 204}, 'B': {476, 204}, 'C': {544, 204}, 'D': {612, 204},
			'E': {680, 204}, 'F': {748, 204}, 'G': {816, 204}, 'H': {884, 204}, 'I': {952, 204},
			'J': {1020, 204}, 'K': {1088, 204}, 'L': {1156, 204}, 'M': {1224, 204}, 'N': {1292, 204},
			'O': {0, 272}, 'Ö': {68, 272}, 'P': {136, 272}, 'Q': {204, 272}, 'R': {272, 272},
			'S': {340, 272}, 'T': {408, 272}, 'U': {476, 272}, 'Ü': {544, 272}, 'V': {612, 272},
			'W': {680, 272}, 'X': {748, 272}, 'Y': {816, 272}, 'Z': {884, 272}, 'Æ': {952, 272},
			'Ø': {1020, 272}, 'Å': {1088, 272}, 'a': {1156, 272}, 'ä': {1224, 272}, 'b': {1292, 272},
			'c': {0, 340}, 'd': {68, 340}, 'e': {136, 340}, 'f': {204, 340}, 'g': {272, 340},
			'h': {340, 340}, 'i': {408, 340}, 'j': {476, 340}, 'k': {544, 340}, 'l': {612, 340},
			'm': {680, 340}, 'n': {748, 340}, 'o': {816, 340}, 'ö': {884, 340}, 'p': {952, 340},
			'q': {1020, 340}, 'r': {1088, 340}, 's': {1156, 340}, 't': {1224, 340}, 'u': {1292, 340},
			'ü': {0, 408}, 'v': {68, 408}, 'w': {136, 408}, 'x': {204, 408}, 'y': {272, 408},
			'z': {340, 408}, 'æ': {408, 408}, 'ø': {476, 408}, 'å': {544, 408}, '?': {612, 408},
		},
		BoardSrc: map[rune][2]int{
			'-': {680, 408}, '=': {748, 408}, '~': {816, 408}, '\'': {884, 408}, '"': {952, 408},
			'^': {1020, 408}, '*': {1088, 408}, ' ': {1156, 408},
		},
		TextXSrc: map[rune][2]int{
			'0': {0, 476}, '1': {24, 476}, '2': {48, 476}, '3': {72, 476}, '4': {96, 476},
			'5': {120, 476}, '6': {144, 476}, '7': {168, 476}, '8': {192, 476}, '9': {216, 476},
			'A': {240, 476}, 'a': {264, 476}, 'Ä': {288, 476}, 'ä': {312, 476}, 'B': {336, 476},
			'b': {360, 476}, 'C': {384, 476}, 'c': {408, 476}, 'D': {432, 476}, 'd': {456, 476},
			'E': {480, 476}, 'e': {504, 476}, 'F': {528, 476}, 'f': {552, 476}, 'G': {576, 476},
			'g': {600, 476}, 'H': {624, 476}, 'h': {648, 476}, 'I': {672, 476}, 'i': {696, 476},
			'J': {720, 476}, 'j': {744, 476}, 'K': {768, 476}, 'k': {792, 476}, 'L': {816, 476},
			'l': {840, 476}, 'M': {864, 476}, 'm': {888, 476}, 'N': {912, 476}, 'n': {936, 476},
			'O': {960, 476}, 'o': {984, 476}, 'Ö': {1008, 476}, 'ö': {1032, 476}, 'P': {1056, 476},
			'p': {1080, 476}, 'Q': {1104, 476}, 'q': {1128, 476}, 'R': {1152, 476}, 'r': {1176, 476},
			'S': {1200, 476}, 's': {1224, 476}, 'T': {1248, 476}, 't': {1272, 476}, 'U': {1296, 476},
			'u': {1320, 476},
			'Ü': {0, 536}, 'ü': {24, 536}, 'V': {48, 536}, 'v': {72, 536}, 'W': {96, 536},
			'w': {120, 536}, 'X': {144, 536}, 'x': {168, 536}, 'Y': {192, 536}, 'y': {216, 536},
			'Z': {240, 536}, 'z': {264, 536}, 'Æ': {288, 536}, 'æ': {312, 536}, 'Ø': {336, 536},
			'ø': {360, 536}, 'Å': {384, 536}, 'å': {408, 536}, ' ': {432, 536}, '!': {456, 536},
			'"': {480, 536}, '#': {504, 536}, '$': {528, 536}, '%': {552, 536}, '&': {576, 536},
			'\'': {600, 536}, '(': {624, 536}, ')': {648, 536}, '*': {672, 536}, '+': {696, 536},
			',': {720, 536}, '-': {744, 536}, '.': {768, 536}, '/': {792, 536}, ':': {816, 536},
			';': {840, 536}, '<': {864, 536}, '=': {888, 536}, '>': {912, 536}, '?': {936, 536},
			'@': {960, 536}, '[': {984, 536}, '\\': {1008, 536}, ']': {1032, 536}, '^': {1056, 536},
			'_': {1080, 536}, '`': {1104, 536}, '{': {1128, 536}, '|': {1152, 536}, '}': {1176, 536},
			'~': {1200, 536},
		},
		Text0Src: map[rune][2]int{
			'0': {1224, 536}, '1': {1248, 536}, '2': {1272, 536}, '3': {1296, 536},
			'4': {1320, 536},
			'5': {0, 596}, '6': {24, 596}, '7': {48, 596}, '8': {72, 596}, '9': {96, 596},
			'A': {120, 596}, 'a': {144, 596}, 'Ä': {168, 596}, 'ä': {192, 596}, 'B': {216, 596},
			'b': {240, 596}, 'C': {264, 596}, 'c': {288, 596}, 'D': {312, 596}, 'd': {336, 596},
			'E': {360, 596}, 'e': {384, 596}, 'F': {408, 596}, 'f': {432, 596}, 'G': {456, 596},
			'g': {480, 596}, 'H': {504, 596}, 'h': {528, 596}, 'I': {552, 596}, 'i': {576, 596},
			'J': {600, 596}, 'j': {624, 596}, 'K': {648, 596}, 'k': {672, 596}, 'L': {696, 596},
			'l': {720, 596}, 'M': {744, 596}, 'm': {768, 596}, 'N': {792, 596}, 'n': {816, 596},
			'O': {840, 596}, 'o': {864, 596}, 'Ö': {888, 596}, 'ö': {912, 596}, 'P': {936, 596},
			'p': {960, 596}, 'Q': {984, 596}, 'q': {1008, 596}, 'R': {1032, 596}, 'r': {1056, 596},
			'S': {1080, 596}, 's': {1104, 596}, 'T': {1128, 596}, 't': {1152, 596}, 'U': {1176, 596},
			'u': {1200, 596}, 'Ü': {1224, 596}, 'ü': {1248, 596}, 'V': {1272, 596}, 'v': {1296, 596},
			'W': {1320, 596},
			'w': {0, 656}, 'X': {24, 656}, 'x': {48, 656}, 'Y': {72, 656}, 'y': {96, 656},
			'Z': {120, 656}, 'z': {144, 656}, 'Æ': {168, 656}, 'æ': {192, 656}, 'Ø': {216, 656},
			'ø': {240, 656}, 'Å': {264, 656}, 'å': {288, 656}, ' ': {312, 656}, '!': {336, 656},
			'"': {360, 656}, '#': {384, 656}, '$': {408, 656}, '%': {432, 656}, '&': {456, 656},
			'\'': {480, 656}, '(': {504, 656}, ')': {528, 656}, '*': {552, 656}, '+': {576, 656},
			',': {600, 656}, '-': {624, 656}, '.': {648, 656}, '/': {672, 656}, ':': {696, 656},
			';': {720, 656}, '<': {744, 656}, '=': {768, 656}, '>': {792, 656}, '?': {816, 656},
			'@': {840, 656}, '[': {864, 656}, '\\': {888, 656}, ']': {912, 656}, '^': {936, 656},
			'_': {960, 656}, '`': {984, 656}, '{': {1008, 656}, '|': {1032, 656}, '}': {1056, 656},
			'~': {1080, 656},
		},
		Text1Src: map[rune][2]int{
			'0': {1104, 656}, '1': {1128, 656}, '2': {1152, 656}, '3': {1176, 656},
			'4': {1200, 656}, '5': {1224, 656}, '6': {1248, 656}, '7': {1272, 656}, '8': {1296, 656},
			'9': {1320, 656},
			'A': {0, 716}, 'a': {24, 716}, 'Ä': {48, 716}, 'ä': {72, 716}, 'B': {96, 716},
			'b': {120, 716}, 'C': {144, 716}, 'c': {168, 716}, 'D': {192, 716}, 'd': {216, 716},
			'E': {240, 716}, 'e': {264, 716}, 'F': {288, 716}, 'f': {312, 716}, 'G': {336, 716},
			'g': {360, 716}, 'H': {384, 716}, 'h': {408, 716}, 'I': {432, 716}, 'i': {456, 716},
			'J': {480, 716}, 'j': {504, 716}, 'K': {528, 716}, 'k': {552, 716}, 'L': {576, 716},
			'l': {600, 716}, 'M': {624, 716}, 'm': {648, 716}, 'N': {672, 716}, 'n': {696, 716},
			'O': {720, 716}, 'o': {744, 716}, 'Ö': {768, 716}, 'ö': {792, 716}, 'P': {816, 716},
			'p': {840, 716}, 'Q': {864, 716}, 'q': {888, 716}, 'R': {912, 716}, 'r': {936, 716},
			'S': {960, 716}, 's': {984, 716}, 'T': {1008, 716}, 't': {1032, 716}, 'U': {1056, 716},
			'u': {1080, 716}, 'Ü': {1104, 716}, 'ü': {1128, 716}, 'V': {1152, 716}, 'v': {1176, 716},
			'W': {1200, 716}, 'w': {1224, 716}, 'X': {1248, 716}, 'x': {1272, 716}, 'Y': {1296, 716},
			'y': {1320, 716},
			'Z': {0, 776}, 'z': {24, 776}, 'Æ': {48, 776}, 'æ': {72, 776}, 'Ø': {96, 776},
			'ø': {120, 776}, 'Å': {144, 776}, 'å': {168, 776}, ' ': {192, 776}, '!': {216, 776},
			'"': {240, 776}, '#': {264, 776}, '$': {288, 776}, '%': {312, 776}, '&': {336, 776},
			'\'': {360, 776}, '(': {384, 776}, ')': {408, 776}, '*': {432, 776}, '+': {456, 776},
			',': {480, 776}, '-': {504, 776}, '.': {528, 776}, '/': {552, 776}, ':': {576, 776},
			';': {600, 776}, '<': {624, 776}, '=': {648, 776}, '>': {672, 776}, '?': {696, 776},
			'@': {720, 776}, '[': {744, 776}, '\\': {768, 776}, ']': {792, 776}, '^': {816, 776},
			'_': {840, 776}, '`': {864, 776}, '{': {888, 776}, '|': {912, 776}, '}': {936, 776},
			'~': {960, 776},
		},
		ExpDimXY:    [2]int{1360, 836},
		BoardConfig: standardBoardConfig,
	},
}

// Some diagrams may help understand the rendering code.

// Initial version:
// not to scale:
// +---------------+ - a
// | +-----------+ | - b (b-a = padTop)
// | | header    | |
// | +-----------+ | - c (c-b = headerHeight)
// | +-----------+ | - d (d-c = padHeader)
// | | board     | |
// | |           | |
// | |           | |
// | |           | |
// | +-----------+ | - e
// +---------------+ - f (f-e = padBottom)
// | |           | |
// w x           y z (x-w = padLeft, z-y = padRight)
//
// Board sprites are squareDim * squareDim and are opaque.
// Tile sprites are squareDim * squareDim and are transparent.
//
// header:
// - header.png is left-aligned at x and cropped past y
// - the top-left pixel is used as background (to fill z-y, x-w, f-e,
//   d-c, b-a, and the part to the right of the header)
// - (assumption: the logo has rounded corner)
//
// board:
// - e-d and y-x exactly fit the board, plus one pixel each
// - the board spaces have lines at bottom and left
// - so one pixel high of the bottom row and one pixel wide of the leftmost
//   column of the NoBonus square are repeated as the top and right borders of
//   the board
// - hence, board origin is at (x, d+1) (to account for the additional padding)

// Second version:
// In addition to above.
// +---------------+
// | +-----------+ | - b
// | | header+   | |
// | +-----------+ | - c
// | +-----------+ |
// | | board     | |
// | |           | |
// | |           | |
// | |           | |
// | +-----------+ | - g
// | +-----------+ | - h (h-g = padRack)
// | | rack      | |
// | +-----------+ | - i (i-h = squareDim)
// | +-----------+ | - j (j-i = padSpread)
// | | spread    | |
// | +-----------+ | - k (k-j = spreadHeight)
// +---------------+ - l (l-k = padBottom)
//   |           |
//   x           y
//
// Text sprites are monospacedFontDimX * monospacedFontDimY and are currently opaque.
//
// header+:
// - c-b is the taller of header height and 1 line of text (monospacedFontDimY)
// - header and text are vertically centered here
// - text and thrown tiles may overlap header image
// - header is still left-aligned, but if the header is too short would be centered
// - headerTop and textTop measure from top of image
// - cumulative scores at top right is "[score0] [score1]" (brackets are just colored spaces)
// - score earned this turn is at top center, as signed number ("+0")
// - exchanges and withdrawn tiles go to top center of this region (not necessarily textTop)
// - (assumption: cumulative scores will not overflow the given width, otherwise panic)
//
// rack:
// - current rack is shown centered between y-x
// - tiles have a gap of rackGap (see formula in code)
// - rackY measure from top of image
// - (assumption: rack will not overflow the given width, otherwise panic)
//
// spread:
// - spread bar is centered between y-x
// - it takes spreadMax steps to reach y or x

type BoardDrawer struct {
	Colors             []color.Color // all *image.Paletted in this struct share this palette
	HeaderPalImg       *image.Paletted
	Tile0Sprite        map[rune]*image.Paletted // SubImage of the original tiles sprites
	Tile1Sprite        map[rune]*image.Paletted
	BoardSprite        map[rune]*image.Paletted
	TextXSprite        map[rune]*image.Paletted
	Text0Sprite        map[rune]*image.Paletted
	Text1Sprite        map[rune]*image.Paletted
	BoardConfig        [][]rune
	EmptyBoardPalImg   *image.Paletted
	PadLeft            int
	PadTop             int
	PadRight           int
	PadBottom          int
	PadHeader          int
	PadRack            int
	RackGap            int
	HeaderHeight       int
	PadSpread          int
	SpreadHeight       int
	SpreadMax          int
	PaddingColorIndex  byte
	BackXColorIndex    byte
	Back0ColorIndex    byte
	Back1ColorIndex    byte
	LetterDistribution *alphabet.LetterDistribution
}

var BoardDrawers map[string]*BoardDrawer

func validateBoardConfig(boardConfig [][]rune) error {
	nRows := len(boardConfig)
	if nRows < 1 {
		return fmt.Errorf("expecting at least 1 row")
	}

	nCols := len(boardConfig[0])
	for i, row := range boardConfig {
		if i > 0 && len(row) != nCols {
			return fmt.Errorf("expecting row %d to have length %d", i+1, nCols)
		}
	}

	return nil
}

func getSprite(sprites map[rune]*image.Paletted, r, d rune) *image.Paletted {
	sprite, ok := sprites[r]
	if !ok {
		sprite = sprites[d]
	}
	return sprite
}

// Missed opportunity to use the word unicolor.
// Does not work with empty image.
func isImageOneColor(src *image.Paletted) bool {
	srcP := src.PixOffset(src.Rect.Min.X, src.Rect.Min.Y)
	c := src.Pix[srcP]
	dx, dy := src.Rect.Dx(), src.Rect.Dy()
	for y := 0; y < dy; y++ {
		for x := 0; x < dx; x++ {
			if c != src.Pix[srcP+x] {
				return false
			}
		}
		srcP += src.Stride
	}
	return true
}

var displacementRatioVerA []float64
var displacementRatioVerB []float64

func init() {
	// For animation.
	{
		numSteps := 10
		displacementRatioVerA = make([]float64, numSteps+1)
		for i := 1; i < numSteps; i++ {
			// These numbers range from 0.0 (start point) to 1.0 (end point).
			// There are some choices here, such as:
			// "linear": float64(i) / float64(numSteps)
			// "ease-out": math.Sin(float64(math.Pi/2) * float64(i) / float64(numSteps))
			// "ease-in-out": (1 - math.Cos(float64(math.Pi) * float64(i) / float64(numSteps)))/2
			// Reference: https://developers.google.com/web/fundamentals/design-and-ux/animations/the-basics-of-easing
			// This reference explains why ease-out is preferred.
			displacementRatioVerA[i] = math.Sin(float64(math.Pi/2) * float64(i) / float64(numSteps))
		}
		displacementRatioVerA[numSteps] = 1
	}
	{
		numSteps := 5
		displacementRatioVerB = make([]float64, numSteps+1)
		for i := 1; i < numSteps; i++ {
			displacementRatioVerB[i] = math.Sin(float64(math.Pi/2) * float64(i) / float64(numSteps))
		}
		displacementRatioVerB[numSteps] = 1
	}

	if err := validateBoardConfig(standardBoardConfig); err != nil {
		panic(fmt.Errorf("invalid boardConfig: %v", err))
	}
	if err := validateBoardConfig(superBoardConfig); err != nil {
		panic(fmt.Errorf("invalid boardConfig: %v", err))
	}

	lds := make(map[string]*alphabet.LetterDistribution)
	for _, entry := range []struct {
		name     string
		csvBytes []byte
	}{
		{name: "english", csvBytes: englishLetterDistributionCSVBytes},
		{name: "english_super", csvBytes: englishSuperLetterDistributionCSVBytes},
		{name: "french", csvBytes: frenchLetterDistributionCSVBytes},
		{name: "german", csvBytes: germanLetterDistributionCSVBytes},
		{name: "norwegian", csvBytes: norwegianLetterDistributionCSVBytes},
	} {
		ld, err := alphabet.ScanLetterDistribution(bytes.NewReader(entry.csvBytes))
		if err != nil {
			panic(fmt.Errorf("invalid letterDistribution for %s: %v", entry.name, err))
		}
		lds[entry.name] = ld
	}

	headerImg, headerColors, err := loadImageAndDistinctOpaqueColors(headerBytes)
	if err != nil {
		panic(fmt.Errorf("can't load headerImg: %v", err))
	}
	padLeft := 10
	padTop := 10
	padRight := 10
	padBottom := 10
	padHeader := 10
	padRack := 10
	rackGap := int(math.RoundToEven(float64(squareDim) * 0.1))
	padSpread := 10
	spreadHeight := 10
	spreadMax := 200
	headerHeight := headerImg.Bounds().Dy()

	ret := make(map[string]*BoardDrawer)
	for k, tptm := range tilesMeta {
		ld, ok := lds[k]
		if !ok {
			panic(fmt.Errorf("no letterDistribution for %s", k))
		}

		tilesImg, tilesImgColors, err := loadImageAndDistinctOpaqueColors(tptm.TilesBytes)
		if err != nil {
			panic(fmt.Errorf("can't load tilesImg for %s: %v", k, err))
		}
		if tilesImg.Bounds().Max != image.Pt(tptm.ExpDimXY[0], tptm.ExpDimXY[1]) {
			panic(fmt.Errorf("tilesImg for %s has incorrect bounds: %v", k, tilesImg.Bounds()))
		}

		// Add header image's palette to tiles image's palette.
		// There is no requirement that all tiles images have the same palette,
		// so they are mixed separately.
		for c := range headerColors {
			tilesImgColors[c] = struct{}{}
		}

		tilesImgPal, err := serializePalette(tilesImgColors)
		if err != nil {
			panic(fmt.Errorf("can't build palette for %s: %v", k, err))
		}

		headerPalImg := cloneToPaletted(headerImg, tilesImgPal)
		tilesPalImg := cloneToPaletted(tilesImg, tilesImgPal)

		tile0Sprite := make(map[rune]*image.Paletted)
		for kk, vv := range tptm.Tile0Src {
			tile0Sprite[kk] = tilesPalImg.SubImage(image.Rect(vv[0], vv[1], vv[0]+squareDim, vv[1]+squareDim)).(*image.Paletted)
		}
		tile1Sprite := make(map[rune]*image.Paletted)
		for kk, vv := range tptm.Tile1Src {
			tile1Sprite[kk] = tilesPalImg.SubImage(image.Rect(vv[0], vv[1], vv[0]+squareDim, vv[1]+squareDim)).(*image.Paletted)
		}
		boardSprite := make(map[rune]*image.Paletted)
		for kk, vv := range tptm.BoardSrc {
			boardSprite[kk] = tilesPalImg.SubImage(image.Rect(vv[0], vv[1], vv[0]+squareDim, vv[1]+squareDim)).(*image.Paletted)
		}
		textXSprite := make(map[rune]*image.Paletted)
		for kk, vv := range tptm.TextXSrc {
			textXSprite[kk] = tilesPalImg.SubImage(image.Rect(vv[0], vv[1], vv[0]+monospacedFontDimX, vv[1]+monospacedFontDimY)).(*image.Paletted)
		}
		text0Sprite := make(map[rune]*image.Paletted)
		for kk, vv := range tptm.Text0Src {
			text0Sprite[kk] = tilesPalImg.SubImage(image.Rect(vv[0], vv[1], vv[0]+monospacedFontDimX, vv[1]+monospacedFontDimY)).(*image.Paletted)
		}
		text1Sprite := make(map[rune]*image.Paletted)
		for kk, vv := range tptm.Text1Src {
			text1Sprite[kk] = tilesPalImg.SubImage(image.Rect(vv[0], vv[1], vv[0]+monospacedFontDimX, vv[1]+monospacedFontDimY)).(*image.Paletted)
		}

		// Mandatory character.
		if sprite, ok := textXSprite[' ']; !(ok && isImageOneColor(sprite)) {
			panic(fmt.Errorf("textX space for %s is not single color", k))
		}
		if sprite, ok := text0Sprite[' ']; !(ok && isImageOneColor(sprite)) {
			panic(fmt.Errorf("text0 space for %s is not single color", k))
		}
		if sprite, ok := text1Sprite[' ']; !(ok && isImageOneColor(sprite)) {
			panic(fmt.Errorf("text1 space for %s is not single color", k))
		}

		paddingColorIndex := headerPalImg.Pix[0] // use top left pixel color

		nRows := len(tptm.BoardConfig)
		nCols := len(tptm.BoardConfig[0])
		emptyBoardPalImg := image.NewPaletted(image.Rect(0, 0, nCols*squareDim+1, 1+nRows*squareDim), tilesImgPal)
		defaultBoardSpace := boardSprite[' ']
		for r := 0; r < nRows; r++ {
			for c := 0; c < nCols; c++ {
				fastSpriteDrawSrc(emptyBoardPalImg, image.Pt(c*squareDim, 1+r*squareDim), getSprite(boardSprite, tptm.BoardConfig[r][c], ' '))
			}
		}

		// Missing borders. Add 1 px at top and right.
		// The default board space sprite has bottom and left borders.
		sprite := defaultBoardSpace.SubImage(image.Rect(0, squareDim-1, squareDim, squareDim).Add(defaultBoardSpace.Bounds().Min)).(*image.Paletted)
		// Copy bottom border to top of board.
		// This must be what aboveboard means.
		x, y := 0, 0
		for c := 0; c < nCols; c++ {
			fastSpriteDrawSrc(emptyBoardPalImg, image.Pt(x, y), sprite)
			x += squareDim
		}
		// Copy bottom-left pixel of sample to top right of board.
		sprite = defaultBoardSpace.SubImage(image.Rect(0, squareDim-1, 1, squareDim).Add(defaultBoardSpace.Bounds().Min)).(*image.Paletted)
		fastSpriteDrawSrc(emptyBoardPalImg, image.Pt(x, y), sprite)
		y++
		sprite = defaultBoardSpace.SubImage(image.Rect(0, 0, 1, squareDim).Add(defaultBoardSpace.Bounds().Min)).(*image.Paletted)
		// Copy left border to right.
		for r := 0; r < nRows; r++ {
			fastSpriteDrawSrc(emptyBoardPalImg, image.Pt(x, y), sprite)
			y += squareDim
		}

		ret[k] = &BoardDrawer{
			Colors:             tilesImgPal,
			HeaderPalImg:       headerPalImg,
			Tile0Sprite:        tile0Sprite,
			Tile1Sprite:        tile1Sprite,
			BoardSprite:        boardSprite,
			TextXSprite:        textXSprite,
			Text0Sprite:        text0Sprite,
			Text1Sprite:        text1Sprite,
			BoardConfig:        tptm.BoardConfig,
			EmptyBoardPalImg:   emptyBoardPalImg,
			PadLeft:            padLeft,
			PadTop:             padTop,
			PadRight:           padRight,
			PadBottom:          padBottom,
			PadHeader:          padHeader,
			PadRack:            padRack,
			RackGap:            rackGap,
			HeaderHeight:       headerHeight,
			PadSpread:          padSpread,
			SpreadHeight:       spreadHeight,
			SpreadMax:          spreadMax,
			PaddingColorIndex:  paddingColorIndex,
			BackXColorIndex:    textXSprite[' '].Pix[0],
			Back0ColorIndex:    text0Sprite[' '].Pix[0],
			Back1ColorIndex:    text1Sprite[' '].Pix[0],
			LetterDistribution: ld,
		}
	}

	BoardDrawers = ret
}

// The previous index. Should work for any number of players.
func previousNicknameIndex(history *macondopb.GameHistory, which int) int {
	if which == 0 {
		return len(history.Players) - 1
	}
	return which - 1
}

// Nickname index within history.Players. Not adjusted for SecondWentFirst.
func nicknameIndex(history *macondopb.GameHistory, evt *macondopb.GameEvent) int {
	for k, v := range history.Players {
		if evt.Nickname == v.Nickname {
			return k
		}
	}
	return -1
}

// Blank tiles are undeclared unless they are on board.
func reblank(r rune) rune {
	if r == unicode.ToLower(r) {
		return '?'
	}
	return r
}

func RenderImage(history *macondopb.GameHistory, wf WhichFile) ([]byte, error) {
	ver2Board := wf.Version == 2
	if ver2Board && history.PlayState != macondopb.PlayState_GAME_OVER {
		return nil, fmt.Errorf("game is not over yet")
	}

	isAnimatedB := wf.FileType == "animated-gif-b"
	isAnimated := isAnimatedB || wf.FileType == "animated-gif"
	numEvents := math.MaxInt
	if wf.HasNextEventNum {
		numEvents = wf.NextEventNum - 1
	}

	_, letterDistributionName, _ := game.HistoryToVariant(history)
	lang := strings.ToLower(letterDistributionName)
	bd, ok := BoardDrawers[lang]
	if !ok {
		return nil, fmt.Errorf("missing boardDrawer: %s", lang)
	}

	numPlayers := len(history.Players)
	if len(history.LastKnownRacks) != numPlayers {
		return nil, fmt.Errorf("invalid len(lastKnownRacks): %v racks for %v players", len(history.LastKnownRacks), numPlayers)
	}

	// Nothing is adjusted for SecondWentFirst.
	// For 0 <= turn < len(history.Events), [turn] is pre-turn and [turn+1] is post-turn.
	whoseTurn := make([]int, len(history.Events)+1) // [0] == 0.
	if history.SecondWentFirst && numPlayers > 1 {
		whoseTurn[0] = 1
	}
	{
		canHaveActiveAction := true
		contestedTilePlacementMoveIdx := -1
		for i, evt := range history.Events {
			expectedNicknameIndex := whoseTurn[i]
			whoseTurn[i+1] = expectedNicknameIndex
			isActiveAction := true
			switch evt.Type {
			case
				macondopb.GameEvent_TILE_PLACEMENT_MOVE,
				macondopb.GameEvent_PASS,
				macondopb.GameEvent_EXCHANGE,
				macondopb.GameEvent_UNSUCCESSFUL_CHALLENGE_TURN_LOSS:
				// The player spends the turn.
				whoseTurn[i+1] = (expectedNicknameIndex + 1) % numPlayers
			case
				macondopb.GameEvent_PHONY_TILES_RETURNED,
				macondopb.GameEvent_CHALLENGE_BONUS:
				// The player on turn keeps the turn, but the event is attributed to the previous player.
				expectedNicknameIndex = previousNicknameIndex(history, expectedNicknameIndex)
			case
				macondopb.GameEvent_END_RACK_PTS,
				macondopb.GameEvent_TIME_PENALTY,
				macondopb.GameEvent_END_RACK_PENALTY:
				// These are not actual actions.
				// Nonetheless, the event should still be attributed to one of the players.
				isActiveAction = false
				expectedNicknameIndex = nicknameIndex(history, evt)
				if expectedNicknameIndex < 0 || expectedNicknameIndex > numPlayers {
					return nil, fmt.Errorf("invalid nickname in event[%v]: %v", i, evt)
				}
				// For TIME_PENALTY, whose turn it is does not change.
				// For END_RACK_PTS/END_RACK_PENALTY, set turn to rack owner.
				// This works because active actions are no longer allowed after this.
				switch evt.Type {
				case macondopb.GameEvent_END_RACK_PTS:
					// For END_RACK_PTS, assume the rack belongs to the immediately preceding player.
					whoseTurn[i] = (expectedNicknameIndex + numPlayers - 1) % numPlayers
					whoseTurn[i+1] = whoseTurn[i]
				case macondopb.GameEvent_END_RACK_PENALTY:
					whoseTurn[i] = expectedNicknameIndex
					whoseTurn[i+1] = whoseTurn[i]
				}
			default:
				// Mistake-proof in case the jigglypuff evolves.
				// * protobuf
				return nil, fmt.Errorf("unknown event[%v]: %v", i, evt)
			}
			expectedNickname := history.Players[expectedNicknameIndex].Nickname
			if evt.Nickname != expectedNickname {
				return nil, fmt.Errorf("unexpected nickname in event[%v] (should be %v): %v", i, expectedNickname, evt)
			}
			if isActiveAction {
				if !canHaveActiveAction {
					return nil, fmt.Errorf("invalid active action in event[%v]: %v", i, evt)
				}
			} else {
				canHaveActiveAction = false // Passive actions cannot be followed by active actions.
			}
			switch evt.Type {
			case
				macondopb.GameEvent_UNSUCCESSFUL_CHALLENGE_TURN_LOSS,
				macondopb.GameEvent_PHONY_TILES_RETURNED,
				macondopb.GameEvent_CHALLENGE_BONUS:
				if contestedTilePlacementMoveIdx < 0 {
					return nil, fmt.Errorf("no relevant TILE_PLACEMENT_MOVE in event[%v]: %v", i, evt)
				}
			}
			contestedTilePlacementMoveIdx = -1
			if evt.Type == macondopb.GameEvent_TILE_PLACEMENT_MOVE {
				contestedTilePlacementMoveIdx = i
			}
		}
	}

	colorMapping := make([]int, numPlayers)
	for i := range colorMapping {
		colorMapping[i] = 1
	}
	colorMapping[whoseTurn[0]] = 0
	if wf.WhichColor >= 0 && wf.WhichColor <= 1 {
		for i := range colorMapping {
			colorMapping[i] = wf.WhichColor
		}
	}

	// For 0 <= turn < len(history.Events), [turn] is pre-turn and [turn+1] is post-turn.
	cumes := make([][]int32, len(history.Events)+1)
	cumes[0] = make([]int32, numPlayers) // Zeros.
	for i, evt := range history.Events {
		cumes[i+1] = make([]int32, numPlayers)
		copy(cumes[i+1], cumes[i])
		cumes[i+1][nicknameIndex(history, evt)] = evt.Cumulative
	}

	// For 0 <= turn < len(history.Events), [turn] is pre-turn and [turn+1] is post-turn.
	racks := make([][][]rune, len(history.Events)+1)
	{
		racki := make([][]rune, numPlayers)
		for p := 0; p < numPlayers; p++ {
			rack := []rune(history.LastKnownRacks[p])
			// Racks may not always be pre-sorted.
			sort.Slice(rack, func(i, j int) bool {
				return bd.LetterDistribution.SortOrder[rack[i]] < bd.LetterDistribution.SortOrder[rack[j]]
			})
			racki[p] = rack
		}
		racks[len(history.Events)] = racki
	}
	for t := len(history.Events) - 1; t >= 0; t-- {
		evt := history.Events[t]
		switch evt.Type {
		case
			macondopb.GameEvent_END_RACK_PTS,     // This event has Opponent's Rack, which is already correct.
			macondopb.GameEvent_TIME_PENALTY,     // This event should not change the rack.
			macondopb.GameEvent_END_RACK_PENALTY: // This event should not change the rack.
			racks[t] = racks[t+1]
		default:
			racki := make([][]rune, numPlayers)
			copy(racki, racks[t+1])
			rack := []rune(evt.Rack)
			// Racks may not always be pre-sorted.
			sort.Slice(rack, func(i, j int) bool {
				return bd.LetterDistribution.SortOrder[rack[i]] < bd.LetterDistribution.SortOrder[rack[j]]
			})
			racki[nicknameIndex(history, evt)] = rack
			racks[t] = racki
		}
	}

	nRows := len(bd.BoardConfig)
	nCols := len(bd.BoardConfig[0])
	onBoard := func(r, c int) bool {
		return r >= 0 && r < nRows && c >= 0 && c < nCols
	}

	// This is just the board. It gets translated differently depending on the layout version.
	emptyBoardPalImg := bd.EmptyBoardPalImg

	boardOrigin := image.Pt(bd.PadLeft, bd.PadTop+bd.HeaderHeight+bd.PadHeader+1)
	twiceHeaderAreaMiddle := 2*bd.PadTop + bd.HeaderHeight
	if ver2Board {
		// Ensure enough height for 1 line of text.
		addHeight := monospacedFontDimY - bd.HeaderHeight
		if addHeight > 0 {
			boardOrigin.Y += addHeight
			twiceHeaderAreaMiddle += addHeight
		}
	}
	desiredBounds := image.Rect(0, 0, boardOrigin.X+emptyBoardPalImg.Bounds().Dx()+bd.PadRight, boardOrigin.Y+emptyBoardPalImg.Bounds().Dy()+bd.PadBottom)
	if ver2Board {
		desiredBounds.Max.Y += bd.PadRack + squareDim + bd.PadSpread + bd.SpreadHeight
	}
	canvasPalImg := image.NewPaletted(desiredBounds, bd.Colors)
	canvasPalImg.Pix[0] = bd.PaddingColorIndex
	fillPaletted(canvasPalImg)
	headerImgRight := bd.PadLeft + bd.HeaderPalImg.Bounds().Dx()
	headerImgRightCannotExceed := desiredBounds.Dx() - bd.PadRight
	if headerImgRightCannotExceed < headerImgRight {
		headerImgRight = headerImgRightCannotExceed
	}
	headerTop := (twiceHeaderAreaMiddle - bd.HeaderHeight) / 2
	fastDrawOver(canvasPalImg, image.Rect(bd.PadLeft, headerTop, headerImgRight, headerTop+bd.HeaderHeight), bd.HeaderPalImg, image.Point{})
	textTop := (twiceHeaderAreaMiddle - monospacedFontDimY) / 2
	fastSpriteDrawSrc(canvasPalImg, image.Pt(boardOrigin.X, boardOrigin.Y-1), emptyBoardPalImg)
	rackY := desiredBounds.Dy() - (squareDim + bd.PadSpread + bd.SpreadHeight + bd.PadBottom)

	patchImage := func(evt *macondopb.GameEvent, callback func(r, c int, ch rune)) {
		r, c := int(evt.Row), int(evt.Column)
		dr, dc := 0, 1
		if evt.Direction == macondopb.GameEvent_VERTICAL {
			dr, dc = 1, 0
		}
		for _, ch := range evt.PlayedTiles {
			if ch != alphabet.ASCIIPlayedThrough && onBoard(r, c) {
				callback(r, c, ch)
			}
			r, c = r+dr, c+dc
		}
	}
	textSprite := func(which int) map[rune]*image.Paletted {
		if colorMapping[which] != 0 {
			return bd.Text1Sprite
		}
		return bd.Text0Sprite
	}
	tileSprite := func(which int) map[rune]*image.Paletted {
		if colorMapping[which] != 0 {
			return bd.Tile1Sprite
		}
		return bd.Tile0Sprite
	}
	backColorIndex := func(which int) byte {
		if colorMapping[which] != 0 {
			return bd.Back1ColorIndex
		}
		return bd.Back0ColorIndex
	}
	type flyingSprite struct {
		pt0 image.Point
		pt1 image.Point
		src *image.Paletted
		ch  rune
	}
	var flyingSpritesBuf []flyingSprite
	// Home rack refers to the tiles at the rack, where they most feel at home, before being sent anywhere.
	// Pass a slice to append to, to avoid reallocating each time.
	buildHomeRack := func(turn int, arr []flyingSprite) []flyingSprite {
		// The rack of the turn-to-move. This can be different from the event's nickname.
		which := whoseTurn[turn]
		sprites := tileSprite(which)
		rack := racks[turn][which]
		pt := image.Pt((bd.PadLeft+canvasPalImg.Bounds().Dx()-bd.PadRight-len(rack)*(squareDim+bd.RackGap)+bd.RackGap)/2, rackY)
		for _, ch := range rack {
			arr = append(arr, flyingSprite{pt0: pt, pt1: pt, src: getSprite(sprites, ch, '?'), ch: ch})
			pt.X += squareDim + bd.RackGap
		}
		return arr
	}
	var cumeBuf0 []byte
	var cumeBuf1 []byte
	paintCumes := func(turn int) image.Rectangle {
		// This function attempts to not crash when numPlayers != 2.
		if numPlayers <= 0 {
			return image.Rectangle{}
		}
		cumeBuf0 = strconv.AppendInt(cumeBuf0[:0], int64(cumes[turn][0]), 10)
		cumeBuf1 = cumeBuf1[:0]
		if numPlayers > 1 {
			cumeBuf1 = strconv.AppendInt(cumeBuf1, int64(cumes[turn][1]), 10)
		}
		cumeBuf0Index := 0
		if history.SecondWentFirst && numPlayers > 1 {
			cumeBuf0, cumeBuf1 = cumeBuf1, cumeBuf0
			cumeBuf0Index = 1
		}
		gap := 2
		if numPlayers > 1 {
			gap += 3
		}
		pt := image.Pt(canvasPalImg.Bounds().Dx()-bd.PadRight-(len(cumeBuf0)+gap+len(cumeBuf1))*monospacedFontDimX, textTop)
		startX := pt.X
		sprite := textSprite(cumeBuf0Index)
		// We have established that spaces have a single color, but it is still easier to draw text normally.
		fastSpriteDrawSrc(canvasPalImg, pt, sprite[' '])
		pt.X += monospacedFontDimX
		for _, ch := range cumeBuf0 {
			fastSpriteDrawSrc(canvasPalImg, pt, getSprite(sprite, rune(ch), ' '))
			pt.X += monospacedFontDimX
		}
		fastSpriteDrawSrc(canvasPalImg, pt, sprite[' '])
		pt.X += monospacedFontDimX
		if numPlayers > 1 {
			fastSpriteDrawSrc(canvasPalImg, pt, bd.TextXSprite[' '])
			pt.X += monospacedFontDimX
			sprite = textSprite(cumeBuf0Index ^ 1)
			fastSpriteDrawSrc(canvasPalImg, pt, sprite[' '])
			pt.X += monospacedFontDimX
			for _, ch := range cumeBuf1 {
				fastSpriteDrawSrc(canvasPalImg, pt, getSprite(sprite, rune(ch), ' '))
				pt.X += monospacedFontDimX
			}
			fastSpriteDrawSrc(canvasPalImg, pt, sprite[' '])
			pt.X += monospacedFontDimX
		}
		return image.Rect(startX, pt.Y, pt.X, pt.Y+monospacedFontDimY)
	}
	paintSpread := func(turn int) image.Rectangle {
		// This function attempts to not crash when numPlayers != 2.
		if numPlayers <= 0 {
			return image.Rectangle{}
		}
		spread := -int(cumes[turn][0])
		if numPlayers > 1 {
			spread += int(cumes[turn][1])
		}
		if spread == 0 {
			return image.Rectangle{}
		}
		negativeIndex := 0
		if history.SecondWentFirst && numPlayers > 1 {
			negativeIndex = 1
			spread = -spread
		}
		twiceSpreadMidX := bd.PadLeft + canvasPalImg.Bounds().Dx() - bd.PadRight
		twiceSpreadWidth := canvasPalImg.Bounds().Dx() - (bd.PadLeft + bd.PadRight)
		spreadBottomY := canvasPalImg.Bounds().Dy() - bd.PadBottom
		spreadTopY := spreadBottomY - bd.SpreadHeight
		var rect image.Rectangle
		if spread > 0 {
			cappedAbsSpread := spread
			if cappedAbsSpread > bd.SpreadMax {
				cappedAbsSpread = bd.SpreadMax
			}
			barWidth := int(math.RoundToEven(float64(twiceSpreadWidth) * float64(cappedAbsSpread) / float64(bd.SpreadMax)))
			rect = image.Rect(twiceSpreadMidX/2, spreadTopY, (twiceSpreadMidX+barWidth)/2, spreadBottomY)
			fillPalettedRect(canvasPalImg, rect, backColorIndex(negativeIndex^1))
		} else {
			cappedAbsSpread := -spread
			if cappedAbsSpread > bd.SpreadMax {
				cappedAbsSpread = bd.SpreadMax
			}
			barWidth := int(math.RoundToEven(float64(twiceSpreadWidth) * float64(cappedAbsSpread) / float64(bd.SpreadMax)))
			rect = image.Rect((twiceSpreadMidX-barWidth)/2, spreadTopY, twiceSpreadMidX/2, spreadBottomY)
			fillPalettedRect(canvasPalImg, rect, backColorIndex(negativeIndex))
		}
		return rect
	}
	paintScoreDiff := func(turn int) image.Rectangle {
		// For 0 <= turn < len(history.Events).
		// Score difference always belongs to stated nickname.
		// Score diff refers to the difference to the next turn's cumulative score (not spread).
		// The protobuf does not dedicate one specific field for this purpose.
		which := nicknameIndex(history, history.Events[turn])
		scoreDiff := int64(cumes[turn+1][which] - cumes[turn][which])
		cumeBuf0 = cumeBuf0[:0]
		if scoreDiff >= 0 {
			cumeBuf0 = append(cumeBuf0, '+')
		}
		cumeBuf0 = strconv.AppendInt(cumeBuf0, scoreDiff, 10)
		pt := image.Pt((bd.PadLeft+canvasPalImg.Bounds().Dx()-bd.PadRight-len(cumeBuf0)*monospacedFontDimX)/2, textTop)
		startX := pt.X
		for _, ch := range cumeBuf0 {
			fastSpriteDrawSrc(canvasPalImg, pt, getSprite(bd.TextXSprite, rune(ch), ' '))
			pt.X += monospacedFontDimX
		}
		return image.Rect(startX, pt.Y, pt.X, pt.Y+monospacedFontDimY)
	}

	evts := history.Events
	if numEvents <= 0 {
		evts = evts[:0]
	} else if numEvents < len(evts) {
		evts = evts[:numEvents]
	}
	if !isAnimated {
		// When not animating, a TILE_PLACEMENT_MOVE that is canceled by PHONY_TILES_RETURNED is never drawn at all.
		lastPlaceIndex := -1
		setLastPlaceIndex := func(i int) {
			if lastPlaceIndex >= 0 {
				evt := evts[lastPlaceIndex]
				which := whoseTurn[lastPlaceIndex]
				sprites := tileSprite(which)
				patchImage(evt, func(r, c int, ch rune) {
					pt := image.Pt(boardOrigin.X+c*squareDim, boardOrigin.Y+r*squareDim)
					fastSpriteDrawOver(canvasPalImg, pt, getSprite(sprites, ch, '?'))
				})
			}
			lastPlaceIndex = i
		}
		for i, evt := range evts {
			switch evt.Type {
			case macondopb.GameEvent_TILE_PLACEMENT_MOVE:
				setLastPlaceIndex(i)
			case macondopb.GameEvent_PHONY_TILES_RETURNED:
				lastPlaceIndex = -1
			}
		}
		setLastPlaceIndex(-1)

		if ver2Board {
			paintCumes(len(evts))
			paintSpread(len(evts))
			flyingSpritesBuf = buildHomeRack(len(evts), flyingSpritesBuf[:0])
			for k := range flyingSpritesBuf {
				elt := &flyingSpritesBuf[k]
				pt := elt.pt0
				fastSpriteDrawOver(canvasPalImg, pt, elt.src)
			}
		}

		var buf bytes.Buffer
		var err error
		if wf.FileType == "png" {
			err = png.Encode(&buf, canvasPalImg)
		} else {
			// This might not be worth it. The PNG is smaller after switching from image.NRGBA to image.Paletted.
			err = gif.EncodeAll(&buf, &gif.GIF{
				Image: []*image.Paletted{canvasPalImg},
				Delay: []int{0},
				Config: image.Config{
					ColorModel: canvasPalImg.Palette,
					Width:      canvasPalImg.Bounds().Dx(),
					Height:     canvasPalImg.Bounds().Dy(),
				},
			})
		}
		if err != nil {
			return nil, err
		}
		return buf.Bytes(), nil
	}

	// The boardPalImg only contains header and the current board.
	boardPalImg := image.NewPaletted(canvasPalImg.Bounds(), bd.Colors)
	copy(boardPalImg.Pix, canvasPalImg.Pix)
	lastFramePalImg := image.NewPaletted(canvasPalImg.Bounds(), bd.Colors)
	// Since every frame uses the same palette, specifying it once here shrinks the output file.
	// Otherwise each frame encodes a copy of the palette.
	agif := &gif.GIF{
		Config: image.Config{
			ColorModel: canvasPalImg.Palette,
			Width:      canvasPalImg.Bounds().Dx(),
			Height:     canvasPalImg.Bounds().Dy(),
		},
	}
	// This is a gif, so the delay is in centiseconds.
	// Refer to https://www.biphelps.com/blog/The-Fastest-GIF-Does-Not-Exist for why 2 centiseconds is the minimum.
	addFrame := func(bounds image.Rectangle, delay int) {
		if len(agif.Delay) == 0 {
			// Always record the first frame completely.
			// This is a copy (we would be mutating lastFramePalImg later).
			frameDiffPalImg := image.NewPaletted(bounds, bd.Colors)
			fastDrawSrc(frameDiffPalImg, bounds, canvasPalImg, bounds.Min)
			fastDrawSrc(lastFramePalImg, bounds, canvasPalImg, bounds.Min)
			agif.Image = append(agif.Image, frameDiffPalImg)
			agif.Delay = append(agif.Delay, delay)
		} else {
			// Determine the bounds that have any changes.
			bounds = croppedBoundsDiff(canvasPalImg, bounds, lastFramePalImg, bounds.Min)
			if bounds.Empty() {
				// Nothing changes. just increase delay of previous frame.
				agif.Delay[len(agif.Delay)-1] += delay
			} else {
				// Make pixels that are the same as lastFramePalImg transparent. This is likelier to compress better, but not always.
				frameDiffPalImg := image.NewPaletted(bounds, bd.Colors)
				fastDrawSrc(frameDiffPalImg, bounds, canvasPalImg, bounds.Min)
				fastUndrawOver(frameDiffPalImg, bounds, lastFramePalImg, bounds.Min)
				fastDrawSrc(lastFramePalImg, bounds, canvasPalImg, bounds.Min)
				agif.Image = append(agif.Image, frameDiffPalImg)
				agif.Delay = append(agif.Delay, delay)
			}
		}
	}

	rect := canvasPalImg.Bounds()
	if ver2Board {
		lastPlaceIndex := -1
		for i, evt := range evts {
			flyingSpritesBuf = buildHomeRack(i, flyingSpritesBuf[:0])
			lenRack := len(flyingSpritesBuf)
			hasAnimation := true

			switch evt.Type {
			case macondopb.GameEvent_TILE_PLACEMENT_MOVE:
				// Place tiles from rack.
				lastPlaceIndex = i
				patchImage(evt, func(r, c int, ch rune) {
					pt := image.Pt(boardOrigin.X+c*squareDim, boardOrigin.Y+r*squareDim)
					ch = reblank(ch)
					for k := range flyingSpritesBuf {
						// This is quadratic, but rack length is small.
						if ch == flyingSpritesBuf[k].ch && flyingSpritesBuf[k].pt0 == flyingSpritesBuf[k].pt1 {
							flyingSpritesBuf[k].pt1 = pt
							break
						}
					}
				})
			case macondopb.GameEvent_PHONY_TILES_RETURNED:
				// Remove opponent's tiles.
				withdrawnEvt := evts[lastPlaceIndex]
				which := whoseTurn[lastPlaceIndex]
				sprites := tileSprite(which)
				numRet := 0
				patchImage(withdrawnEvt, func(r, c int, ch rune) { numRet++ })
				pt := image.Pt((bd.PadLeft+canvasPalImg.Bounds().Dx()-bd.PadRight-numRet*squareDim)/2, bd.PadTop)
				patchImage(withdrawnEvt, func(r, c int, ch rune) {
					ch = reblank(ch)
					flyingSpritesBuf = append(flyingSpritesBuf, flyingSprite{
						pt0: image.Pt(boardOrigin.X+c*squareDim, boardOrigin.Y+r*squareDim),
						pt1: pt, src: getSprite(sprites, ch, '?'), ch: ch})
					pt.X += squareDim
				})
			case macondopb.GameEvent_EXCHANGE:
				// Set aside unwanted tiles.
				// Only affect exchanged tiles found on rack.
				numRet := 0
				for _, ch := range evt.Exchanged {
					for k := range flyingSpritesBuf {
						// This is quadratic, but rack length is small.
						if ch == flyingSpritesBuf[k].ch && flyingSpritesBuf[k].pt0 == flyingSpritesBuf[k].pt1 {
							flyingSpritesBuf[k].pt1.X++
							numRet++
							break
						}
					}
				}
				pt := image.Pt((bd.PadLeft+canvasPalImg.Bounds().Dx()-bd.PadRight-numRet*squareDim)/2, bd.PadTop)
				// Preserve sorting order.
				for k := range flyingSpritesBuf {
					if flyingSpritesBuf[k].pt0 != flyingSpritesBuf[k].pt1 {
						flyingSpritesBuf[k].pt1 = pt
						pt.X += squareDim
					}
				}
			default:
				hasAnimation = false
			}

			cumesRect := paintCumes(i)
			spreadRect := paintSpread(i)
			tilesRect := image.Rectangle{}
			// Slicing for [:lenRack] keep only tiles on rack and excludes tiles affected by PHONY_TILES_RETURNED.
			for k := range flyingSpritesBuf[:lenRack] {
				elt := &flyingSpritesBuf[k]
				pt := elt.pt0
				fastSpriteDrawOver(canvasPalImg, pt, elt.src)
				tilesRect = tilesRect.Union(image.Rect(pt.X, pt.Y, pt.X+squareDim, pt.Y+squareDim))
			}

			// Each event takes 50 centiseconds. The first 30 centiseconds is a still frame.
			thisDelay := 30
			if isAnimatedB {
				// Version B delays for 70 centiseconds, then spends 30 centiseconds on the animation.
				thisDelay = 70
			}
			addFrame(rect.Union(cumesRect.Union(spreadRect).Union(tilesRect)), thisDelay)
			scoreDiffRect := paintScoreDiff(i)
			if hasAnimation {
				displacementRatio := displacementRatioVerA
				if isAnimatedB {
					displacementRatio = displacementRatioVerB
				}
				thisDelay = 2
				if isAnimatedB {
					// In version B, displacementRatio has 5 steps, and it should take 30 centiseconds here.
					thisDelay = 6
				}
				// With animation, animate every 2 centiseconds.
				// When displacementRatio has 10 steps (len() == 11), this works out to be 20 centiseconds.

				// The boardPalImg layer persists to the next turn.
				// The canvasPalImg is the current canvas, and includes boardPalImg plus any temporary sprites.
				// Typically, we draw the temporary sprites on the canvas, while keeping track of the rectangles they encompass.
				// When adding a frame we draw the union of the bounds added by the current frame and by the previous frame,
				// because that previous frame will mostly be erased.

				// However, changes for PHONY_TILES_RETURNED (and later TILE_PLACEMENT_MOVE) persist.
				// So, those are first drawn on the board and then mirrored onto canvas instead.
				rect = image.Rectangle{}
				if evt.Type == macondopb.GameEvent_PHONY_TILES_RETURNED {
					patchImage(evts[lastPlaceIndex], func(r, c int, ch rune) {
						pt := image.Pt(boardOrigin.X+c*squareDim, boardOrigin.Y+r*squareDim)
						fastSpriteDrawSrc(boardPalImg, pt, getSprite(bd.BoardSprite, bd.BoardConfig[r][c], ' '))
						rect = rect.Union(image.Rect(pt.X, pt.Y, pt.X+squareDim, pt.Y+squareDim))
					})
					fastDrawSrc(canvasPalImg, rect, boardPalImg, rect.Min)
				}
				// The score diff is first unveiled in this frame.
				rect = rect.Union(scoreDiffRect.Union(tilesRect))
				for f := 1; f < len(displacementRatio); f++ {
					// Erase flying tiles.
					fastDrawSrc(canvasPalImg, tilesRect, boardPalImg, tilesRect.Min)
					// Apparently displacementRatio[0] is not used. It's ok. Helps avoid off-by-one errors.
					dpr := displacementRatio[f]
					tilesRect = image.Rectangle{}
					// Non-moving tiles are below.
					// Note that this is actually inefficient because we keep drawing the same non-moving tiles.
					// Maybe this could be sped up.
					for k := range flyingSpritesBuf {
						elt := &flyingSpritesBuf[k]
						if elt.pt0 == elt.pt1 {
							pt := elt.pt0
							fastSpriteDrawOver(canvasPalImg, pt, elt.src)
							// Do not immediately include this rect.
						}
					}
					// Moving tiles are above. This ordering matters in the few frames when they overlap.
					for k := range flyingSpritesBuf {
						elt := &flyingSpritesBuf[k]
						if elt.pt0 != elt.pt1 {
							pt := image.Pt(elt.pt0.X+int(math.RoundToEven(float64(elt.pt1.X-elt.pt0.X)*dpr)), elt.pt0.Y+int(math.RoundToEven(float64(elt.pt1.Y-elt.pt0.Y)*dpr)))
							fastSpriteDrawOver(canvasPalImg, pt, elt.src)
							tilesRect = tilesRect.Union(image.Rect(pt.X, pt.Y, pt.X+squareDim, pt.Y+squareDim))
						}
					}
					// Check if non-moving tiles need to be drawn. They tend to be further away from moving tiles, that this optimization is worth it.
					for k := range flyingSpritesBuf {
						elt := &flyingSpritesBuf[k]
						if elt.pt0 == elt.pt1 {
							pt := elt.pt0
							tilesRect = tilesRect.Union(croppedBoundsDiff(canvasPalImg, image.Rect(pt.X, pt.Y, pt.X+squareDim, pt.Y+squareDim), lastFramePalImg, pt))
						}
					}
					// tilesRect bounds the tiles in this frame only.
					// rect bounds the other changes (erasure of previous tilesRect, and adding score diff for the first frame).
					addFrame(rect.Union(tilesRect), thisDelay)
					rect = tilesRect
				}
				// Include non-moving tiles in tilesRect so they can be erased.
				for k := range flyingSpritesBuf {
					elt := &flyingSpritesBuf[k]
					if elt.pt0 == elt.pt1 {
						pt := elt.pt0
						tilesRect = tilesRect.Union(image.Rect(pt.X, pt.Y, pt.X+squareDim, pt.Y+squareDim))
					}
				}
			} else {
				// With no animation, the remaining 20 centiseconds is the same still frame, with the score diff.
				addFrame(scoreDiffRect, 20)
			}
			// Erase stuffs.
			fastDrawSrc(canvasPalImg, cumesRect, boardPalImg, cumesRect.Min)
			fastDrawSrc(canvasPalImg, spreadRect, boardPalImg, spreadRect.Min)
			fastDrawSrc(canvasPalImg, tilesRect, boardPalImg, tilesRect.Min)
			fastDrawSrc(canvasPalImg, scoreDiffRect, boardPalImg, scoreDiffRect.Min)
			rect = cumesRect.Union(spreadRect).Union(tilesRect).Union(scoreDiffRect)

			if evt.Type == macondopb.GameEvent_TILE_PLACEMENT_MOVE {
				which := whoseTurn[i]
				sprites := tileSprite(which)
				rectBoard := image.Rectangle{}
				patchImage(evt, func(r, c int, ch rune) {
					pt := image.Pt(boardOrigin.X+c*squareDim, boardOrigin.Y+r*squareDim)
					fastSpriteDrawOver(boardPalImg, pt, getSprite(sprites, ch, '?'))
					rectBoard = rectBoard.Union(image.Rect(pt.X, pt.Y, pt.X+squareDim, pt.Y+squareDim))
				})
				fastDrawSrc(canvasPalImg, rectBoard, boardPalImg, rectBoard.Min)
				rect = rect.Union(rectBoard)
			}
		}

		// The final frame.
		rect = rect.Union(paintCumes(len(evts))).Union(paintSpread(len(evts)))
		flyingSpritesBuf = buildHomeRack(len(evts), flyingSpritesBuf[:0])
		for k := range flyingSpritesBuf {
			elt := &flyingSpritesBuf[k]
			pt := elt.pt0
			fastSpriteDrawOver(canvasPalImg, pt, elt.src)
			rect = rect.Union(image.Rect(pt.X, pt.Y, pt.X+squareDim, pt.Y+squareDim))
		}
	} else {
		thisDelay := 50
		if isAnimatedB {
			// Version B delays for 100 centiseconds.
			thisDelay = 100
		}
		// In the original version, only TILE_PLACEMENT_MOVE and PHONY_TILES_RETURNED generate a frame.
		lastPlaceIndex := -1
		for i, evt := range evts {
			switch evt.Type {
			case macondopb.GameEvent_TILE_PLACEMENT_MOVE:
				addFrame(rect, thisDelay)
				rect = image.Rectangle{}
				lastPlaceIndex = i
				which := whoseTurn[lastPlaceIndex]
				sprites := tileSprite(which)
				patchImage(evt, func(r, c int, ch rune) {
					pt := image.Pt(boardOrigin.X+c*squareDim, boardOrigin.Y+r*squareDim)
					fastSpriteDrawOver(canvasPalImg, pt, getSprite(sprites, ch, '?'))
					rect = rect.Union(image.Rect(pt.X, pt.Y, pt.X+squareDim, pt.Y+squareDim))
				})
			case macondopb.GameEvent_PHONY_TILES_RETURNED:
				addFrame(rect, thisDelay)
				rect = image.Rectangle{}
				patchImage(evts[lastPlaceIndex], func(r, c int, ch rune) {
					pt := image.Pt(boardOrigin.X+c*squareDim, boardOrigin.Y+r*squareDim)
					fastSpriteDrawSrc(canvasPalImg, pt, getSprite(bd.BoardSprite, bd.BoardConfig[r][c], ' '))
					rect = rect.Union(image.Rect(pt.X, pt.Y, pt.X+squareDim, pt.Y+squareDim))
				})
			}
		}
	}

	// We want the final frame to stay for 2 sec (200 centiseconds).
	addFrame(rect, 200)

	// Chrome interprets Delay as the delay after the frame.
	// Mac Quick Look interprets Delay as the delay before the frame.
	// Solution: Use a transparent 1x1 frame to hold excess delay.
	minDelay := math.MaxInt
	for _, v := range agif.Delay {
		if v < minDelay {
			minDelay = v
		}
	}
	nFrames := len(agif.Delay)
	for _, v := range agif.Delay {
		if v != minDelay {
			nFrames++
		}
	}
	if nFrames != len(agif.Delay) {
		fillerTransparent1x1PalImg := image.NewPaletted(image.Rect(0, 0, 1, 1), bd.Colors)
		imgs := make([]*image.Paletted, 0, nFrames)
		delays := make([]int, 0, nFrames)
		for i, delay := range agif.Delay {
			imgs = append(imgs, agif.Image[i])
			delays = append(delays, minDelay)
			if delay != minDelay {
				imgs = append(imgs, fillerTransparent1x1PalImg)
				delays = append(delays, delay-minDelay)
			}
		}
		agif.Image = imgs
		agif.Delay = delays
	}

	var buf bytes.Buffer
	err := gif.EncodeAll(&buf, agif)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
