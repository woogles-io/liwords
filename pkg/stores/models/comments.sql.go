// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: comments.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/woogles-io/liwords/pkg/entity"
)

const addComment = `-- name: AddComment :one
INSERT INTO game_comments (
    id, game_id, author_id, event_number, comment
) SELECT gen_random_uuid(), games.id, $2, $3, $4
FROM games WHERE games.uuid = $1
RETURNING game_comments.id
`

type AddCommentParams struct {
	Uuid        pgtype.Text
	AuthorID    int32
	EventNumber int32
	Comment     string
}

func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, addComment,
		arg.Uuid,
		arg.AuthorID,
		arg.EventNumber,
		arg.Comment,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM game_comments
WHERE id = $1 and author_id = $2
`

type DeleteCommentParams struct {
	ID       uuid.UUID
	AuthorID int32
}

func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment, arg.ID, arg.AuthorID)
	return err
}

const deleteCommentNoAuthorSpecified = `-- name: DeleteCommentNoAuthorSpecified :exec
DELETE FROM game_comments WHERE id = $1
`

func (q *Queries) DeleteCommentNoAuthorSpecified(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCommentNoAuthorSpecified, id)
	return err
}

const getCommentsForAllGames = `-- name: GetCommentsForAllGames :many
SELECT game_comments.id, games.uuid as game_uuid, users.uuid as user_uuid,
    users.username, event_number, edited_at, comment, quickdata
FROM game_comments
JOIN games on game_comments.game_id = games.id
JOIN users on game_comments.author_id = users.id
ORDER BY game_comments.created_at DESC
LIMIT $1 OFFSET $2
`

type GetCommentsForAllGamesParams struct {
	Limit  int32
	Offset int32
}

type GetCommentsForAllGamesRow struct {
	ID          uuid.UUID
	GameUuid    pgtype.Text
	UserUuid    pgtype.Text
	Username    pgtype.Text
	EventNumber int32
	EditedAt    pgtype.Timestamptz
	Comment     string
	Quickdata   entity.Quickdata
}

func (q *Queries) GetCommentsForAllGames(ctx context.Context, arg GetCommentsForAllGamesParams) ([]GetCommentsForAllGamesRow, error) {
	rows, err := q.db.Query(ctx, getCommentsForAllGames, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsForAllGamesRow
	for rows.Next() {
		var i GetCommentsForAllGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.GameUuid,
			&i.UserUuid,
			&i.Username,
			&i.EventNumber,
			&i.EditedAt,
			&i.Comment,
			&i.Quickdata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsForCollectionGames = `-- name: GetCommentsForCollectionGames :many
SELECT game_comments.id, games.uuid as game_uuid, users.uuid as user_uuid,
    users.username, event_number, edited_at, comment, quickdata
FROM game_comments
JOIN games on game_comments.game_id = games.id
JOIN users on game_comments.author_id = users.id
JOIN collection_games cg on games.uuid = cg.game_id
JOIN collections c on cg.collection_id = c.id
WHERE c.uuid = $1
ORDER BY game_comments.created_at DESC
LIMIT $2 OFFSET $3
`

type GetCommentsForCollectionGamesParams struct {
	Uuid   uuid.UUID
	Limit  int32
	Offset int32
}

type GetCommentsForCollectionGamesRow struct {
	ID          uuid.UUID
	GameUuid    pgtype.Text
	UserUuid    pgtype.Text
	Username    pgtype.Text
	EventNumber int32
	EditedAt    pgtype.Timestamptz
	Comment     string
	Quickdata   entity.Quickdata
}

func (q *Queries) GetCommentsForCollectionGames(ctx context.Context, arg GetCommentsForCollectionGamesParams) ([]GetCommentsForCollectionGamesRow, error) {
	rows, err := q.db.Query(ctx, getCommentsForCollectionGames, arg.Uuid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsForCollectionGamesRow
	for rows.Next() {
		var i GetCommentsForCollectionGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.GameUuid,
			&i.UserUuid,
			&i.Username,
			&i.EventNumber,
			&i.EditedAt,
			&i.Comment,
			&i.Quickdata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsForGame = `-- name: GetCommentsForGame :many
SELECT game_comments.id, games.uuid as game_uuid, users.uuid as user_uuid, 
    users.username, event_number, edited_at, comment
from game_comments
join games on game_comments.game_id = games.id
join users on game_comments.author_id = users.id
where games.uuid = $1
ORDER BY game_comments.created_at ASC
`

type GetCommentsForGameRow struct {
	ID          uuid.UUID
	GameUuid    pgtype.Text
	UserUuid    pgtype.Text
	Username    pgtype.Text
	EventNumber int32
	EditedAt    pgtype.Timestamptz
	Comment     string
}

func (q *Queries) GetCommentsForGame(ctx context.Context, argUuid pgtype.Text) ([]GetCommentsForGameRow, error) {
	rows, err := q.db.Query(ctx, getCommentsForGame, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsForGameRow
	for rows.Next() {
		var i GetCommentsForGameRow
		if err := rows.Scan(
			&i.ID,
			&i.GameUuid,
			&i.UserUuid,
			&i.Username,
			&i.EventNumber,
			&i.EditedAt,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :exec
UPDATE game_comments SET comment = $1, edited_at = now()
WHERE id = $2 and author_id = $3
`

type UpdateCommentParams struct {
	Comment  string
	ID       uuid.UUID
	AuthorID int32
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.Exec(ctx, updateComment, arg.Comment, arg.ID, arg.AuthorID)
	return err
}
