// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rbac.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPermission = `-- name: AddPermission :exec
INSERT INTO permissions (code, description) VALUES ($1, $2)
`

type AddPermissionParams struct {
	Code        string
	Description string
}

func (q *Queries) AddPermission(ctx context.Context, arg AddPermissionParams) error {
	_, err := q.db.Exec(ctx, addPermission, arg.Code, arg.Description)
	return err
}

const addRole = `-- name: AddRole :exec
INSERT INTO roles (name, description) VALUES ($1, $2)
`

type AddRoleParams struct {
	Name        string
	Description string
}

func (q *Queries) AddRole(ctx context.Context, arg AddRoleParams) error {
	_, err := q.db.Exec(ctx, addRole, arg.Name, arg.Description)
	return err
}

const assignRole = `-- name: AssignRole :exec
INSERT INTO user_roles (user_id, role_id)
VALUES (
    (SELECT id FROM users where lower(username) = lower($1)),
    (SELECT id FROM roles WHERE name = $2 LIMIT 1)
)
`

type AssignRoleParams struct {
	Username string
	RoleName string
}

func (q *Queries) AssignRole(ctx context.Context, arg AssignRoleParams) error {
	_, err := q.db.Exec(ctx, assignRole, arg.Username, arg.RoleName)
	return err
}

const getRolesWithPermissions = `-- name: GetRolesWithPermissions :many
SELECT
    r.name,
    COALESCE(array_agg(p.code) FILTER (WHERE p.code IS NOT NULL), '{}')::text[] AS permissions
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN permissions p ON p.id = rp.permission_id
GROUP BY r.name
ORDER BY r.name
`

type GetRolesWithPermissionsRow struct {
	Name        string
	Permissions []string
}

func (q *Queries) GetRolesWithPermissions(ctx context.Context) ([]GetRolesWithPermissionsRow, error) {
	rows, err := q.db.Query(ctx, getRolesWithPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRolesWithPermissionsRow
	for rows.Next() {
		var i GetRolesWithPermissionsRow
		if err := rows.Scan(&i.Name, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.description
FROM roles r
JOIN user_roles ur ON ur.role_id = r.id
WHERE ur.user_id = (SELECT id FROM users where lower(username) = lower($1))
ORDER BY r.name ASC
`

func (q *Queries) GetUserRoles(ctx context.Context, username string) ([]Role, error) {
	rows, err := q.db.Query(ctx, getUserRoles, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRoles = `-- name: GetUsersWithRoles :many
SELECT
  u.uuid,
  u.username,
  r.name AS role_name
FROM users u
JOIN user_roles ur ON u.id = ur.user_id
JOIN roles r ON ur.role_id = r.id
WHERE r.name = ANY($1::text[])
ORDER BY u.username, r.name
`

type GetUsersWithRolesRow struct {
	Uuid     pgtype.Text
	Username pgtype.Text
	RoleName string
}

func (q *Queries) GetUsersWithRoles(ctx context.Context, roleNames []string) ([]GetUsersWithRolesRow, error) {
	rows, err := q.db.Query(ctx, getUsersWithRoles, roleNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithRolesRow
	for rows.Next() {
		var i GetUsersWithRolesRow
		if err := rows.Scan(&i.Uuid, &i.Username, &i.RoleName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasPermission = `-- name: HasPermission :one
SELECT EXISTS (
    -- Check for either:
    -- 1. Direct permission match, OR
    -- 2. Wildcard admin access
    SELECT 1
    FROM user_roles ur
    JOIN role_permissions rp ON ur.role_id = rp.role_id
    JOIN permissions p ON rp.permission_id = p.id
    WHERE ur.user_id = $1
    AND (
        p.code = $2  -- Specific permission
        OR
        p.code = 'admin_all_access'  -- Wildcard
    )
)
`

type HasPermissionParams struct {
	UserID     int32
	Permission string
}

func (q *Queries) HasPermission(ctx context.Context, arg HasPermissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasPermission, arg.UserID, arg.Permission)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const linkRoleAndPermission = `-- name: LinkRoleAndPermission :exec
INSERT INTO role_permissions (role_id, permission_id)
VALUES (
    (SELECT id FROM roles WHERE name = $1),
    (SELECT id FROM permissions WHERE code = $2)
)
`

type LinkRoleAndPermissionParams struct {
	RoleName       string
	PermissionCode string
}

func (q *Queries) LinkRoleAndPermission(ctx context.Context, arg LinkRoleAndPermissionParams) error {
	_, err := q.db.Exec(ctx, linkRoleAndPermission, arg.RoleName, arg.PermissionCode)
	return err
}

const unassignRole = `-- name: UnassignRole :execrows
DELETE FROM user_roles WHERE
  user_id = (SELECT id FROM users where lower(username) = lower($1))
  AND role_id = (SELECT id from roles WHERE name = $2 LIMIT 1)
`

type UnassignRoleParams struct {
	Username string
	RoleName string
}

func (q *Queries) UnassignRole(ctx context.Context, arg UnassignRoleParams) (int64, error) {
	result, err := q.db.Exec(ctx, unassignRole, arg.Username, arg.RoleName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const unlinkRoleAndPermission = `-- name: UnlinkRoleAndPermission :execrows
DELETE FROM role_permissions
WHERE
    role_id = (SELECT id FROM roles WHERE name = $1)
AND
    permission_id = (SELECT id FROM permissions WHERE code = $2)
`

type UnlinkRoleAndPermissionParams struct {
	RoleName       string
	PermissionCode string
}

func (q *Queries) UnlinkRoleAndPermission(ctx context.Context, arg UnlinkRoleAndPermissionParams) (int64, error) {
	result, err := q.db.Exec(ctx, unlinkRoleAndPermission, arg.RoleName, arg.PermissionCode)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
