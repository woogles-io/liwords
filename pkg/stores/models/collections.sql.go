// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: collections.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addGameToCollection = `-- name: AddGameToCollection :exec
INSERT INTO collection_games (collection_id, game_id, chapter_number, chapter_title, is_annotated)
VALUES ($1, $2, $3, $4, $5)
`

type AddGameToCollectionParams struct {
	CollectionID  int32
	GameID        string
	ChapterNumber int32
	ChapterTitle  pgtype.Text
	IsAnnotated   pgtype.Bool
}

func (q *Queries) AddGameToCollection(ctx context.Context, arg AddGameToCollectionParams) error {
	_, err := q.db.Exec(ctx, addGameToCollection,
		arg.CollectionID,
		arg.GameID,
		arg.ChapterNumber,
		arg.ChapterTitle,
		arg.IsAnnotated,
	)
	return err
}

const checkCollectionOwnership = `-- name: CheckCollectionOwnership :one
SELECT EXISTS(
    SELECT 1 FROM collections 
    WHERE uuid = $1 AND creator_id = $2
) as owns
`

type CheckCollectionOwnershipParams struct {
	Uuid      uuid.UUID
	CreatorID int32
}

func (q *Queries) CheckCollectionOwnership(ctx context.Context, arg CheckCollectionOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCollectionOwnership, arg.Uuid, arg.CreatorID)
	var owns bool
	err := row.Scan(&owns)
	return owns, err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (uuid, title, description, creator_id, public)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, uuid, created_at
`

type CreateCollectionParams struct {
	Uuid        uuid.UUID
	Title       string
	Description pgtype.Text
	CreatorID   int32
	Public      pgtype.Bool
}

type CreateCollectionRow struct {
	ID        int32
	Uuid      uuid.UUID
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (CreateCollectionRow, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.Uuid,
		arg.Title,
		arg.Description,
		arg.CreatorID,
		arg.Public,
	)
	var i CreateCollectionRow
	err := row.Scan(&i.ID, &i.Uuid, &i.CreatedAt)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections WHERE uuid = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCollection, argUuid)
	return err
}

const getCollectionByUUID = `-- name: GetCollectionByUUID :one
SELECT id, uuid, title, description, creator_id, public, created_at, updated_at FROM collections WHERE uuid = $1
`

func (q *Queries) GetCollectionByUUID(ctx context.Context, argUuid uuid.UUID) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollectionByUUID, argUuid)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Description,
		&i.CreatorID,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionGames = `-- name: GetCollectionGames :many
SELECT id, collection_id, game_id, chapter_number, chapter_title, is_annotated, added_at FROM collection_games 
WHERE collection_id = $1 
ORDER BY chapter_number
`

func (q *Queries) GetCollectionGames(ctx context.Context, collectionID int32) ([]CollectionGame, error) {
	rows, err := q.db.Query(ctx, getCollectionGames, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CollectionGame
	for rows.Next() {
		var i CollectionGame
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.GameID,
			&i.ChapterNumber,
			&i.ChapterTitle,
			&i.IsAnnotated,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionWithGames = `-- name: GetCollectionWithGames :one
SELECT c.id, c.uuid, c.title, c.description, c.creator_id, c.public, c.created_at, c.updated_at, u.uuid as creator_uuid, u.username as creator_username
FROM collections c
JOIN users u ON c.creator_id = u.id
WHERE c.uuid = $1
`

type GetCollectionWithGamesRow struct {
	ID              int32
	Uuid            uuid.UUID
	Title           string
	Description     pgtype.Text
	CreatorID       int32
	Public          pgtype.Bool
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	CreatorUuid     pgtype.Text
	CreatorUsername pgtype.Text
}

func (q *Queries) GetCollectionWithGames(ctx context.Context, argUuid uuid.UUID) (GetCollectionWithGamesRow, error) {
	row := q.db.QueryRow(ctx, getCollectionWithGames, argUuid)
	var i GetCollectionWithGamesRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Description,
		&i.CreatorID,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatorUuid,
		&i.CreatorUsername,
	)
	return i, err
}

const getCollectionsForGame = `-- name: GetCollectionsForGame :many
SELECT c.uuid, c.title, c.description, c.creator_id, c.public, 
       u.uuid as creator_uuid, u.username as creator_username,
       cg.chapter_number, cg.chapter_title
FROM collections c
JOIN collection_games cg ON c.id = cg.collection_id
JOIN users u ON c.creator_id = u.id
WHERE cg.game_id = $1
ORDER BY c.created_at DESC
`

type GetCollectionsForGameRow struct {
	Uuid            uuid.UUID
	Title           string
	Description     pgtype.Text
	CreatorID       int32
	Public          pgtype.Bool
	CreatorUuid     pgtype.Text
	CreatorUsername pgtype.Text
	ChapterNumber   int32
	ChapterTitle    pgtype.Text
}

func (q *Queries) GetCollectionsForGame(ctx context.Context, gameID string) ([]GetCollectionsForGameRow, error) {
	rows, err := q.db.Query(ctx, getCollectionsForGame, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionsForGameRow
	for rows.Next() {
		var i GetCollectionsForGameRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Title,
			&i.Description,
			&i.CreatorID,
			&i.Public,
			&i.CreatorUuid,
			&i.CreatorUsername,
			&i.ChapterNumber,
			&i.ChapterTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxChapterNumber = `-- name: GetMaxChapterNumber :one
SELECT COALESCE(MAX(chapter_number), 0) as max_chapter
FROM collection_games 
WHERE collection_id = $1
`

func (q *Queries) GetMaxChapterNumber(ctx context.Context, collectionID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getMaxChapterNumber, collectionID)
	var max_chapter interface{}
	err := row.Scan(&max_chapter)
	return max_chapter, err
}

const getPublicCollections = `-- name: GetPublicCollections :many
SELECT c.id, c.uuid, c.title, c.description, c.creator_id, c.public, c.created_at, c.updated_at, u.uuid as creator_uuid, u.username as creator_username,
       COALESCE(game_counts.game_count, 0) as game_count
FROM collections c
JOIN users u ON c.creator_id = u.id
LEFT JOIN (
    SELECT collection_id, COUNT(*) as game_count
    FROM collection_games
    GROUP BY collection_id
) game_counts ON c.id = game_counts.collection_id
WHERE c.public = true 
ORDER BY c.created_at DESC
LIMIT $1 OFFSET $2
`

type GetPublicCollectionsParams struct {
	Limit  int32
	Offset int32
}

type GetPublicCollectionsRow struct {
	ID              int32
	Uuid            uuid.UUID
	Title           string
	Description     pgtype.Text
	CreatorID       int32
	Public          pgtype.Bool
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	CreatorUuid     pgtype.Text
	CreatorUsername pgtype.Text
	GameCount       int64
}

func (q *Queries) GetPublicCollections(ctx context.Context, arg GetPublicCollectionsParams) ([]GetPublicCollectionsRow, error) {
	rows, err := q.db.Query(ctx, getPublicCollections, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicCollectionsRow
	for rows.Next() {
		var i GetPublicCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Description,
			&i.CreatorID,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatorUuid,
			&i.CreatorUsername,
			&i.GameCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyUpdatedCollections = `-- name: GetRecentlyUpdatedCollections :many
SELECT c.id, c.uuid, c.title, c.description, c.creator_id, c.public, c.created_at, c.updated_at, u.uuid as creator_uuid, u.username as creator_username,
       COALESCE((
           SELECT COUNT(*) 
           FROM collection_games cg 
           WHERE cg.collection_id = c.id
       ), 0) as game_count
FROM collections c
JOIN users u ON c.creator_id = u.id
WHERE c.public = true OR c.creator_id = COALESCE((SELECT id FROM users WHERE users.uuid = $3), 0)
ORDER BY c.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentlyUpdatedCollectionsParams struct {
	Limit    int32
	Offset   int32
	UserUuid pgtype.Text
}

type GetRecentlyUpdatedCollectionsRow struct {
	ID              int32
	Uuid            uuid.UUID
	Title           string
	Description     pgtype.Text
	CreatorID       int32
	Public          pgtype.Bool
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	CreatorUuid     pgtype.Text
	CreatorUsername pgtype.Text
	GameCount       interface{}
}

func (q *Queries) GetRecentlyUpdatedCollections(ctx context.Context, arg GetRecentlyUpdatedCollectionsParams) ([]GetRecentlyUpdatedCollectionsRow, error) {
	rows, err := q.db.Query(ctx, getRecentlyUpdatedCollections, arg.Limit, arg.Offset, arg.UserUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentlyUpdatedCollectionsRow
	for rows.Next() {
		var i GetRecentlyUpdatedCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Description,
			&i.CreatorID,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatorUuid,
			&i.CreatorUsername,
			&i.GameCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollections = `-- name: GetUserCollections :many
SELECT c.id, c.uuid, c.title, c.description, c.creator_id, c.public, c.created_at, c.updated_at, u.uuid as creator_uuid, u.username as creator_username,
       COALESCE((
           SELECT COUNT(*) 
           FROM collection_games cg 
           WHERE cg.collection_id = c.id
       ), 0) as game_count
FROM collections c
JOIN users u ON c.creator_id = u.id
WHERE c.creator_id = (SELECT id FROM users WHERE users.uuid = $1)
ORDER BY c.updated_at DESC
LIMIT $2 OFFSET $3
`

type GetUserCollectionsParams struct {
	Uuid   pgtype.Text
	Limit  int32
	Offset int32
}

type GetUserCollectionsRow struct {
	ID              int32
	Uuid            uuid.UUID
	Title           string
	Description     pgtype.Text
	CreatorID       int32
	Public          pgtype.Bool
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	CreatorUuid     pgtype.Text
	CreatorUsername pgtype.Text
	GameCount       interface{}
}

func (q *Queries) GetUserCollections(ctx context.Context, arg GetUserCollectionsParams) ([]GetUserCollectionsRow, error) {
	rows, err := q.db.Query(ctx, getUserCollections, arg.Uuid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCollectionsRow
	for rows.Next() {
		var i GetUserCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Description,
			&i.CreatorID,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatorUuid,
			&i.CreatorUsername,
			&i.GameCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeGameFromAllCollections = `-- name: RemoveGameFromAllCollections :exec
DELETE FROM collection_games 
WHERE game_id = $1
`

func (q *Queries) RemoveGameFromAllCollections(ctx context.Context, gameID string) error {
	_, err := q.db.Exec(ctx, removeGameFromAllCollections, gameID)
	return err
}

const removeGameFromCollection = `-- name: RemoveGameFromCollection :exec
DELETE FROM collection_games 
WHERE collection_id = $1 AND game_id = $2
`

type RemoveGameFromCollectionParams struct {
	CollectionID int32
	GameID       string
}

func (q *Queries) RemoveGameFromCollection(ctx context.Context, arg RemoveGameFromCollectionParams) error {
	_, err := q.db.Exec(ctx, removeGameFromCollection, arg.CollectionID, arg.GameID)
	return err
}

const reorderCollectionGames = `-- name: ReorderCollectionGames :exec
UPDATE collection_games 
SET chapter_number = $2
WHERE collection_id = $1 AND game_id = $3
`

type ReorderCollectionGamesParams struct {
	CollectionID  int32
	ChapterNumber int32
	GameID        string
}

func (q *Queries) ReorderCollectionGames(ctx context.Context, arg ReorderCollectionGamesParams) error {
	_, err := q.db.Exec(ctx, reorderCollectionGames, arg.CollectionID, arg.ChapterNumber, arg.GameID)
	return err
}

const resetChapterNumbers = `-- name: ResetChapterNumbers :exec
UPDATE collection_games 
SET chapter_number = -chapter_number
WHERE collection_id = $1 AND chapter_number < 0
`

func (q *Queries) ResetChapterNumbers(ctx context.Context, collectionID int32) error {
	_, err := q.db.Exec(ctx, resetChapterNumbers, collectionID)
	return err
}

const setTempChapterNumbers = `-- name: SetTempChapterNumbers :exec
UPDATE collection_games 
SET chapter_number = -chapter_number
WHERE collection_id = $1
`

func (q *Queries) SetTempChapterNumbers(ctx context.Context, collectionID int32) error {
	_, err := q.db.Exec(ctx, setTempChapterNumbers, collectionID)
	return err
}

const updateChapterTitle = `-- name: UpdateChapterTitle :exec
UPDATE collection_games 
SET chapter_title = $3
WHERE collection_id = $1 AND game_id = $2
`

type UpdateChapterTitleParams struct {
	CollectionID int32
	GameID       string
	ChapterTitle pgtype.Text
}

func (q *Queries) UpdateChapterTitle(ctx context.Context, arg UpdateChapterTitleParams) error {
	_, err := q.db.Exec(ctx, updateChapterTitle, arg.CollectionID, arg.GameID, arg.ChapterTitle)
	return err
}

const updateCollection = `-- name: UpdateCollection :exec
UPDATE collections 
SET title = $2, description = $3, public = $4, updated_at = NOW()
WHERE uuid = $1
`

type UpdateCollectionParams struct {
	Uuid        uuid.UUID
	Title       string
	Description pgtype.Text
	Public      pgtype.Bool
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) error {
	_, err := q.db.Exec(ctx, updateCollection,
		arg.Uuid,
		arg.Title,
		arg.Description,
		arg.Public,
	)
	return err
}

const updateCollectionTimestamp = `-- name: UpdateCollectionTimestamp :exec
UPDATE collections 
SET updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateCollectionTimestamp(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateCollectionTimestamp, id)
	return err
}
