// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: leagues.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countDivisionGamesComplete = `-- name: CountDivisionGamesComplete :one
SELECT COUNT(*) FROM games
WHERE league_division_id = $1 AND game_end_reason != 0
`

func (q *Queries) CountDivisionGamesComplete(ctx context.Context, leagueDivisionID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDivisionGamesComplete, leagueDivisionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDivisionGamesTotal = `-- name: CountDivisionGamesTotal :one
SELECT COUNT(*) FROM games
WHERE league_division_id = $1
`

func (q *Queries) CountDivisionGamesTotal(ctx context.Context, leagueDivisionID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDivisionGamesTotal, leagueDivisionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDivision = `-- name: CreateDivision :one

INSERT INTO league_divisions (uuid, season_id, division_number, division_name, is_complete)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, uuid, season_id, division_number, division_name, is_complete, created_at, updated_at
`

type CreateDivisionParams struct {
	Uuid           uuid.UUID
	SeasonID       uuid.UUID
	DivisionNumber int32
	DivisionName   pgtype.Text
	IsComplete     pgtype.Bool
}

// Division operations
func (q *Queries) CreateDivision(ctx context.Context, arg CreateDivisionParams) (LeagueDivision, error) {
	row := q.db.QueryRow(ctx, createDivision,
		arg.Uuid,
		arg.SeasonID,
		arg.DivisionNumber,
		arg.DivisionName,
		arg.IsComplete,
	)
	var i LeagueDivision
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.SeasonID,
		&i.DivisionNumber,
		&i.DivisionName,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeague = `-- name: CreateLeague :one

INSERT INTO leagues (uuid, name, description, slug, settings, is_active, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by
`

type CreateLeagueParams struct {
	Uuid        uuid.UUID
	Name        string
	Description pgtype.Text
	Slug        string
	Settings    []byte
	IsActive    pgtype.Bool
	CreatedBy   pgtype.Int8
}

// League operations
func (q *Queries) CreateLeague(ctx context.Context, arg CreateLeagueParams) (League, error) {
	row := q.db.QueryRow(ctx, createLeague,
		arg.Uuid,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.Settings,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Slug,
		&i.Settings,
		&i.CurrentSeasonID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createSeason = `-- name: CreateSeason :one

INSERT INTO league_seasons (uuid, league_id, season_number, start_date, end_date, status, promotion_formula)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula
`

type CreateSeasonParams struct {
	Uuid             uuid.UUID
	LeagueID         uuid.UUID
	SeasonNumber     int32
	StartDate        pgtype.Timestamptz
	EndDate          pgtype.Timestamptz
	Status           int32
	PromotionFormula int32
}

// Season operations
func (q *Queries) CreateSeason(ctx context.Context, arg CreateSeasonParams) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, createSeason,
		arg.Uuid,
		arg.LeagueID,
		arg.SeasonNumber,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.PromotionFormula,
	)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.DivisionsPreparedAt,
		&i.StartedAt,
		&i.RegistrationOpenedAt,
		&i.StartingSoonNotificationSentAt,
		&i.PromotionFormula,
	)
	return i, err
}

const deleteDivision = `-- name: DeleteDivision :exec
DELETE FROM league_divisions
WHERE uuid = $1
`

func (q *Queries) DeleteDivision(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDivision, argUuid)
	return err
}

const deleteDivisionStandings = `-- name: DeleteDivisionStandings :exec
DELETE FROM league_standings
WHERE division_id = $1
`

func (q *Queries) DeleteDivisionStandings(ctx context.Context, divisionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDivisionStandings, divisionID)
	return err
}

const forceFinishGame = `-- name: ForceFinishGame :exec
WITH game_update AS (
    UPDATE games
    SET game_end_reason = 8,  -- FORCE_FORFEIT
        winner_idx = $2,
        loser_idx = $3,
        updated_at = NOW()
    WHERE uuid = $1
    RETURNING uuid, winner_idx, loser_idx
)
UPDATE game_players gp
SET game_end_reason = 8,  -- FORCE_FORFEIT
    won = CASE
        WHEN gu.winner_idx IS NULL THEN NULL  -- Tie: both players get NULL
        WHEN gp.player_index = gu.winner_idx THEN true
        WHEN gp.player_index = gu.loser_idx THEN false
        ELSE NULL
    END
FROM game_update gu
WHERE gp.game_uuid = gu.uuid
`

type ForceFinishGameParams struct {
	Uuid      pgtype.Text
	WinnerIdx pgtype.Int4
	LoserIdx  pgtype.Int4
}

func (q *Queries) ForceFinishGame(ctx context.Context, arg ForceFinishGameParams) error {
	_, err := q.db.Exec(ctx, forceFinishGame, arg.Uuid, arg.WinnerIdx, arg.LoserIdx)
	return err
}

const getAllLeagues = `-- name: GetAllLeagues :many
SELECT id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by FROM leagues
WHERE ($1::boolean = false OR is_active = true)
ORDER BY name
`

func (q *Queries) GetAllLeagues(ctx context.Context, activeOnly bool) ([]League, error) {
	rows, err := q.db.Query(ctx, getAllLeagues, activeOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []League
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.Slug,
			&i.Settings,
			&i.CurrentSeasonID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentSeason = `-- name: GetCurrentSeason :one
SELECT ls.id, ls.uuid, ls.league_id, ls.season_number, ls.start_date, ls.end_date, ls.actual_end_date, ls.status, ls.created_at, ls.updated_at, ls.closed_at, ls.divisions_prepared_at, ls.started_at, ls.registration_opened_at, ls.starting_soon_notification_sent_at, ls.promotion_formula FROM league_seasons ls
JOIN leagues l ON l.current_season_id = ls.uuid
WHERE l.uuid = $1
`

func (q *Queries) GetCurrentSeason(ctx context.Context, argUuid uuid.UUID) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, getCurrentSeason, argUuid)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.DivisionsPreparedAt,
		&i.StartedAt,
		&i.RegistrationOpenedAt,
		&i.StartingSoonNotificationSentAt,
		&i.PromotionFormula,
	)
	return i, err
}

const getDivision = `-- name: GetDivision :one
SELECT id, uuid, season_id, division_number, division_name, is_complete, created_at, updated_at FROM league_divisions WHERE uuid = $1
`

func (q *Queries) GetDivision(ctx context.Context, argUuid uuid.UUID) (LeagueDivision, error) {
	row := q.db.QueryRow(ctx, getDivision, argUuid)
	var i LeagueDivision
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.SeasonID,
		&i.DivisionNumber,
		&i.DivisionName,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDivisionGameResults = `-- name: GetDivisionGameResults :many
SELECT
    g.uuid,
    g.player0_id,
    g.player1_id,
    gp0.score as player0_score,
    gp1.score as player1_score,
    gp0.won as player0_won,
    gp1.won as player1_won,
    gp0.game_end_reason
FROM games g
INNER JOIN game_players gp0 ON g.uuid = gp0.game_uuid AND gp0.player_index = 0
INNER JOIN game_players gp1 ON g.uuid = gp1.game_uuid AND gp1.player_index = 1
WHERE g.league_division_id = $1
  AND gp0.game_end_reason != 0  -- Only finished games
  AND gp0.game_end_reason != 5  -- Exclude ABORTED
  AND gp0.game_end_reason != 7
`

type GetDivisionGameResultsRow struct {
	Uuid          pgtype.Text
	Player0ID     pgtype.Int4
	Player1ID     pgtype.Int4
	Player0Score  int32
	Player1Score  int32
	Player0Won    pgtype.Bool
	Player1Won    pgtype.Bool
	GameEndReason int16
}

func (q *Queries) GetDivisionGameResults(ctx context.Context, leagueDivisionID pgtype.UUID) ([]GetDivisionGameResultsRow, error) {
	rows, err := q.db.Query(ctx, getDivisionGameResults, leagueDivisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDivisionGameResultsRow
	for rows.Next() {
		var i GetDivisionGameResultsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Player0Score,
			&i.Player1Score,
			&i.Player0Won,
			&i.Player1Won,
			&i.GameEndReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDivisionRegistrations = `-- name: GetDivisionRegistrations :many
SELECT lr.id, lr.user_id, lr.season_id, lr.division_id, lr.registration_date, lr.firsts_count, lr.status, lr.placement_status, lr.previous_division_rank, lr.seasons_away, lr.created_at, lr.updated_at, u.uuid as user_uuid, u.username FROM league_registrations lr
JOIN users u ON lr.user_id = u.id
WHERE lr.division_id = $1
ORDER BY lr.registration_date
`

type GetDivisionRegistrationsRow struct {
	ID                   int64
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	UserUuid             pgtype.Text
	Username             pgtype.Text
}

func (q *Queries) GetDivisionRegistrations(ctx context.Context, divisionID pgtype.UUID) ([]GetDivisionRegistrationsRow, error) {
	rows, err := q.db.Query(ctx, getDivisionRegistrations, divisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDivisionRegistrationsRow
	for rows.Next() {
		var i GetDivisionRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserUuid,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDivisionsBySeason = `-- name: GetDivisionsBySeason :many
SELECT id, uuid, season_id, division_number, division_name, is_complete, created_at, updated_at FROM league_divisions
WHERE season_id = $1
ORDER BY division_number ASC
`

func (q *Queries) GetDivisionsBySeason(ctx context.Context, seasonID uuid.UUID) ([]LeagueDivision, error) {
	rows, err := q.db.Query(ctx, getDivisionsBySeason, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueDivision
	for rows.Next() {
		var i LeagueDivision
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.SeasonID,
			&i.DivisionNumber,
			&i.DivisionName,
			&i.IsComplete,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameLeagueInfo = `-- name: GetGameLeagueInfo :one

SELECT
    g.league_division_id,
    g.season_id,
    g.league_id,
    g.player0_id,
    g.player1_id,
    gp0.score as player0_score,
    gp1.score as player1_score,
    gp0.won as player0_won,
    gp1.won as player1_won,
    gp0.game_end_reason
FROM games g
LEFT JOIN game_players gp0 ON g.uuid = gp0.game_uuid AND gp0.player_index = 0
LEFT JOIN game_players gp1 ON g.uuid = gp1.game_uuid AND gp1.player_index = 1
WHERE g.uuid = $1
`

type GetGameLeagueInfoRow struct {
	LeagueDivisionID pgtype.UUID
	SeasonID         pgtype.UUID
	LeagueID         pgtype.UUID
	Player0ID        pgtype.Int4
	Player1ID        pgtype.Int4
	Player0Score     pgtype.Int4
	Player1Score     pgtype.Int4
	Player0Won       pgtype.Bool
	Player1Won       pgtype.Bool
	GameEndReason    pgtype.Int2
}

// Exclude CANCELLED
func (q *Queries) GetGameLeagueInfo(ctx context.Context, argUuid pgtype.Text) (GetGameLeagueInfoRow, error) {
	row := q.db.QueryRow(ctx, getGameLeagueInfo, argUuid)
	var i GetGameLeagueInfoRow
	err := row.Scan(
		&i.LeagueDivisionID,
		&i.SeasonID,
		&i.LeagueID,
		&i.Player0ID,
		&i.Player1ID,
		&i.Player0Score,
		&i.Player1Score,
		&i.Player0Won,
		&i.Player1Won,
		&i.GameEndReason,
	)
	return i, err
}

const getLeagueBySlug = `-- name: GetLeagueBySlug :one
SELECT id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by FROM leagues WHERE LOWER(slug) = LOWER($1)
`

func (q *Queries) GetLeagueBySlug(ctx context.Context, lower string) (League, error) {
	row := q.db.QueryRow(ctx, getLeagueBySlug, lower)
	var i League
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Slug,
		&i.Settings,
		&i.CurrentSeasonID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getLeagueByUUID = `-- name: GetLeagueByUUID :one
SELECT id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by FROM leagues WHERE uuid = $1
`

func (q *Queries) GetLeagueByUUID(ctx context.Context, argUuid uuid.UUID) (League, error) {
	row := q.db.QueryRow(ctx, getLeagueByUUID, argUuid)
	var i League
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Slug,
		&i.Settings,
		&i.CurrentSeasonID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getLeagueGames = `-- name: GetLeagueGames :many

SELECT
    id, created_at, updated_at, deleted_at, uuid,
    player0_id, player1_id, timers, started, game_end_reason,
    winner_idx, loser_idx, history, stats, quickdata,
    tournament_data, tournament_id, ready_flag, meta_events, type,
    game_request, player_on_turn, league_id, season_id, league_division_id
FROM games
WHERE league_division_id = $1
ORDER BY created_at
`

// Game queries for league games
func (q *Queries) GetLeagueGames(ctx context.Context, leagueDivisionID pgtype.UUID) ([]Game, error) {
	rows, err := q.db.Query(ctx, getLeagueGames, leagueDivisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.History,
			&i.Stats,
			&i.Quickdata,
			&i.TournamentData,
			&i.TournamentID,
			&i.ReadyFlag,
			&i.MetaEvents,
			&i.Type,
			&i.GameRequest,
			&i.PlayerOnTurn,
			&i.LeagueID,
			&i.SeasonID,
			&i.LeagueDivisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueGamesByStatus = `-- name: GetLeagueGamesByStatus :many
SELECT
    id, created_at, updated_at, deleted_at, uuid,
    player0_id, player1_id, timers, started, game_end_reason,
    winner_idx, loser_idx, history, stats, quickdata,
    tournament_data, tournament_id, ready_flag, meta_events, type,
    game_request, player_on_turn, league_id, season_id, league_division_id
FROM games
WHERE league_division_id = $1
  AND ($2::boolean = true OR game_end_reason = 0)
ORDER BY created_at
`

type GetLeagueGamesByStatusParams struct {
	LeagueDivisionID pgtype.UUID
	IncludeFinished  bool
}

func (q *Queries) GetLeagueGamesByStatus(ctx context.Context, arg GetLeagueGamesByStatusParams) ([]Game, error) {
	rows, err := q.db.Query(ctx, getLeagueGamesByStatus, arg.LeagueDivisionID, arg.IncludeFinished)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.History,
			&i.Stats,
			&i.Quickdata,
			&i.TournamentData,
			&i.TournamentID,
			&i.ReadyFlag,
			&i.MetaEvents,
			&i.Type,
			&i.GameRequest,
			&i.PlayerOnTurn,
			&i.LeagueID,
			&i.SeasonID,
			&i.LeagueDivisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPastSeasons = `-- name: GetPastSeasons :many
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula FROM league_seasons
WHERE league_id = $1 AND status = 2  -- SeasonStatus.SEASON_COMPLETED
ORDER BY season_number DESC
`

func (q *Queries) GetPastSeasons(ctx context.Context, leagueID uuid.UUID) ([]LeagueSeason, error) {
	rows, err := q.db.Query(ctx, getPastSeasons, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueSeason
	for rows.Next() {
		var i LeagueSeason
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.LeagueID,
			&i.SeasonNumber,
			&i.StartDate,
			&i.EndDate,
			&i.ActualEndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.DivisionsPreparedAt,
			&i.StartedAt,
			&i.RegistrationOpenedAt,
			&i.StartingSoonNotificationSentAt,
			&i.PromotionFormula,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerRegistration = `-- name: GetPlayerRegistration :one
SELECT id, user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away, created_at, updated_at FROM league_registrations
WHERE season_id = $1 AND user_id = $2
`

type GetPlayerRegistrationParams struct {
	SeasonID uuid.UUID
	UserID   int32
}

func (q *Queries) GetPlayerRegistration(ctx context.Context, arg GetPlayerRegistrationParams) (LeagueRegistration, error) {
	row := q.db.QueryRow(ctx, getPlayerRegistration, arg.SeasonID, arg.UserID)
	var i LeagueRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SeasonID,
		&i.DivisionID,
		&i.RegistrationDate,
		&i.FirstsCount,
		&i.Status,
		&i.PlacementStatus,
		&i.PreviousDivisionRank,
		&i.SeasonsAway,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerSeasonGames = `-- name: GetPlayerSeasonGames :many
SELECT
    g.uuid as game_uuid,
    g.created_at,
    gp_player.player_id,
    gp_player.score as player_score,
    gp_player.opponent_score,
    gp_player.won,
    gp_player.game_end_reason,
    u_opponent.uuid as opponent_uuid,
    u_opponent.username as opponent_username
FROM games g
INNER JOIN game_players gp_player ON g.uuid = gp_player.game_uuid
INNER JOIN users u_player ON gp_player.player_id = u_player.id
INNER JOIN game_players gp_opponent ON g.uuid = gp_opponent.game_uuid AND gp_opponent.player_index = (1 - gp_player.player_index)
INNER JOIN users u_opponent ON gp_opponent.player_id = u_opponent.id
WHERE g.season_id = $1
  AND u_player.uuid = $2
ORDER BY g.created_at DESC
`

type GetPlayerSeasonGamesParams struct {
	SeasonID pgtype.UUID
	UserUuid pgtype.Text
}

type GetPlayerSeasonGamesRow struct {
	GameUuid         pgtype.Text
	CreatedAt        pgtype.Timestamptz
	PlayerID         int32
	PlayerScore      int32
	OpponentScore    int32
	Won              pgtype.Bool
	GameEndReason    int16
	OpponentUuid     pgtype.Text
	OpponentUsername pgtype.Text
}

// Get finished games for a specific player in a season with scores from game_players table
func (q *Queries) GetPlayerSeasonGames(ctx context.Context, arg GetPlayerSeasonGamesParams) ([]GetPlayerSeasonGamesRow, error) {
	rows, err := q.db.Query(ctx, getPlayerSeasonGames, arg.SeasonID, arg.UserUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerSeasonGamesRow
	for rows.Next() {
		var i GetPlayerSeasonGamesRow
		if err := rows.Scan(
			&i.GameUuid,
			&i.CreatedAt,
			&i.PlayerID,
			&i.PlayerScore,
			&i.OpponentScore,
			&i.Won,
			&i.GameEndReason,
			&i.OpponentUuid,
			&i.OpponentUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerSeasonHistory = `-- name: GetPlayerSeasonHistory :many
SELECT lr.id, lr.user_id, lr.season_id, lr.division_id, lr.registration_date, lr.firsts_count, lr.status, lr.placement_status, lr.previous_division_rank, lr.seasons_away, lr.created_at, lr.updated_at, ls.season_number, ls.league_id
FROM league_registrations lr
JOIN league_seasons ls ON lr.season_id = ls.uuid
WHERE lr.user_id = $1
  AND ($2::uuid IS NULL OR ls.league_id = $2)
ORDER BY ls.season_number DESC
`

type GetPlayerSeasonHistoryParams struct {
	UserID   int32
	LeagueID uuid.UUID
}

type GetPlayerSeasonHistoryRow struct {
	ID                   int64
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	SeasonNumber         int32
	LeagueID             uuid.UUID
}

func (q *Queries) GetPlayerSeasonHistory(ctx context.Context, arg GetPlayerSeasonHistoryParams) ([]GetPlayerSeasonHistoryRow, error) {
	rows, err := q.db.Query(ctx, getPlayerSeasonHistory, arg.UserID, arg.LeagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerSeasonHistoryRow
	for rows.Next() {
		var i GetPlayerSeasonHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeasonNumber,
			&i.LeagueID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerSeasonInProgressGames = `-- name: GetPlayerSeasonInProgressGames :many
SELECT
    g.uuid as game_uuid,
    g.created_at,
    g.player0_id,
    g.player1_id,
    u_player0.uuid as player0_uuid,
    u_player0.username as player0_username,
    u_player1.uuid as player1_uuid,
    u_player1.username as player1_username
FROM games g
INNER JOIN users u_player0 ON g.player0_id = u_player0.id
INNER JOIN users u_player1 ON g.player1_id = u_player1.id
WHERE g.season_id = $1
  AND g.game_end_reason = 0
  AND (u_player0.uuid = $2 OR u_player1.uuid = $2)
ORDER BY g.created_at DESC
`

type GetPlayerSeasonInProgressGamesParams struct {
	SeasonID pgtype.UUID
	UserUuid pgtype.Text
}

type GetPlayerSeasonInProgressGamesRow struct {
	GameUuid        pgtype.Text
	CreatedAt       pgtype.Timestamptz
	Player0ID       pgtype.Int4
	Player1ID       pgtype.Int4
	Player0Uuid     pgtype.Text
	Player0Username pgtype.Text
	Player1Uuid     pgtype.Text
	Player1Username pgtype.Text
}

// Get in-progress games for a specific player in a season (fast query on indexed fields)
func (q *Queries) GetPlayerSeasonInProgressGames(ctx context.Context, arg GetPlayerSeasonInProgressGamesParams) ([]GetPlayerSeasonInProgressGamesRow, error) {
	rows, err := q.db.Query(ctx, getPlayerSeasonInProgressGames, arg.SeasonID, arg.UserUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerSeasonInProgressGamesRow
	for rows.Next() {
		var i GetPlayerSeasonInProgressGamesRow
		if err := rows.Scan(
			&i.GameUuid,
			&i.CreatedAt,
			&i.Player0ID,
			&i.Player1ID,
			&i.Player0Uuid,
			&i.Player0Username,
			&i.Player1Uuid,
			&i.Player1Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerSeasonOpponents = `-- name: GetPlayerSeasonOpponents :many
SELECT DISTINCT
    (CASE
        WHEN u_player0.uuid = $1 THEN u_player1.username
        ELSE u_player0.username
    END)::text as opponent_username
FROM games g
INNER JOIN users u_player0 ON g.player0_id = u_player0.id
INNER JOIN users u_player1 ON g.player1_id = u_player1.id
WHERE g.season_id = $2
  AND (u_player0.uuid = $1 OR u_player1.uuid = $1)
ORDER BY opponent_username
`

type GetPlayerSeasonOpponentsParams struct {
	UserUuid pgtype.Text
	SeasonID pgtype.UUID
}

// Get distinct opponents for a player in a season (from games table)
func (q *Queries) GetPlayerSeasonOpponents(ctx context.Context, arg GetPlayerSeasonOpponentsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getPlayerSeasonOpponents, arg.UserUuid, arg.SeasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var opponent_username string
		if err := rows.Scan(&opponent_username); err != nil {
			return nil, err
		}
		items = append(items, opponent_username)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStanding = `-- name: GetPlayerStanding :one
SELECT id, division_id, user_id, rank, wins, losses, draws, spread, games_played, games_remaining, result, updated_at FROM league_standings
WHERE division_id = $1 AND user_id = $2
`

type GetPlayerStandingParams struct {
	DivisionID uuid.UUID
	UserID     int32
}

func (q *Queries) GetPlayerStanding(ctx context.Context, arg GetPlayerStandingParams) (LeagueStanding, error) {
	row := q.db.QueryRow(ctx, getPlayerStanding, arg.DivisionID, arg.UserID)
	var i LeagueStanding
	err := row.Scan(
		&i.ID,
		&i.DivisionID,
		&i.UserID,
		&i.Rank,
		&i.Wins,
		&i.Losses,
		&i.Draws,
		&i.Spread,
		&i.GamesPlayed,
		&i.GamesRemaining,
		&i.Result,
		&i.UpdatedAt,
	)
	return i, err
}

const getRegistrationsByDivision = `-- name: GetRegistrationsByDivision :many
SELECT id, user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away, created_at, updated_at FROM league_registrations
WHERE division_id = $1
ORDER BY placement_status, previous_division_rank
`

func (q *Queries) GetRegistrationsByDivision(ctx context.Context, divisionID pgtype.UUID) ([]LeagueRegistration, error) {
	rows, err := q.db.Query(ctx, getRegistrationsByDivision, divisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueRegistration
	for rows.Next() {
		var i LeagueRegistration
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeason = `-- name: GetSeason :one
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula FROM league_seasons WHERE uuid = $1
`

func (q *Queries) GetSeason(ctx context.Context, argUuid uuid.UUID) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, getSeason, argUuid)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.DivisionsPreparedAt,
		&i.StartedAt,
		&i.RegistrationOpenedAt,
		&i.StartingSoonNotificationSentAt,
		&i.PromotionFormula,
	)
	return i, err
}

const getSeasonByLeagueAndNumber = `-- name: GetSeasonByLeagueAndNumber :one
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula FROM league_seasons
WHERE league_id = $1 AND season_number = $2
`

type GetSeasonByLeagueAndNumberParams struct {
	LeagueID     uuid.UUID
	SeasonNumber int32
}

func (q *Queries) GetSeasonByLeagueAndNumber(ctx context.Context, arg GetSeasonByLeagueAndNumberParams) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, getSeasonByLeagueAndNumber, arg.LeagueID, arg.SeasonNumber)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.DivisionsPreparedAt,
		&i.StartedAt,
		&i.RegistrationOpenedAt,
		&i.StartingSoonNotificationSentAt,
		&i.PromotionFormula,
	)
	return i, err
}

const getSeasonPlayersWithUnstartedGames = `-- name: GetSeasonPlayersWithUnstartedGames :many
SELECT
    u.uuid as user_uuid,
    u.username,
    COUNT(*) as unstarted_game_count
FROM games g
INNER JOIN users u ON (
    (g.player_on_turn = 0 AND u.id = g.player0_id) OR
    (g.player_on_turn = 1 AND u.id = g.player1_id)
)
WHERE g.season_id = $1
  AND g.game_end_reason = 0
  AND (g.timers->>'lu')::bigint = (g.timers->>'ts')::bigint
GROUP BY u.uuid, u.username
ORDER BY unstarted_game_count DESC, u.username
`

type GetSeasonPlayersWithUnstartedGamesRow struct {
	UserUuid           pgtype.Text
	Username           pgtype.Text
	UnstartedGameCount int64
}

// Get players who are on turn but haven't made their first move yet
// Groups by player to show who needs reminders
func (q *Queries) GetSeasonPlayersWithUnstartedGames(ctx context.Context, seasonID pgtype.UUID) ([]GetSeasonPlayersWithUnstartedGamesRow, error) {
	rows, err := q.db.Query(ctx, getSeasonPlayersWithUnstartedGames, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonPlayersWithUnstartedGamesRow
	for rows.Next() {
		var i GetSeasonPlayersWithUnstartedGamesRow
		if err := rows.Scan(&i.UserUuid, &i.Username, &i.UnstartedGameCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonRegistrations = `-- name: GetSeasonRegistrations :many
SELECT
    lr.id, lr.user_id, lr.season_id, lr.division_id, lr.registration_date, lr.firsts_count, lr.status, lr.placement_status, lr.previous_division_rank, lr.seasons_away, lr.created_at, lr.updated_at,
    u.uuid as user_uuid,
    u.username as username,
    ld.division_number as division_number
FROM league_registrations lr
JOIN users u ON lr.user_id = u.id
LEFT JOIN league_divisions ld ON lr.division_id = ld.uuid
WHERE lr.season_id = $1
ORDER BY lr.registration_date
`

type GetSeasonRegistrationsRow struct {
	ID                   int64
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	UserUuid             pgtype.Text
	Username             pgtype.Text
	DivisionNumber       pgtype.Int4
}

func (q *Queries) GetSeasonRegistrations(ctx context.Context, seasonID uuid.UUID) ([]GetSeasonRegistrationsRow, error) {
	rows, err := q.db.Query(ctx, getSeasonRegistrations, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonRegistrationsRow
	for rows.Next() {
		var i GetSeasonRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserUuid,
			&i.Username,
			&i.DivisionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonZeroMoveGames = `-- name: GetSeasonZeroMoveGames :many
SELECT
    g.uuid as game_uuid,
    g.created_at,
    g.player0_id,
    g.player1_id,
    u_player0.uuid as player0_uuid,
    u_player0.username as player0_username,
    u_player1.uuid as player1_uuid,
    u_player1.username as player1_username,
    g.league_division_id as division_id
FROM games g
INNER JOIN users u_player0 ON g.player0_id = u_player0.id
INNER JOIN users u_player1 ON g.player1_id = u_player1.id
WHERE g.season_id = $1
  AND g.game_end_reason = 0
  AND (g.timers->>'lu')::bigint = (g.timers->>'ts')::bigint
ORDER BY g.created_at ASC
`

type GetSeasonZeroMoveGamesRow struct {
	GameUuid        pgtype.Text
	CreatedAt       pgtype.Timestamptz
	Player0ID       pgtype.Int4
	Player1ID       pgtype.Int4
	Player0Uuid     pgtype.Text
	Player0Username pgtype.Text
	Player1Uuid     pgtype.Text
	Player1Username pgtype.Text
	DivisionID      pgtype.UUID
}

// Get all in-progress games in a season that have zero moves
// Uses timers field: if lu (last update) == ts (time started), no moves have been made
// This helps league managers identify players who haven't started their games
func (q *Queries) GetSeasonZeroMoveGames(ctx context.Context, seasonID pgtype.UUID) ([]GetSeasonZeroMoveGamesRow, error) {
	rows, err := q.db.Query(ctx, getSeasonZeroMoveGames, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonZeroMoveGamesRow
	for rows.Next() {
		var i GetSeasonZeroMoveGamesRow
		if err := rows.Scan(
			&i.GameUuid,
			&i.CreatedAt,
			&i.Player0ID,
			&i.Player1ID,
			&i.Player0Uuid,
			&i.Player0Username,
			&i.Player1Uuid,
			&i.Player1Username,
			&i.DivisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonsByLeague = `-- name: GetSeasonsByLeague :many
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula FROM league_seasons
WHERE league_id = $1
ORDER BY season_number DESC
`

func (q *Queries) GetSeasonsByLeague(ctx context.Context, leagueID uuid.UUID) ([]LeagueSeason, error) {
	rows, err := q.db.Query(ctx, getSeasonsByLeague, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueSeason
	for rows.Next() {
		var i LeagueSeason
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.LeagueID,
			&i.SeasonNumber,
			&i.StartDate,
			&i.EndDate,
			&i.ActualEndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.DivisionsPreparedAt,
			&i.StartedAt,
			&i.RegistrationOpenedAt,
			&i.StartingSoonNotificationSentAt,
			&i.PromotionFormula,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStandings = `-- name: GetStandings :many
SELECT ls.id, ls.division_id, ls.user_id, ls.wins, ls.losses, ls.draws,
       ls.spread, ls.games_played, ls.games_remaining, ls.result, ls.updated_at,
       u.uuid as user_uuid, u.username
FROM league_standings ls
JOIN users u ON ls.user_id = u.id
WHERE ls.division_id = $1
`

type GetStandingsRow struct {
	ID             int64
	DivisionID     uuid.UUID
	UserID         int32
	Wins           pgtype.Int4
	Losses         pgtype.Int4
	Draws          pgtype.Int4
	Spread         pgtype.Int4
	GamesPlayed    pgtype.Int4
	GamesRemaining pgtype.Int4
	Result         pgtype.Int4
	UpdatedAt      pgtype.Timestamptz
	UserUuid       pgtype.Text
	Username       pgtype.Text
}

// Note: rank column is deprecated and not queried. Sorting is done in Go code.
func (q *Queries) GetStandings(ctx context.Context, divisionID uuid.UUID) ([]GetStandingsRow, error) {
	rows, err := q.db.Query(ctx, getStandings, divisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStandingsRow
	for rows.Next() {
		var i GetStandingsRow
		if err := rows.Scan(
			&i.ID,
			&i.DivisionID,
			&i.UserID,
			&i.Wins,
			&i.Losses,
			&i.Draws,
			&i.Spread,
			&i.GamesPlayed,
			&i.GamesRemaining,
			&i.Result,
			&i.UpdatedAt,
			&i.UserUuid,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnfinishedLeagueGames = `-- name: GetUnfinishedLeagueGames :many
SELECT
    uuid as game_id,
    player0_id,
    player1_id
FROM games
WHERE season_id = $1
  AND game_end_reason = 0
`

type GetUnfinishedLeagueGamesRow struct {
	GameID    pgtype.Text
	Player0ID pgtype.Int4
	Player1ID pgtype.Int4
}

func (q *Queries) GetUnfinishedLeagueGames(ctx context.Context, seasonID pgtype.UUID) ([]GetUnfinishedLeagueGamesRow, error) {
	rows, err := q.db.Query(ctx, getUnfinishedLeagueGames, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnfinishedLeagueGamesRow
	for rows.Next() {
		var i GetUnfinishedLeagueGamesRow
		if err := rows.Scan(&i.GameID, &i.Player0ID, &i.Player1ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementStandingsAtomic = `-- name: IncrementStandingsAtomic :exec
INSERT INTO league_standings (division_id, user_id, wins, losses, draws, spread, games_played, games_remaining, result, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, 1, $7, 0, NOW())
ON CONFLICT (division_id, user_id)
DO UPDATE SET
    wins = league_standings.wins + EXCLUDED.wins,
    losses = league_standings.losses + EXCLUDED.losses,
    draws = league_standings.draws + EXCLUDED.draws,
    spread = league_standings.spread + EXCLUDED.spread,
    games_played = league_standings.games_played + 1,
    games_remaining = GREATEST(league_standings.games_remaining - 1, 0),
    updated_at = NOW()
`

type IncrementStandingsAtomicParams struct {
	DivisionID     uuid.UUID
	UserID         int32
	Wins           pgtype.Int4
	Losses         pgtype.Int4
	Draws          pgtype.Int4
	Spread         pgtype.Int4
	GamesRemaining pgtype.Int4
}

// Atomically increment standings for a player after a game completes
// This avoids race conditions by using database-level arithmetic
func (q *Queries) IncrementStandingsAtomic(ctx context.Context, arg IncrementStandingsAtomicParams) error {
	_, err := q.db.Exec(ctx, incrementStandingsAtomic,
		arg.DivisionID,
		arg.UserID,
		arg.Wins,
		arg.Losses,
		arg.Draws,
		arg.Spread,
		arg.GamesRemaining,
	)
	return err
}

const markDivisionComplete = `-- name: MarkDivisionComplete :exec
UPDATE league_divisions
SET is_complete = true, updated_at = NOW()
WHERE uuid = $1
`

func (q *Queries) MarkDivisionComplete(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDivisionComplete, argUuid)
	return err
}

const markDivisionsPrepared = `-- name: MarkDivisionsPrepared :exec
UPDATE league_seasons
SET divisions_prepared_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

func (q *Queries) MarkDivisionsPrepared(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDivisionsPrepared, argUuid)
	return err
}

const markRegistrationOpened = `-- name: MarkRegistrationOpened :exec
UPDATE league_seasons
SET registration_opened_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

// Marks when registration was opened for this season
func (q *Queries) MarkRegistrationOpened(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markRegistrationOpened, argUuid)
	return err
}

const markSeasonClosed = `-- name: MarkSeasonClosed :exec

UPDATE league_seasons
SET closed_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

// Task tracking queries for hourly runner idempotency
func (q *Queries) MarkSeasonClosed(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markSeasonClosed, argUuid)
	return err
}

const markSeasonComplete = `-- name: MarkSeasonComplete :exec
UPDATE league_seasons
SET status = 2, actual_end_date = NOW(), updated_at = NOW()  -- SeasonStatus.SEASON_COMPLETED
WHERE uuid = $1
`

func (q *Queries) MarkSeasonComplete(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markSeasonComplete, argUuid)
	return err
}

const markSeasonStarted = `-- name: MarkSeasonStarted :exec
UPDATE league_seasons
SET started_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

func (q *Queries) MarkSeasonStarted(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markSeasonStarted, argUuid)
	return err
}

const markStartingSoonNotificationSent = `-- name: MarkStartingSoonNotificationSent :exec
UPDATE league_seasons
SET starting_soon_notification_sent_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

func (q *Queries) MarkStartingSoonNotificationSent(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markStartingSoonNotificationSent, argUuid)
	return err
}

const registerPlayer = `-- name: RegisterPlayer :one

INSERT INTO league_registrations (user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (user_id, season_id)
DO UPDATE SET
    division_id = EXCLUDED.division_id,
    firsts_count = EXCLUDED.firsts_count,
    status = EXCLUDED.status,
    placement_status = EXCLUDED.placement_status,
    previous_division_rank = EXCLUDED.previous_division_rank,
    seasons_away = EXCLUDED.seasons_away
RETURNING id, user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away, created_at, updated_at
`

type RegisterPlayerParams struct {
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
}

// Registration operations
func (q *Queries) RegisterPlayer(ctx context.Context, arg RegisterPlayerParams) (LeagueRegistration, error) {
	row := q.db.QueryRow(ctx, registerPlayer,
		arg.UserID,
		arg.SeasonID,
		arg.DivisionID,
		arg.RegistrationDate,
		arg.FirstsCount,
		arg.Status,
		arg.PlacementStatus,
		arg.PreviousDivisionRank,
		arg.SeasonsAway,
	)
	var i LeagueRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SeasonID,
		&i.DivisionID,
		&i.RegistrationDate,
		&i.FirstsCount,
		&i.Status,
		&i.PlacementStatus,
		&i.PreviousDivisionRank,
		&i.SeasonsAway,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setCurrentSeason = `-- name: SetCurrentSeason :exec
UPDATE leagues
SET current_season_id = $2, updated_at = NOW()
WHERE uuid = $1
`

type SetCurrentSeasonParams struct {
	Uuid            uuid.UUID
	CurrentSeasonID pgtype.UUID
}

func (q *Queries) SetCurrentSeason(ctx context.Context, arg SetCurrentSeasonParams) error {
	_, err := q.db.Exec(ctx, setCurrentSeason, arg.Uuid, arg.CurrentSeasonID)
	return err
}

const unregisterPlayer = `-- name: UnregisterPlayer :exec
DELETE FROM league_registrations
WHERE season_id = $1 AND user_id = $2
`

type UnregisterPlayerParams struct {
	SeasonID uuid.UUID
	UserID   int32
}

func (q *Queries) UnregisterPlayer(ctx context.Context, arg UnregisterPlayerParams) error {
	_, err := q.db.Exec(ctx, unregisterPlayer, arg.SeasonID, arg.UserID)
	return err
}

const updateDivisionNumber = `-- name: UpdateDivisionNumber :exec
UPDATE league_divisions
SET division_number = $2, division_name = $3, updated_at = NOW()
WHERE uuid = $1
`

type UpdateDivisionNumberParams struct {
	Uuid           uuid.UUID
	DivisionNumber int32
	DivisionName   pgtype.Text
}

func (q *Queries) UpdateDivisionNumber(ctx context.Context, arg UpdateDivisionNumberParams) error {
	_, err := q.db.Exec(ctx, updateDivisionNumber, arg.Uuid, arg.DivisionNumber, arg.DivisionName)
	return err
}

const updateLeagueMetadata = `-- name: UpdateLeagueMetadata :exec
UPDATE leagues
SET name = $2, description = $3, updated_at = NOW()
WHERE uuid = $1
`

type UpdateLeagueMetadataParams struct {
	Uuid        uuid.UUID
	Name        string
	Description pgtype.Text
}

func (q *Queries) UpdateLeagueMetadata(ctx context.Context, arg UpdateLeagueMetadataParams) error {
	_, err := q.db.Exec(ctx, updateLeagueMetadata, arg.Uuid, arg.Name, arg.Description)
	return err
}

const updateLeagueSettings = `-- name: UpdateLeagueSettings :exec
UPDATE leagues
SET settings = $2, updated_at = NOW()
WHERE uuid = $1
`

type UpdateLeagueSettingsParams struct {
	Uuid     uuid.UUID
	Settings []byte
}

func (q *Queries) UpdateLeagueSettings(ctx context.Context, arg UpdateLeagueSettingsParams) error {
	_, err := q.db.Exec(ctx, updateLeagueSettings, arg.Uuid, arg.Settings)
	return err
}

const updatePlacementStatus = `-- name: UpdatePlacementStatus :exec
UPDATE league_registrations
SET placement_status = $2, previous_division_rank = $3, updated_at = NOW()
WHERE user_id = $1 AND season_id = $4
`

type UpdatePlacementStatusParams struct {
	UserID               int32
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonID             uuid.UUID
}

func (q *Queries) UpdatePlacementStatus(ctx context.Context, arg UpdatePlacementStatusParams) error {
	_, err := q.db.Exec(ctx, updatePlacementStatus,
		arg.UserID,
		arg.PlacementStatus,
		arg.PreviousDivisionRank,
		arg.SeasonID,
	)
	return err
}

const updatePlacementStatusWithSeasonsAway = `-- name: UpdatePlacementStatusWithSeasonsAway :exec
UPDATE league_registrations
SET placement_status = $2, previous_division_rank = $3, seasons_away = $4, updated_at = NOW()
WHERE user_id = $1 AND season_id = $5
`

type UpdatePlacementStatusWithSeasonsAwayParams struct {
	UserID               int32
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	SeasonID             uuid.UUID
}

func (q *Queries) UpdatePlacementStatusWithSeasonsAway(ctx context.Context, arg UpdatePlacementStatusWithSeasonsAwayParams) error {
	_, err := q.db.Exec(ctx, updatePlacementStatusWithSeasonsAway,
		arg.UserID,
		arg.PlacementStatus,
		arg.PreviousDivisionRank,
		arg.SeasonsAway,
		arg.SeasonID,
	)
	return err
}

const updatePlayerDivision = `-- name: UpdatePlayerDivision :exec
UPDATE league_registrations
SET division_id = $1, firsts_count = $2
WHERE user_id = $3 AND season_id = $4
`

type UpdatePlayerDivisionParams struct {
	DivisionID  pgtype.UUID
	FirstsCount pgtype.Int4
	UserID      int32
	SeasonID    uuid.UUID
}

func (q *Queries) UpdatePlayerDivision(ctx context.Context, arg UpdatePlayerDivisionParams) error {
	_, err := q.db.Exec(ctx, updatePlayerDivision,
		arg.DivisionID,
		arg.FirstsCount,
		arg.UserID,
		arg.SeasonID,
	)
	return err
}

const updateRegistrationDivision = `-- name: UpdateRegistrationDivision :exec
UPDATE league_registrations
SET division_id = $2, firsts_count = $3, updated_at = NOW()
WHERE season_id = $1 AND user_id = $4
`

type UpdateRegistrationDivisionParams struct {
	SeasonID    uuid.UUID
	DivisionID  pgtype.UUID
	FirstsCount pgtype.Int4
	UserID      int32
}

func (q *Queries) UpdateRegistrationDivision(ctx context.Context, arg UpdateRegistrationDivisionParams) error {
	_, err := q.db.Exec(ctx, updateRegistrationDivision,
		arg.SeasonID,
		arg.DivisionID,
		arg.FirstsCount,
		arg.UserID,
	)
	return err
}

const updateSeasonDates = `-- name: UpdateSeasonDates :exec
UPDATE league_seasons
SET start_date = $2, end_date = $3, updated_at = NOW()
WHERE uuid = $1
`

type UpdateSeasonDatesParams struct {
	Uuid      uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

func (q *Queries) UpdateSeasonDates(ctx context.Context, arg UpdateSeasonDatesParams) error {
	_, err := q.db.Exec(ctx, updateSeasonDates, arg.Uuid, arg.StartDate, arg.EndDate)
	return err
}

const updateSeasonPromotionFormula = `-- name: UpdateSeasonPromotionFormula :exec
UPDATE league_seasons
SET promotion_formula = $2, updated_at = NOW()
WHERE uuid = $1
`

type UpdateSeasonPromotionFormulaParams struct {
	Uuid             uuid.UUID
	PromotionFormula int32
}

func (q *Queries) UpdateSeasonPromotionFormula(ctx context.Context, arg UpdateSeasonPromotionFormulaParams) error {
	_, err := q.db.Exec(ctx, updateSeasonPromotionFormula, arg.Uuid, arg.PromotionFormula)
	return err
}

const updateSeasonStatus = `-- name: UpdateSeasonStatus :exec
UPDATE league_seasons
SET status = $2, updated_at = NOW()
WHERE uuid = $1
`

type UpdateSeasonStatusParams struct {
	Uuid   uuid.UUID
	Status int32
}

func (q *Queries) UpdateSeasonStatus(ctx context.Context, arg UpdateSeasonStatusParams) error {
	_, err := q.db.Exec(ctx, updateSeasonStatus, arg.Uuid, arg.Status)
	return err
}

const upsertStanding = `-- name: UpsertStanding :exec

INSERT INTO league_standings (division_id, user_id, wins, losses, draws, spread, games_played, games_remaining, result, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
ON CONFLICT (division_id, user_id)
DO UPDATE SET
    wins = EXCLUDED.wins,
    losses = EXCLUDED.losses,
    draws = EXCLUDED.draws,
    spread = EXCLUDED.spread,
    games_played = EXCLUDED.games_played,
    games_remaining = EXCLUDED.games_remaining,
    result = EXCLUDED.result,
    updated_at = NOW()
`

type UpsertStandingParams struct {
	DivisionID     uuid.UUID
	UserID         int32
	Wins           pgtype.Int4
	Losses         pgtype.Int4
	Draws          pgtype.Int4
	Spread         pgtype.Int4
	GamesPlayed    pgtype.Int4
	GamesRemaining pgtype.Int4
	Result         pgtype.Int4
}

// Standings operations
// Note: rank column is not upserted - it's calculated on-demand from wins/losses/draws/spread
func (q *Queries) UpsertStanding(ctx context.Context, arg UpsertStandingParams) error {
	_, err := q.db.Exec(ctx, upsertStanding,
		arg.DivisionID,
		arg.UserID,
		arg.Wins,
		arg.Losses,
		arg.Draws,
		arg.Spread,
		arg.GamesPlayed,
		arg.GamesRemaining,
		arg.Result,
	)
	return err
}
