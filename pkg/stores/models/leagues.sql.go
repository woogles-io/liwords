// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: leagues.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/woogles-io/liwords/pkg/entity"
)

const addTimeBankAllPlayers = `-- name: AddTimeBankAllPlayers :execrows
UPDATE games
SET timers = jsonb_set(
    jsonb_set(timers, '{tb,0}', to_jsonb((timers->'tb'->0)::bigint + $1::bigint)),
    '{tb,1}',
    to_jsonb((timers->'tb'->1)::bigint + $1::bigint)
),
updated_at = NOW()
WHERE season_id = $2
  AND game_end_reason = 0
  AND timers->'tb' IS NOT NULL
  AND jsonb_array_length(timers->'tb') = 2
`

type AddTimeBankAllPlayersParams struct {
	AdditionalMs int64
	SeasonID     pgtype.UUID
}

// Add time bank to all in-progress games in a season
func (q *Queries) AddTimeBankAllPlayers(ctx context.Context, arg AddTimeBankAllPlayersParams) (int64, error) {
	result, err := q.db.Exec(ctx, addTimeBankAllPlayers, arg.AdditionalMs, arg.SeasonID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const addTimeBankPlayerAndOpponent = `-- name: AddTimeBankPlayerAndOpponent :execrows
UPDATE games
SET timers = jsonb_set(
    jsonb_set(timers, '{tb,0}', to_jsonb((timers->'tb'->0)::bigint + $1::bigint)),
    '{tb,1}',
    to_jsonb((timers->'tb'->1)::bigint + $1::bigint)
),
updated_at = NOW()
WHERE season_id = $2
  AND game_end_reason = 0
  AND (player0_id = $3 OR player1_id = $3)
  AND timers->'tb' IS NOT NULL
  AND jsonb_array_length(timers->'tb') = 2
`

type AddTimeBankPlayerAndOpponentParams struct {
	AdditionalMs int64
	SeasonID     pgtype.UUID
	PlayerID     pgtype.Int4
}

// Add time bank to both sides of a player's in-progress games
func (q *Queries) AddTimeBankPlayerAndOpponent(ctx context.Context, arg AddTimeBankPlayerAndOpponentParams) (int64, error) {
	result, err := q.db.Exec(ctx, addTimeBankPlayerAndOpponent, arg.AdditionalMs, arg.SeasonID, arg.PlayerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const addTimeBankSinglePlayer = `-- name: AddTimeBankSinglePlayer :execrows
UPDATE games
SET timers = jsonb_set(
    timers,
    CASE WHEN player0_id = $1 THEN '{tb,0}' ELSE '{tb,1}' END,
    to_jsonb((timers->'tb'->(CASE WHEN player0_id = $1 THEN 0 ELSE 1 END))::bigint + $2::bigint)
),
updated_at = NOW()
WHERE season_id = $3
  AND game_end_reason = 0
  AND (player0_id = $1 OR player1_id = $1)
  AND timers->'tb' IS NOT NULL
  AND jsonb_array_length(timers->'tb') = 2
`

type AddTimeBankSinglePlayerParams struct {
	PlayerID     pgtype.Int4
	AdditionalMs int64
	SeasonID     pgtype.UUID
}

// Add time bank to only the specified player's side in their in-progress games
func (q *Queries) AddTimeBankSinglePlayer(ctx context.Context, arg AddTimeBankSinglePlayerParams) (int64, error) {
	result, err := q.db.Exec(ctx, addTimeBankSinglePlayer, arg.PlayerID, arg.AdditionalMs, arg.SeasonID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const countDivisionGamesComplete = `-- name: CountDivisionGamesComplete :one
SELECT COUNT(*) FROM games
WHERE league_division_id = $1 AND game_end_reason != 0
`

func (q *Queries) CountDivisionGamesComplete(ctx context.Context, leagueDivisionID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDivisionGamesComplete, leagueDivisionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDivisionGamesTotal = `-- name: CountDivisionGamesTotal :one
SELECT COUNT(*) FROM games
WHERE league_division_id = $1
`

func (q *Queries) CountDivisionGamesTotal(ctx context.Context, leagueDivisionID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDivisionGamesTotal, leagueDivisionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDivision = `-- name: CreateDivision :one

INSERT INTO league_divisions (uuid, season_id, division_number, division_name, is_complete)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, uuid, season_id, division_number, division_name, is_complete, created_at, updated_at
`

type CreateDivisionParams struct {
	Uuid           uuid.UUID
	SeasonID       uuid.UUID
	DivisionNumber int32
	DivisionName   pgtype.Text
	IsComplete     pgtype.Bool
}

// Division operations
func (q *Queries) CreateDivision(ctx context.Context, arg CreateDivisionParams) (LeagueDivision, error) {
	row := q.db.QueryRow(ctx, createDivision,
		arg.Uuid,
		arg.SeasonID,
		arg.DivisionNumber,
		arg.DivisionName,
		arg.IsComplete,
	)
	var i LeagueDivision
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.SeasonID,
		&i.DivisionNumber,
		&i.DivisionName,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeague = `-- name: CreateLeague :one

INSERT INTO leagues (uuid, name, description, slug, settings, is_active, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by
`

type CreateLeagueParams struct {
	Uuid        uuid.UUID
	Name        string
	Description pgtype.Text
	Slug        string
	Settings    []byte
	IsActive    pgtype.Bool
	CreatedBy   pgtype.Int8
}

// League operations
func (q *Queries) CreateLeague(ctx context.Context, arg CreateLeagueParams) (League, error) {
	row := q.db.QueryRow(ctx, createLeague,
		arg.Uuid,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.Settings,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Slug,
		&i.Settings,
		&i.CurrentSeasonID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createSeason = `-- name: CreateSeason :one

INSERT INTO league_seasons (uuid, league_id, season_number, start_date, end_date, status, promotion_formula)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula
`

type CreateSeasonParams struct {
	Uuid             uuid.UUID
	LeagueID         uuid.UUID
	SeasonNumber     int32
	StartDate        pgtype.Timestamptz
	EndDate          pgtype.Timestamptz
	Status           int32
	PromotionFormula int32
}

// Season operations
func (q *Queries) CreateSeason(ctx context.Context, arg CreateSeasonParams) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, createSeason,
		arg.Uuid,
		arg.LeagueID,
		arg.SeasonNumber,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.PromotionFormula,
	)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.DivisionsPreparedAt,
		&i.StartedAt,
		&i.RegistrationOpenedAt,
		&i.StartingSoonNotificationSentAt,
		&i.PromotionFormula,
	)
	return i, err
}

const deleteDivision = `-- name: DeleteDivision :exec
DELETE FROM league_divisions
WHERE uuid = $1
`

func (q *Queries) DeleteDivision(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDivision, argUuid)
	return err
}

const deleteDivisionStandings = `-- name: DeleteDivisionStandings :exec
DELETE FROM league_standings
WHERE division_id = $1
`

func (q *Queries) DeleteDivisionStandings(ctx context.Context, divisionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDivisionStandings, divisionID)
	return err
}

const forceFinishGame = `-- name: ForceFinishGame :exec
WITH game_update AS (
    UPDATE games
    SET game_end_reason = 8,  -- FORCE_FORFEIT
        winner_idx = $2,
        loser_idx = $3,
        updated_at = NOW()
    WHERE uuid = $1
    RETURNING uuid, winner_idx, loser_idx
)
UPDATE game_players gp
SET game_end_reason = 8,  -- FORCE_FORFEIT
    won = CASE
        WHEN gu.winner_idx IS NULL THEN NULL  -- Tie: both players get NULL
        WHEN gp.player_index = gu.winner_idx THEN true
        WHEN gp.player_index = gu.loser_idx THEN false
        ELSE NULL
    END
FROM game_update gu
WHERE gp.game_uuid = gu.uuid
`

type ForceFinishGameParams struct {
	Uuid      pgtype.Text
	WinnerIdx pgtype.Int4
	LoserIdx  pgtype.Int4
}

func (q *Queries) ForceFinishGame(ctx context.Context, arg ForceFinishGameParams) error {
	_, err := q.db.Exec(ctx, forceFinishGame, arg.Uuid, arg.WinnerIdx, arg.LoserIdx)
	return err
}

const getAllLeagues = `-- name: GetAllLeagues :many
SELECT id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by FROM leagues
WHERE ($1::boolean = false OR is_active = true)
ORDER BY name
`

func (q *Queries) GetAllLeagues(ctx context.Context, activeOnly bool) ([]League, error) {
	rows, err := q.db.Query(ctx, getAllLeagues, activeOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []League
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.Slug,
			&i.Settings,
			&i.CurrentSeasonID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentSeason = `-- name: GetCurrentSeason :one
SELECT ls.id, ls.uuid, ls.league_id, ls.season_number, ls.start_date, ls.end_date, ls.actual_end_date, ls.status, ls.created_at, ls.updated_at, ls.closed_at, ls.divisions_prepared_at, ls.started_at, ls.registration_opened_at, ls.starting_soon_notification_sent_at, ls.promotion_formula FROM league_seasons ls
JOIN leagues l ON l.current_season_id = ls.uuid
WHERE l.uuid = $1
`

func (q *Queries) GetCurrentSeason(ctx context.Context, argUuid uuid.UUID) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, getCurrentSeason, argUuid)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.DivisionsPreparedAt,
		&i.StartedAt,
		&i.RegistrationOpenedAt,
		&i.StartingSoonNotificationSentAt,
		&i.PromotionFormula,
	)
	return i, err
}

const getDivision = `-- name: GetDivision :one
SELECT id, uuid, season_id, division_number, division_name, is_complete, created_at, updated_at FROM league_divisions WHERE uuid = $1
`

func (q *Queries) GetDivision(ctx context.Context, argUuid uuid.UUID) (LeagueDivision, error) {
	row := q.db.QueryRow(ctx, getDivision, argUuid)
	var i LeagueDivision
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.SeasonID,
		&i.DivisionNumber,
		&i.DivisionName,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDivisionGameResults = `-- name: GetDivisionGameResults :many

SELECT
    g.uuid,
    g.player0_id,
    g.player1_id,
    gp0.score as player0_score,
    gp1.score as player1_score,
    gp0.won as player0_won,
    gp1.won as player1_won,
    gp0.game_end_reason
FROM games g
INNER JOIN game_players gp0 ON g.uuid = gp0.game_uuid AND gp0.player_index = 0
INNER JOIN game_players gp1 ON g.uuid = gp1.game_uuid AND gp1.player_index = 1
WHERE g.league_division_id = $1
  AND gp0.game_end_reason != 0  -- Only finished games
  AND gp0.game_end_reason != 5  -- Exclude ABORTED
  AND gp0.game_end_reason != 7
`

type GetDivisionGameResultsRow struct {
	Uuid          pgtype.Text
	Player0ID     pgtype.Int4
	Player1ID     pgtype.Int4
	Player0Score  int32
	Player1Score  int32
	Player0Won    pgtype.Bool
	Player1Won    pgtype.Bool
	GameEndReason int16
}

// No game_players rows exist
func (q *Queries) GetDivisionGameResults(ctx context.Context, leagueDivisionID pgtype.UUID) ([]GetDivisionGameResultsRow, error) {
	rows, err := q.db.Query(ctx, getDivisionGameResults, leagueDivisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDivisionGameResultsRow
	for rows.Next() {
		var i GetDivisionGameResultsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Player0Score,
			&i.Player1Score,
			&i.Player0Won,
			&i.Player1Won,
			&i.GameEndReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDivisionGamesWithStats = `-- name: GetDivisionGamesWithStats :many

SELECT
    g.uuid,
    g.player0_id,
    g.player1_id,
    gp0.score as player0_score,
    gp1.score as player1_score,
    gp0.won as player0_won,
    gp1.won as player1_won,
    gp0.game_end_reason,
    g.stats
FROM games g
INNER JOIN game_players gp0 ON g.uuid = gp0.game_uuid AND gp0.player_index = 0
INNER JOIN game_players gp1 ON g.uuid = gp1.game_uuid AND gp1.player_index = 1
WHERE g.league_division_id = $1
  AND gp0.game_end_reason != 0  -- Only finished games
  AND gp0.game_end_reason != 5  -- Exclude ABORTED
  AND gp0.game_end_reason != 7
`

type GetDivisionGamesWithStatsRow struct {
	Uuid          pgtype.Text
	Player0ID     pgtype.Int4
	Player1ID     pgtype.Int4
	Player0Score  int32
	Player1Score  int32
	Player0Won    pgtype.Bool
	Player1Won    pgtype.Bool
	GameEndReason int16
	Stats         entity.Stats
}

// Exclude CANCELLED
// Get all finished games for a division including the stats JSON blob
// Used for recalculating extended standings stats from historical games
func (q *Queries) GetDivisionGamesWithStats(ctx context.Context, leagueDivisionID pgtype.UUID) ([]GetDivisionGamesWithStatsRow, error) {
	rows, err := q.db.Query(ctx, getDivisionGamesWithStats, leagueDivisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDivisionGamesWithStatsRow
	for rows.Next() {
		var i GetDivisionGamesWithStatsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Player0Score,
			&i.Player1Score,
			&i.Player0Won,
			&i.Player1Won,
			&i.GameEndReason,
			&i.Stats,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDivisionRegistrations = `-- name: GetDivisionRegistrations :many
SELECT lr.id, lr.user_id, lr.season_id, lr.division_id, lr.registration_date, lr.firsts_count, lr.status, lr.placement_status, lr.previous_division_rank, lr.seasons_away, lr.created_at, lr.updated_at, u.uuid as user_uuid, u.username FROM league_registrations lr
JOIN users u ON lr.user_id = u.id
WHERE lr.division_id = $1
ORDER BY lr.registration_date
`

type GetDivisionRegistrationsRow struct {
	ID                   int64
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	UserUuid             pgtype.Text
	Username             pgtype.Text
}

func (q *Queries) GetDivisionRegistrations(ctx context.Context, divisionID pgtype.UUID) ([]GetDivisionRegistrationsRow, error) {
	rows, err := q.db.Query(ctx, getDivisionRegistrations, divisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDivisionRegistrationsRow
	for rows.Next() {
		var i GetDivisionRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserUuid,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDivisionTimeBankStatus = `-- name: GetDivisionTimeBankStatus :many
SELECT
    u.id as user_id,
    u.uuid as user_uuid,
    u.username,
    COUNT(*) as low_timebank_game_count
FROM games g
JOIN users u ON (
    (g.player_on_turn = 0 AND u.id = g.player0_id) OR
    (g.player_on_turn = 1 AND u.id = g.player1_id)
)
WHERE g.league_division_id = $1
  AND g.game_end_reason = 0
  AND g.timers->'tb' IS NOT NULL
  AND jsonb_array_length(g.timers->'tb') = 2
  AND (
    -- Effective time bank = stored_tb + MIN(effective_tr, 0)
    (g.timers->'tb'->(g.player_on_turn))::bigint +
    LEAST(
        (g.timers->'tr'->(g.player_on_turn))::bigint -
        ($2::bigint - (g.timers->>'lu')::bigint),
        0
    )
  ) < $3::bigint
GROUP BY u.id, u.uuid, u.username
`

type GetDivisionTimeBankStatusParams struct {
	DivisionID  pgtype.UUID
	NowMs       int64
	ThresholdMs int64
}

type GetDivisionTimeBankStatusRow struct {
	UserID               int32
	UserUuid             pgtype.Text
	Username             pgtype.Text
	LowTimebankGameCount int64
}

// Get time bank status for all players with active games in a division
// Returns users who have at least one game where it's their turn and their
// effective time bank (accounting for deficit from main time) is below threshold
// Effective time bank = stored_tb + MIN(effective_tr, 0)
// This matches the adjudicator's calculation in timeRanOut()
func (q *Queries) GetDivisionTimeBankStatus(ctx context.Context, arg GetDivisionTimeBankStatusParams) ([]GetDivisionTimeBankStatusRow, error) {
	rows, err := q.db.Query(ctx, getDivisionTimeBankStatus, arg.DivisionID, arg.NowMs, arg.ThresholdMs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDivisionTimeBankStatusRow
	for rows.Next() {
		var i GetDivisionTimeBankStatusRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserUuid,
			&i.Username,
			&i.LowTimebankGameCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDivisionsBySeason = `-- name: GetDivisionsBySeason :many
SELECT id, uuid, season_id, division_number, division_name, is_complete, created_at, updated_at FROM league_divisions
WHERE season_id = $1
ORDER BY division_number ASC
`

func (q *Queries) GetDivisionsBySeason(ctx context.Context, seasonID uuid.UUID) ([]LeagueDivision, error) {
	rows, err := q.db.Query(ctx, getDivisionsBySeason, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueDivision
	for rows.Next() {
		var i LeagueDivision
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.SeasonID,
			&i.DivisionNumber,
			&i.DivisionName,
			&i.IsComplete,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForceFinishedGamesMissingPlayers = `-- name: GetForceFinishedGamesMissingPlayers :many
SELECT
    g.uuid as game_id,
    g.player0_id,
    g.player1_id,
    g.game_end_reason
FROM games g
LEFT JOIN game_players gp ON g.uuid = gp.game_uuid
WHERE g.season_id = $1
  AND g.game_end_reason IN (8, 9)  -- FORCE_FORFEIT or ADJUDICATED
  AND gp.game_uuid IS NULL
`

type GetForceFinishedGamesMissingPlayersRow struct {
	GameID        pgtype.Text
	Player0ID     pgtype.Int4
	Player1ID     pgtype.Int4
	GameEndReason pgtype.Int4
}

// Find force-finished or adjudicated games in a season that are missing game_players rows
// This is used by the repair tool to backfill missing data
func (q *Queries) GetForceFinishedGamesMissingPlayers(ctx context.Context, seasonID pgtype.UUID) ([]GetForceFinishedGamesMissingPlayersRow, error) {
	rows, err := q.db.Query(ctx, getForceFinishedGamesMissingPlayers, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetForceFinishedGamesMissingPlayersRow
	for rows.Next() {
		var i GetForceFinishedGamesMissingPlayersRow
		if err := rows.Scan(
			&i.GameID,
			&i.Player0ID,
			&i.Player1ID,
			&i.GameEndReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameLeagueInfo = `-- name: GetGameLeagueInfo :one

SELECT
    g.league_division_id,
    g.season_id,
    g.league_id,
    g.player0_id,
    g.player1_id,
    gp0.score as player0_score,
    gp1.score as player1_score,
    gp0.won as player0_won,
    gp1.won as player1_won,
    gp0.game_end_reason
FROM games g
LEFT JOIN game_players gp0 ON g.uuid = gp0.game_uuid AND gp0.player_index = 0
LEFT JOIN game_players gp1 ON g.uuid = gp1.game_uuid AND gp1.player_index = 1
WHERE g.uuid = $1
`

type GetGameLeagueInfoRow struct {
	LeagueDivisionID pgtype.UUID
	SeasonID         pgtype.UUID
	LeagueID         pgtype.UUID
	Player0ID        pgtype.Int4
	Player1ID        pgtype.Int4
	Player0Score     pgtype.Int4
	Player1Score     pgtype.Int4
	Player0Won       pgtype.Bool
	Player1Won       pgtype.Bool
	GameEndReason    pgtype.Int2
}

// Exclude CANCELLED
func (q *Queries) GetGameLeagueInfo(ctx context.Context, argUuid pgtype.Text) (GetGameLeagueInfoRow, error) {
	row := q.db.QueryRow(ctx, getGameLeagueInfo, argUuid)
	var i GetGameLeagueInfoRow
	err := row.Scan(
		&i.LeagueDivisionID,
		&i.SeasonID,
		&i.LeagueID,
		&i.Player0ID,
		&i.Player1ID,
		&i.Player0Score,
		&i.Player1Score,
		&i.Player0Won,
		&i.Player1Won,
		&i.GameEndReason,
	)
	return i, err
}

const getLeagueBySlug = `-- name: GetLeagueBySlug :one
SELECT id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by FROM leagues WHERE LOWER(slug) = LOWER($1)
`

func (q *Queries) GetLeagueBySlug(ctx context.Context, lower string) (League, error) {
	row := q.db.QueryRow(ctx, getLeagueBySlug, lower)
	var i League
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Slug,
		&i.Settings,
		&i.CurrentSeasonID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getLeagueByUUID = `-- name: GetLeagueByUUID :one
SELECT id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by FROM leagues WHERE uuid = $1
`

func (q *Queries) GetLeagueByUUID(ctx context.Context, argUuid uuid.UUID) (League, error) {
	row := q.db.QueryRow(ctx, getLeagueByUUID, argUuid)
	var i League
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Slug,
		&i.Settings,
		&i.CurrentSeasonID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getLeagueGames = `-- name: GetLeagueGames :many

SELECT
    id, created_at, updated_at, deleted_at, uuid,
    player0_id, player1_id, timers, started, game_end_reason,
    winner_idx, loser_idx, history, stats, quickdata,
    tournament_data, tournament_id, ready_flag, meta_events, type,
    game_request, player_on_turn, league_id, season_id, league_division_id
FROM games
WHERE league_division_id = $1
ORDER BY created_at
`

// Game queries for league games
func (q *Queries) GetLeagueGames(ctx context.Context, leagueDivisionID pgtype.UUID) ([]Game, error) {
	rows, err := q.db.Query(ctx, getLeagueGames, leagueDivisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.History,
			&i.Stats,
			&i.Quickdata,
			&i.TournamentData,
			&i.TournamentID,
			&i.ReadyFlag,
			&i.MetaEvents,
			&i.Type,
			&i.GameRequest,
			&i.PlayerOnTurn,
			&i.LeagueID,
			&i.SeasonID,
			&i.LeagueDivisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueGamesByStatus = `-- name: GetLeagueGamesByStatus :many
SELECT
    id, created_at, updated_at, deleted_at, uuid,
    player0_id, player1_id, timers, started, game_end_reason,
    winner_idx, loser_idx, history, stats, quickdata,
    tournament_data, tournament_id, ready_flag, meta_events, type,
    game_request, player_on_turn, league_id, season_id, league_division_id
FROM games
WHERE league_division_id = $1
  AND ($2::boolean = true OR game_end_reason = 0)
ORDER BY created_at
`

type GetLeagueGamesByStatusParams struct {
	LeagueDivisionID pgtype.UUID
	IncludeFinished  bool
}

func (q *Queries) GetLeagueGamesByStatus(ctx context.Context, arg GetLeagueGamesByStatusParams) ([]Game, error) {
	rows, err := q.db.Query(ctx, getLeagueGamesByStatus, arg.LeagueDivisionID, arg.IncludeFinished)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.History,
			&i.Stats,
			&i.Quickdata,
			&i.TournamentData,
			&i.TournamentID,
			&i.ReadyFlag,
			&i.MetaEvents,
			&i.Type,
			&i.GameRequest,
			&i.PlayerOnTurn,
			&i.LeagueID,
			&i.SeasonID,
			&i.LeagueDivisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPastSeasons = `-- name: GetPastSeasons :many
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula FROM league_seasons
WHERE league_id = $1 AND status = 2  -- SeasonStatus.SEASON_COMPLETED
ORDER BY season_number DESC
`

func (q *Queries) GetPastSeasons(ctx context.Context, leagueID uuid.UUID) ([]LeagueSeason, error) {
	rows, err := q.db.Query(ctx, getPastSeasons, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueSeason
	for rows.Next() {
		var i LeagueSeason
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.LeagueID,
			&i.SeasonNumber,
			&i.StartDate,
			&i.EndDate,
			&i.ActualEndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.DivisionsPreparedAt,
			&i.StartedAt,
			&i.RegistrationOpenedAt,
			&i.StartingSoonNotificationSentAt,
			&i.PromotionFormula,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerRegistration = `-- name: GetPlayerRegistration :one
SELECT id, user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away, created_at, updated_at FROM league_registrations
WHERE season_id = $1 AND user_id = $2
`

type GetPlayerRegistrationParams struct {
	SeasonID uuid.UUID
	UserID   int32
}

func (q *Queries) GetPlayerRegistration(ctx context.Context, arg GetPlayerRegistrationParams) (LeagueRegistration, error) {
	row := q.db.QueryRow(ctx, getPlayerRegistration, arg.SeasonID, arg.UserID)
	var i LeagueRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SeasonID,
		&i.DivisionID,
		&i.RegistrationDate,
		&i.FirstsCount,
		&i.Status,
		&i.PlacementStatus,
		&i.PreviousDivisionRank,
		&i.SeasonsAway,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerSeasonGames = `-- name: GetPlayerSeasonGames :many
SELECT
    gp_player.game_uuid,
    g.created_at,
    g.updated_at,
    gp_player.player_id,
    gp_player.score as player_score,
    gp_player.opponent_score,
    gp_player.won,
    gp_player.game_end_reason,
    u_opponent.uuid as opponent_uuid,
    u_opponent.username as opponent_username
FROM game_players gp_player
INNER JOIN games g ON gp_player.game_uuid = g.uuid
INNER JOIN users u_opponent ON gp_player.opponent_id = u_opponent.id
WHERE gp_player.player_id = (SELECT id FROM users WHERE users.uuid = $1)
  AND gp_player.league_season_id = $2
ORDER BY gp_player.created_at DESC
`

type GetPlayerSeasonGamesParams struct {
	UserUuid pgtype.Text
	SeasonID pgtype.UUID
}

type GetPlayerSeasonGamesRow struct {
	GameUuid         string
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	PlayerID         int32
	PlayerScore      int32
	OpponentScore    int32
	Won              pgtype.Bool
	GameEndReason    int16
	OpponentUuid     pgtype.Text
	OpponentUsername pgtype.Text
}

// Get finished games for a specific player in a season with scores from game_players table
// Optimized to use idx_game_players_player_league_season composite index
func (q *Queries) GetPlayerSeasonGames(ctx context.Context, arg GetPlayerSeasonGamesParams) ([]GetPlayerSeasonGamesRow, error) {
	rows, err := q.db.Query(ctx, getPlayerSeasonGames, arg.UserUuid, arg.SeasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerSeasonGamesRow
	for rows.Next() {
		var i GetPlayerSeasonGamesRow
		if err := rows.Scan(
			&i.GameUuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlayerID,
			&i.PlayerScore,
			&i.OpponentScore,
			&i.Won,
			&i.GameEndReason,
			&i.OpponentUuid,
			&i.OpponentUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerSeasonHistory = `-- name: GetPlayerSeasonHistory :many
SELECT lr.id, lr.user_id, lr.season_id, lr.division_id, lr.registration_date, lr.firsts_count, lr.status, lr.placement_status, lr.previous_division_rank, lr.seasons_away, lr.created_at, lr.updated_at, ls.season_number, ls.league_id
FROM league_registrations lr
JOIN league_seasons ls ON lr.season_id = ls.uuid
WHERE lr.user_id = $1
  AND ($2::uuid IS NULL OR ls.league_id = $2)
ORDER BY ls.season_number DESC
`

type GetPlayerSeasonHistoryParams struct {
	UserID   int32
	LeagueID uuid.UUID
}

type GetPlayerSeasonHistoryRow struct {
	ID                   int64
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	SeasonNumber         int32
	LeagueID             uuid.UUID
}

func (q *Queries) GetPlayerSeasonHistory(ctx context.Context, arg GetPlayerSeasonHistoryParams) ([]GetPlayerSeasonHistoryRow, error) {
	rows, err := q.db.Query(ctx, getPlayerSeasonHistory, arg.UserID, arg.LeagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerSeasonHistoryRow
	for rows.Next() {
		var i GetPlayerSeasonHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeasonNumber,
			&i.LeagueID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerSeasonInProgressGames = `-- name: GetPlayerSeasonInProgressGames :many
SELECT
    g.uuid as game_uuid,
    g.created_at,
    g.updated_at,
    g.player0_id,
    g.player1_id,
    u_player0.uuid as player0_uuid,
    u_player0.username as player0_username,
    u_player1.uuid as player1_uuid,
    u_player1.username as player1_username,
    g.player_on_turn,
    g.history
FROM games g
INNER JOIN users u_player0 ON g.player0_id = u_player0.id
INNER JOIN users u_player1 ON g.player1_id = u_player1.id
WHERE g.season_id = $1
  AND g.game_end_reason = 0
  AND (u_player0.uuid = $2 OR u_player1.uuid = $2)
ORDER BY g.created_at DESC
`

type GetPlayerSeasonInProgressGamesParams struct {
	SeasonID pgtype.UUID
	UserUuid pgtype.Text
}

type GetPlayerSeasonInProgressGamesRow struct {
	GameUuid        pgtype.Text
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	Player0ID       pgtype.Int4
	Player1ID       pgtype.Int4
	Player0Uuid     pgtype.Text
	Player0Username pgtype.Text
	Player1Uuid     pgtype.Text
	Player1Username pgtype.Text
	PlayerOnTurn    pgtype.Int4
	History         []byte
}

// Get in-progress games for a specific player in a season (fast query on indexed fields)
func (q *Queries) GetPlayerSeasonInProgressGames(ctx context.Context, arg GetPlayerSeasonInProgressGamesParams) ([]GetPlayerSeasonInProgressGamesRow, error) {
	rows, err := q.db.Query(ctx, getPlayerSeasonInProgressGames, arg.SeasonID, arg.UserUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerSeasonInProgressGamesRow
	for rows.Next() {
		var i GetPlayerSeasonInProgressGamesRow
		if err := rows.Scan(
			&i.GameUuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Player0ID,
			&i.Player1ID,
			&i.Player0Uuid,
			&i.Player0Username,
			&i.Player1Uuid,
			&i.Player1Username,
			&i.PlayerOnTurn,
			&i.History,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerSeasonOpponents = `-- name: GetPlayerSeasonOpponents :many
SELECT DISTINCT
    (CASE
        WHEN u_player0.uuid = $1 THEN u_player1.username
        ELSE u_player0.username
    END)::text as opponent_username
FROM games g
INNER JOIN users u_player0 ON g.player0_id = u_player0.id
INNER JOIN users u_player1 ON g.player1_id = u_player1.id
WHERE g.season_id = $2
  AND (u_player0.uuid = $1 OR u_player1.uuid = $1)
ORDER BY opponent_username
`

type GetPlayerSeasonOpponentsParams struct {
	UserUuid pgtype.Text
	SeasonID pgtype.UUID
}

// Get distinct opponents for a player in a season (from games table)
func (q *Queries) GetPlayerSeasonOpponents(ctx context.Context, arg GetPlayerSeasonOpponentsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getPlayerSeasonOpponents, arg.UserUuid, arg.SeasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var opponent_username string
		if err := rows.Scan(&opponent_username); err != nil {
			return nil, err
		}
		items = append(items, opponent_username)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStanding = `-- name: GetPlayerStanding :one
SELECT id, division_id, user_id, rank, wins, losses, draws, spread, games_played, games_remaining, result, updated_at, total_score, total_opponent_score, total_bingos, total_opponent_bingos, total_turns, high_turn, high_game, timeouts, blanks_played, total_tiles_played, total_opponent_tiles_played FROM league_standings
WHERE division_id = $1 AND user_id = $2
`

type GetPlayerStandingParams struct {
	DivisionID uuid.UUID
	UserID     int32
}

func (q *Queries) GetPlayerStanding(ctx context.Context, arg GetPlayerStandingParams) (LeagueStanding, error) {
	row := q.db.QueryRow(ctx, getPlayerStanding, arg.DivisionID, arg.UserID)
	var i LeagueStanding
	err := row.Scan(
		&i.ID,
		&i.DivisionID,
		&i.UserID,
		&i.Rank,
		&i.Wins,
		&i.Losses,
		&i.Draws,
		&i.Spread,
		&i.GamesPlayed,
		&i.GamesRemaining,
		&i.Result,
		&i.UpdatedAt,
		&i.TotalScore,
		&i.TotalOpponentScore,
		&i.TotalBingos,
		&i.TotalOpponentBingos,
		&i.TotalTurns,
		&i.HighTurn,
		&i.HighGame,
		&i.Timeouts,
		&i.BlanksPlayed,
		&i.TotalTilesPlayed,
		&i.TotalOpponentTilesPlayed,
	)
	return i, err
}

const getRecentSeasons = `-- name: GetRecentSeasons :many
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula FROM league_seasons
WHERE league_id = $1
ORDER BY season_number DESC
LIMIT $2
`

type GetRecentSeasonsParams struct {
	LeagueID uuid.UUID
	Limit    int32
}

func (q *Queries) GetRecentSeasons(ctx context.Context, arg GetRecentSeasonsParams) ([]LeagueSeason, error) {
	rows, err := q.db.Query(ctx, getRecentSeasons, arg.LeagueID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueSeason
	for rows.Next() {
		var i LeagueSeason
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.LeagueID,
			&i.SeasonNumber,
			&i.StartDate,
			&i.EndDate,
			&i.ActualEndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.DivisionsPreparedAt,
			&i.StartedAt,
			&i.RegistrationOpenedAt,
			&i.StartingSoonNotificationSentAt,
			&i.PromotionFormula,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegistrationsByDivision = `-- name: GetRegistrationsByDivision :many
SELECT id, user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away, created_at, updated_at FROM league_registrations
WHERE division_id = $1
ORDER BY placement_status, previous_division_rank
`

func (q *Queries) GetRegistrationsByDivision(ctx context.Context, divisionID pgtype.UUID) ([]LeagueRegistration, error) {
	rows, err := q.db.Query(ctx, getRegistrationsByDivision, divisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueRegistration
	for rows.Next() {
		var i LeagueRegistration
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeason = `-- name: GetSeason :one
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula FROM league_seasons WHERE uuid = $1
`

func (q *Queries) GetSeason(ctx context.Context, argUuid uuid.UUID) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, getSeason, argUuid)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.DivisionsPreparedAt,
		&i.StartedAt,
		&i.RegistrationOpenedAt,
		&i.StartingSoonNotificationSentAt,
		&i.PromotionFormula,
	)
	return i, err
}

const getSeasonByLeagueAndNumber = `-- name: GetSeasonByLeagueAndNumber :one

SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula FROM league_seasons
WHERE league_id = $1 AND season_number = $2
`

type GetSeasonByLeagueAndNumberParams struct {
	LeagueID     uuid.UUID
	SeasonNumber int32
}

// RESULT_CHAMPION only
func (q *Queries) GetSeasonByLeagueAndNumber(ctx context.Context, arg GetSeasonByLeagueAndNumberParams) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, getSeasonByLeagueAndNumber, arg.LeagueID, arg.SeasonNumber)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.DivisionsPreparedAt,
		&i.StartedAt,
		&i.RegistrationOpenedAt,
		&i.StartingSoonNotificationSentAt,
		&i.PromotionFormula,
	)
	return i, err
}

const getSeasonChampion = `-- name: GetSeasonChampion :one
SELECT u.uuid as user_uuid, u.username
FROM league_standings ls
JOIN league_divisions ld ON ls.division_id = ld.uuid
JOIN users u ON ls.user_id = u.id
WHERE ld.season_id = $1
  AND ld.division_number = 1
  AND ls.result = 4
`

type GetSeasonChampionRow struct {
	UserUuid pgtype.Text
	Username pgtype.Text
}

// Get the champion (result = RESULT_CHAMPION in division 1) for a completed season
func (q *Queries) GetSeasonChampion(ctx context.Context, seasonID uuid.UUID) (GetSeasonChampionRow, error) {
	row := q.db.QueryRow(ctx, getSeasonChampion, seasonID)
	var i GetSeasonChampionRow
	err := row.Scan(&i.UserUuid, &i.Username)
	return i, err
}

const getSeasonPlayersWithUnstartedGames = `-- name: GetSeasonPlayersWithUnstartedGames :many
SELECT
    u.uuid as user_uuid,
    u.username,
    COUNT(*) as unstarted_game_count
FROM games g
INNER JOIN users u ON (
    (g.player_on_turn = 0 AND u.id = g.player0_id) OR
    (g.player_on_turn = 1 AND u.id = g.player1_id)
)
WHERE g.season_id = $1
  AND g.game_end_reason = 0
  AND (g.timers->>'lu')::bigint = (g.timers->>'ts')::bigint
GROUP BY u.uuid, u.username
ORDER BY unstarted_game_count DESC, u.username
`

type GetSeasonPlayersWithUnstartedGamesRow struct {
	UserUuid           pgtype.Text
	Username           pgtype.Text
	UnstartedGameCount int64
}

// Get players who are on turn but haven't made their first move yet
// Groups by player to show who needs reminders
func (q *Queries) GetSeasonPlayersWithUnstartedGames(ctx context.Context, seasonID pgtype.UUID) ([]GetSeasonPlayersWithUnstartedGamesRow, error) {
	rows, err := q.db.Query(ctx, getSeasonPlayersWithUnstartedGames, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonPlayersWithUnstartedGamesRow
	for rows.Next() {
		var i GetSeasonPlayersWithUnstartedGamesRow
		if err := rows.Scan(&i.UserUuid, &i.Username, &i.UnstartedGameCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonRegistrations = `-- name: GetSeasonRegistrations :many
SELECT
    lr.id, lr.user_id, lr.season_id, lr.division_id, lr.registration_date, lr.firsts_count, lr.status, lr.placement_status, lr.previous_division_rank, lr.seasons_away, lr.created_at, lr.updated_at,
    u.uuid as user_uuid,
    u.username as username,
    ld.division_number as division_number
FROM league_registrations lr
JOIN users u ON lr.user_id = u.id
LEFT JOIN league_divisions ld ON lr.division_id = ld.uuid
WHERE lr.season_id = $1
ORDER BY lr.registration_date
`

type GetSeasonRegistrationsRow struct {
	ID                   int64
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	UserUuid             pgtype.Text
	Username             pgtype.Text
	DivisionNumber       pgtype.Int4
}

func (q *Queries) GetSeasonRegistrations(ctx context.Context, seasonID uuid.UUID) ([]GetSeasonRegistrationsRow, error) {
	rows, err := q.db.Query(ctx, getSeasonRegistrations, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonRegistrationsRow
	for rows.Next() {
		var i GetSeasonRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserUuid,
			&i.Username,
			&i.DivisionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonZeroMoveGames = `-- name: GetSeasonZeroMoveGames :many
SELECT
    g.uuid as game_uuid,
    g.created_at,
    g.player0_id,
    g.player1_id,
    u_player0.uuid as player0_uuid,
    u_player0.username as player0_username,
    u_player1.uuid as player1_uuid,
    u_player1.username as player1_username,
    g.league_division_id as division_id
FROM games g
INNER JOIN users u_player0 ON g.player0_id = u_player0.id
INNER JOIN users u_player1 ON g.player1_id = u_player1.id
WHERE g.season_id = $1
  AND g.game_end_reason = 0
  AND (g.timers->>'lu')::bigint = (g.timers->>'ts')::bigint
ORDER BY g.created_at ASC
`

type GetSeasonZeroMoveGamesRow struct {
	GameUuid        pgtype.Text
	CreatedAt       pgtype.Timestamptz
	Player0ID       pgtype.Int4
	Player1ID       pgtype.Int4
	Player0Uuid     pgtype.Text
	Player0Username pgtype.Text
	Player1Uuid     pgtype.Text
	Player1Username pgtype.Text
	DivisionID      pgtype.UUID
}

// Get all in-progress games in a season that have zero moves
// Uses timers field: if lu (last update) == ts (time started), no moves have been made
// This helps league managers identify players who haven't started their games
func (q *Queries) GetSeasonZeroMoveGames(ctx context.Context, seasonID pgtype.UUID) ([]GetSeasonZeroMoveGamesRow, error) {
	rows, err := q.db.Query(ctx, getSeasonZeroMoveGames, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonZeroMoveGamesRow
	for rows.Next() {
		var i GetSeasonZeroMoveGamesRow
		if err := rows.Scan(
			&i.GameUuid,
			&i.CreatedAt,
			&i.Player0ID,
			&i.Player1ID,
			&i.Player0Uuid,
			&i.Player0Username,
			&i.Player1Uuid,
			&i.Player1Username,
			&i.DivisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonsByLeague = `-- name: GetSeasonsByLeague :many
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at, closed_at, divisions_prepared_at, started_at, registration_opened_at, starting_soon_notification_sent_at, promotion_formula FROM league_seasons
WHERE league_id = $1
ORDER BY season_number DESC
`

func (q *Queries) GetSeasonsByLeague(ctx context.Context, leagueID uuid.UUID) ([]LeagueSeason, error) {
	rows, err := q.db.Query(ctx, getSeasonsByLeague, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueSeason
	for rows.Next() {
		var i LeagueSeason
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.LeagueID,
			&i.SeasonNumber,
			&i.StartDate,
			&i.EndDate,
			&i.ActualEndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.DivisionsPreparedAt,
			&i.StartedAt,
			&i.RegistrationOpenedAt,
			&i.StartingSoonNotificationSentAt,
			&i.PromotionFormula,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStandings = `-- name: GetStandings :many
SELECT ls.id, ls.division_id, ls.user_id, ls.wins, ls.losses, ls.draws,
       ls.spread, ls.games_played, ls.games_remaining, ls.result, ls.updated_at,
       ls.total_score, ls.total_opponent_score, ls.total_bingos, ls.total_opponent_bingos,
       ls.total_turns, ls.high_turn, ls.high_game, ls.timeouts, ls.blanks_played,
       ls.total_tiles_played, ls.total_opponent_tiles_played,
       u.uuid as user_uuid, u.username
FROM league_standings ls
JOIN users u ON ls.user_id = u.id
WHERE ls.division_id = $1
`

type GetStandingsRow struct {
	ID                       int64
	DivisionID               uuid.UUID
	UserID                   int32
	Wins                     pgtype.Int4
	Losses                   pgtype.Int4
	Draws                    pgtype.Int4
	Spread                   pgtype.Int4
	GamesPlayed              pgtype.Int4
	GamesRemaining           pgtype.Int4
	Result                   pgtype.Int4
	UpdatedAt                pgtype.Timestamptz
	TotalScore               pgtype.Int4
	TotalOpponentScore       pgtype.Int4
	TotalBingos              pgtype.Int4
	TotalOpponentBingos      pgtype.Int4
	TotalTurns               pgtype.Int4
	HighTurn                 pgtype.Int4
	HighGame                 pgtype.Int4
	Timeouts                 pgtype.Int4
	BlanksPlayed             pgtype.Int4
	TotalTilesPlayed         pgtype.Int4
	TotalOpponentTilesPlayed pgtype.Int4
	UserUuid                 pgtype.Text
	Username                 pgtype.Text
}

// Note: rank column is deprecated and not queried. Sorting is done in Go code.
func (q *Queries) GetStandings(ctx context.Context, divisionID uuid.UUID) ([]GetStandingsRow, error) {
	rows, err := q.db.Query(ctx, getStandings, divisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStandingsRow
	for rows.Next() {
		var i GetStandingsRow
		if err := rows.Scan(
			&i.ID,
			&i.DivisionID,
			&i.UserID,
			&i.Wins,
			&i.Losses,
			&i.Draws,
			&i.Spread,
			&i.GamesPlayed,
			&i.GamesRemaining,
			&i.Result,
			&i.UpdatedAt,
			&i.TotalScore,
			&i.TotalOpponentScore,
			&i.TotalBingos,
			&i.TotalOpponentBingos,
			&i.TotalTurns,
			&i.HighTurn,
			&i.HighGame,
			&i.Timeouts,
			&i.BlanksPlayed,
			&i.TotalTilesPlayed,
			&i.TotalOpponentTilesPlayed,
			&i.UserUuid,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnfinishedLeagueGames = `-- name: GetUnfinishedLeagueGames :many
SELECT
    uuid as game_id,
    player0_id,
    player1_id
FROM games
WHERE season_id = $1
  AND game_end_reason = 0
`

type GetUnfinishedLeagueGamesRow struct {
	GameID    pgtype.Text
	Player0ID pgtype.Int4
	Player1ID pgtype.Int4
}

func (q *Queries) GetUnfinishedLeagueGames(ctx context.Context, seasonID pgtype.UUID) ([]GetUnfinishedLeagueGamesRow, error) {
	rows, err := q.db.Query(ctx, getUnfinishedLeagueGames, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnfinishedLeagueGamesRow
	for rows.Next() {
		var i GetUnfinishedLeagueGamesRow
		if err := rows.Scan(&i.GameID, &i.Player0ID, &i.Player1ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementStandingsAtomic = `-- name: IncrementStandingsAtomic :exec
INSERT INTO league_standings (division_id, user_id, wins, losses, draws, spread, games_played, games_remaining, result,
    total_score, total_opponent_score, total_bingos, total_opponent_bingos, total_turns, high_turn, high_game, timeouts, blanks_played,
    total_tiles_played, total_opponent_tiles_played, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, 1, $7, 0, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, NOW())
ON CONFLICT (division_id, user_id)
DO UPDATE SET
    wins = league_standings.wins + EXCLUDED.wins,
    losses = league_standings.losses + EXCLUDED.losses,
    draws = league_standings.draws + EXCLUDED.draws,
    spread = league_standings.spread + EXCLUDED.spread,
    games_played = league_standings.games_played + 1,
    games_remaining = GREATEST(league_standings.games_remaining - 1, 0),
    total_score = league_standings.total_score + EXCLUDED.total_score,
    total_opponent_score = league_standings.total_opponent_score + EXCLUDED.total_opponent_score,
    total_bingos = league_standings.total_bingos + EXCLUDED.total_bingos,
    total_opponent_bingos = league_standings.total_opponent_bingos + EXCLUDED.total_opponent_bingos,
    total_turns = league_standings.total_turns + EXCLUDED.total_turns,
    high_turn = GREATEST(league_standings.high_turn, EXCLUDED.high_turn),
    high_game = GREATEST(league_standings.high_game, EXCLUDED.high_game),
    timeouts = league_standings.timeouts + EXCLUDED.timeouts,
    blanks_played = league_standings.blanks_played + EXCLUDED.blanks_played,
    total_tiles_played = league_standings.total_tiles_played + EXCLUDED.total_tiles_played,
    total_opponent_tiles_played = league_standings.total_opponent_tiles_played + EXCLUDED.total_opponent_tiles_played,
    updated_at = NOW()
`

type IncrementStandingsAtomicParams struct {
	DivisionID               uuid.UUID
	UserID                   int32
	Wins                     pgtype.Int4
	Losses                   pgtype.Int4
	Draws                    pgtype.Int4
	Spread                   pgtype.Int4
	GamesRemaining           pgtype.Int4
	TotalScore               pgtype.Int4
	TotalOpponentScore       pgtype.Int4
	TotalBingos              pgtype.Int4
	TotalOpponentBingos      pgtype.Int4
	TotalTurns               pgtype.Int4
	HighTurn                 pgtype.Int4
	HighGame                 pgtype.Int4
	Timeouts                 pgtype.Int4
	BlanksPlayed             pgtype.Int4
	TotalTilesPlayed         pgtype.Int4
	TotalOpponentTilesPlayed pgtype.Int4
}

// Atomically increment standings for a player after a game completes
// This avoids race conditions by using database-level arithmetic
func (q *Queries) IncrementStandingsAtomic(ctx context.Context, arg IncrementStandingsAtomicParams) error {
	_, err := q.db.Exec(ctx, incrementStandingsAtomic,
		arg.DivisionID,
		arg.UserID,
		arg.Wins,
		arg.Losses,
		arg.Draws,
		arg.Spread,
		arg.GamesRemaining,
		arg.TotalScore,
		arg.TotalOpponentScore,
		arg.TotalBingos,
		arg.TotalOpponentBingos,
		arg.TotalTurns,
		arg.HighTurn,
		arg.HighGame,
		arg.Timeouts,
		arg.BlanksPlayed,
		arg.TotalTilesPlayed,
		arg.TotalOpponentTilesPlayed,
	)
	return err
}

const markDivisionComplete = `-- name: MarkDivisionComplete :exec
UPDATE league_divisions
SET is_complete = true, updated_at = NOW()
WHERE uuid = $1
`

func (q *Queries) MarkDivisionComplete(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDivisionComplete, argUuid)
	return err
}

const markDivisionsPrepared = `-- name: MarkDivisionsPrepared :exec
UPDATE league_seasons
SET divisions_prepared_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

func (q *Queries) MarkDivisionsPrepared(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDivisionsPrepared, argUuid)
	return err
}

const markRegistrationOpened = `-- name: MarkRegistrationOpened :exec
UPDATE league_seasons
SET registration_opened_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

// Marks when registration was opened for this season
func (q *Queries) MarkRegistrationOpened(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markRegistrationOpened, argUuid)
	return err
}

const markSeasonClosed = `-- name: MarkSeasonClosed :exec

UPDATE league_seasons
SET closed_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

// Task tracking queries for hourly runner idempotency
func (q *Queries) MarkSeasonClosed(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markSeasonClosed, argUuid)
	return err
}

const markSeasonComplete = `-- name: MarkSeasonComplete :exec
UPDATE league_seasons
SET status = 2, actual_end_date = NOW(), updated_at = NOW()  -- SeasonStatus.SEASON_COMPLETED
WHERE uuid = $1
`

func (q *Queries) MarkSeasonComplete(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markSeasonComplete, argUuid)
	return err
}

const markSeasonStarted = `-- name: MarkSeasonStarted :exec
UPDATE league_seasons
SET started_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

func (q *Queries) MarkSeasonStarted(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markSeasonStarted, argUuid)
	return err
}

const markStartingSoonNotificationSent = `-- name: MarkStartingSoonNotificationSent :exec
UPDATE league_seasons
SET starting_soon_notification_sent_at = NOW(), updated_at = NOW()
WHERE uuid = $1
`

func (q *Queries) MarkStartingSoonNotificationSent(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markStartingSoonNotificationSent, argUuid)
	return err
}

const registerPlayer = `-- name: RegisterPlayer :one

INSERT INTO league_registrations (user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (user_id, season_id)
DO UPDATE SET
    division_id = EXCLUDED.division_id,
    firsts_count = EXCLUDED.firsts_count,
    status = EXCLUDED.status,
    placement_status = EXCLUDED.placement_status,
    previous_division_rank = EXCLUDED.previous_division_rank,
    seasons_away = EXCLUDED.seasons_away
RETURNING id, user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away, created_at, updated_at
`

type RegisterPlayerParams struct {
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
}

// Registration operations
func (q *Queries) RegisterPlayer(ctx context.Context, arg RegisterPlayerParams) (LeagueRegistration, error) {
	row := q.db.QueryRow(ctx, registerPlayer,
		arg.UserID,
		arg.SeasonID,
		arg.DivisionID,
		arg.RegistrationDate,
		arg.FirstsCount,
		arg.Status,
		arg.PlacementStatus,
		arg.PreviousDivisionRank,
		arg.SeasonsAway,
	)
	var i LeagueRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SeasonID,
		&i.DivisionID,
		&i.RegistrationDate,
		&i.FirstsCount,
		&i.Status,
		&i.PlacementStatus,
		&i.PreviousDivisionRank,
		&i.SeasonsAway,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setCurrentSeason = `-- name: SetCurrentSeason :exec
UPDATE leagues
SET current_season_id = $2, updated_at = NOW()
WHERE uuid = $1
`

type SetCurrentSeasonParams struct {
	Uuid            uuid.UUID
	CurrentSeasonID pgtype.UUID
}

func (q *Queries) SetCurrentSeason(ctx context.Context, arg SetCurrentSeasonParams) error {
	_, err := q.db.Exec(ctx, setCurrentSeason, arg.Uuid, arg.CurrentSeasonID)
	return err
}

const unregisterPlayer = `-- name: UnregisterPlayer :exec
DELETE FROM league_registrations
WHERE season_id = $1 AND user_id = $2
`

type UnregisterPlayerParams struct {
	SeasonID uuid.UUID
	UserID   int32
}

func (q *Queries) UnregisterPlayer(ctx context.Context, arg UnregisterPlayerParams) error {
	_, err := q.db.Exec(ctx, unregisterPlayer, arg.SeasonID, arg.UserID)
	return err
}

const updateDivisionNumber = `-- name: UpdateDivisionNumber :exec
UPDATE league_divisions
SET division_number = $2, division_name = $3, updated_at = NOW()
WHERE uuid = $1
`

type UpdateDivisionNumberParams struct {
	Uuid           uuid.UUID
	DivisionNumber int32
	DivisionName   pgtype.Text
}

func (q *Queries) UpdateDivisionNumber(ctx context.Context, arg UpdateDivisionNumberParams) error {
	_, err := q.db.Exec(ctx, updateDivisionNumber, arg.Uuid, arg.DivisionNumber, arg.DivisionName)
	return err
}

const updateLeagueMetadata = `-- name: UpdateLeagueMetadata :exec
UPDATE leagues
SET name = $2, description = $3, updated_at = NOW()
WHERE uuid = $1
`

type UpdateLeagueMetadataParams struct {
	Uuid        uuid.UUID
	Name        string
	Description pgtype.Text
}

func (q *Queries) UpdateLeagueMetadata(ctx context.Context, arg UpdateLeagueMetadataParams) error {
	_, err := q.db.Exec(ctx, updateLeagueMetadata, arg.Uuid, arg.Name, arg.Description)
	return err
}

const updateLeagueSettings = `-- name: UpdateLeagueSettings :exec
UPDATE leagues
SET settings = $2, updated_at = NOW()
WHERE uuid = $1
`

type UpdateLeagueSettingsParams struct {
	Uuid     uuid.UUID
	Settings []byte
}

func (q *Queries) UpdateLeagueSettings(ctx context.Context, arg UpdateLeagueSettingsParams) error {
	_, err := q.db.Exec(ctx, updateLeagueSettings, arg.Uuid, arg.Settings)
	return err
}

const updatePlacementStatus = `-- name: UpdatePlacementStatus :exec
UPDATE league_registrations
SET placement_status = $2, previous_division_rank = $3, updated_at = NOW()
WHERE user_id = $1 AND season_id = $4
`

type UpdatePlacementStatusParams struct {
	UserID               int32
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonID             uuid.UUID
}

func (q *Queries) UpdatePlacementStatus(ctx context.Context, arg UpdatePlacementStatusParams) error {
	_, err := q.db.Exec(ctx, updatePlacementStatus,
		arg.UserID,
		arg.PlacementStatus,
		arg.PreviousDivisionRank,
		arg.SeasonID,
	)
	return err
}

const updatePlacementStatusWithSeasonsAway = `-- name: UpdatePlacementStatusWithSeasonsAway :exec
UPDATE league_registrations
SET placement_status = $2, previous_division_rank = $3, seasons_away = $4, updated_at = NOW()
WHERE user_id = $1 AND season_id = $5
`

type UpdatePlacementStatusWithSeasonsAwayParams struct {
	UserID               int32
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	SeasonID             uuid.UUID
}

func (q *Queries) UpdatePlacementStatusWithSeasonsAway(ctx context.Context, arg UpdatePlacementStatusWithSeasonsAwayParams) error {
	_, err := q.db.Exec(ctx, updatePlacementStatusWithSeasonsAway,
		arg.UserID,
		arg.PlacementStatus,
		arg.PreviousDivisionRank,
		arg.SeasonsAway,
		arg.SeasonID,
	)
	return err
}

const updatePlayerDivision = `-- name: UpdatePlayerDivision :exec
UPDATE league_registrations
SET division_id = $1, firsts_count = $2
WHERE user_id = $3 AND season_id = $4
`

type UpdatePlayerDivisionParams struct {
	DivisionID  pgtype.UUID
	FirstsCount pgtype.Int4
	UserID      int32
	SeasonID    uuid.UUID
}

func (q *Queries) UpdatePlayerDivision(ctx context.Context, arg UpdatePlayerDivisionParams) error {
	_, err := q.db.Exec(ctx, updatePlayerDivision,
		arg.DivisionID,
		arg.FirstsCount,
		arg.UserID,
		arg.SeasonID,
	)
	return err
}

const updatePreviousDivisionRank = `-- name: UpdatePreviousDivisionRank :exec
UPDATE league_registrations
SET previous_division_rank = $2, updated_at = NOW()
WHERE user_id = $1 AND season_id = $3
`

type UpdatePreviousDivisionRankParams struct {
	UserID               int32
	PreviousDivisionRank pgtype.Int4
	SeasonID             uuid.UUID
}

func (q *Queries) UpdatePreviousDivisionRank(ctx context.Context, arg UpdatePreviousDivisionRankParams) error {
	_, err := q.db.Exec(ctx, updatePreviousDivisionRank, arg.UserID, arg.PreviousDivisionRank, arg.SeasonID)
	return err
}

const updateRegistrationDivision = `-- name: UpdateRegistrationDivision :exec
UPDATE league_registrations
SET division_id = $2, firsts_count = $3, updated_at = NOW()
WHERE season_id = $1 AND user_id = $4
`

type UpdateRegistrationDivisionParams struct {
	SeasonID    uuid.UUID
	DivisionID  pgtype.UUID
	FirstsCount pgtype.Int4
	UserID      int32
}

func (q *Queries) UpdateRegistrationDivision(ctx context.Context, arg UpdateRegistrationDivisionParams) error {
	_, err := q.db.Exec(ctx, updateRegistrationDivision,
		arg.SeasonID,
		arg.DivisionID,
		arg.FirstsCount,
		arg.UserID,
	)
	return err
}

const updateSeasonDates = `-- name: UpdateSeasonDates :exec
UPDATE league_seasons
SET start_date = $2, end_date = $3, updated_at = NOW()
WHERE uuid = $1
`

type UpdateSeasonDatesParams struct {
	Uuid      uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

func (q *Queries) UpdateSeasonDates(ctx context.Context, arg UpdateSeasonDatesParams) error {
	_, err := q.db.Exec(ctx, updateSeasonDates, arg.Uuid, arg.StartDate, arg.EndDate)
	return err
}

const updateSeasonPromotionFormula = `-- name: UpdateSeasonPromotionFormula :exec
UPDATE league_seasons
SET promotion_formula = $2, updated_at = NOW()
WHERE uuid = $1
`

type UpdateSeasonPromotionFormulaParams struct {
	Uuid             uuid.UUID
	PromotionFormula int32
}

func (q *Queries) UpdateSeasonPromotionFormula(ctx context.Context, arg UpdateSeasonPromotionFormulaParams) error {
	_, err := q.db.Exec(ctx, updateSeasonPromotionFormula, arg.Uuid, arg.PromotionFormula)
	return err
}

const updateSeasonStatus = `-- name: UpdateSeasonStatus :exec
UPDATE league_seasons
SET status = $2, updated_at = NOW()
WHERE uuid = $1
`

type UpdateSeasonStatusParams struct {
	Uuid   uuid.UUID
	Status int32
}

func (q *Queries) UpdateSeasonStatus(ctx context.Context, arg UpdateSeasonStatusParams) error {
	_, err := q.db.Exec(ctx, updateSeasonStatus, arg.Uuid, arg.Status)
	return err
}

const updateStandingResult = `-- name: UpdateStandingResult :exec
UPDATE league_standings
SET result = $3, updated_at = NOW()
WHERE division_id = $1 AND user_id = $2
`

type UpdateStandingResultParams struct {
	DivisionID uuid.UUID
	UserID     int32
	Result     pgtype.Int4
}

// Updates only the result (outcome) field for a standing without touching other stats
func (q *Queries) UpdateStandingResult(ctx context.Context, arg UpdateStandingResultParams) error {
	_, err := q.db.Exec(ctx, updateStandingResult, arg.DivisionID, arg.UserID, arg.Result)
	return err
}

const upsertStanding = `-- name: UpsertStanding :exec

INSERT INTO league_standings (division_id, user_id, wins, losses, draws, spread, games_played, games_remaining, result,
    total_score, total_opponent_score, total_bingos, total_opponent_bingos, total_turns, high_turn, high_game, timeouts, blanks_played,
    total_tiles_played, total_opponent_tiles_played, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, NOW())
ON CONFLICT (division_id, user_id)
DO UPDATE SET
    wins = EXCLUDED.wins,
    losses = EXCLUDED.losses,
    draws = EXCLUDED.draws,
    spread = EXCLUDED.spread,
    games_played = EXCLUDED.games_played,
    games_remaining = EXCLUDED.games_remaining,
    result = EXCLUDED.result,
    total_score = EXCLUDED.total_score,
    total_opponent_score = EXCLUDED.total_opponent_score,
    total_bingos = EXCLUDED.total_bingos,
    total_opponent_bingos = EXCLUDED.total_opponent_bingos,
    total_turns = EXCLUDED.total_turns,
    high_turn = EXCLUDED.high_turn,
    high_game = EXCLUDED.high_game,
    timeouts = EXCLUDED.timeouts,
    blanks_played = EXCLUDED.blanks_played,
    total_tiles_played = EXCLUDED.total_tiles_played,
    total_opponent_tiles_played = EXCLUDED.total_opponent_tiles_played,
    updated_at = NOW()
`

type UpsertStandingParams struct {
	DivisionID               uuid.UUID
	UserID                   int32
	Wins                     pgtype.Int4
	Losses                   pgtype.Int4
	Draws                    pgtype.Int4
	Spread                   pgtype.Int4
	GamesPlayed              pgtype.Int4
	GamesRemaining           pgtype.Int4
	Result                   pgtype.Int4
	TotalScore               pgtype.Int4
	TotalOpponentScore       pgtype.Int4
	TotalBingos              pgtype.Int4
	TotalOpponentBingos      pgtype.Int4
	TotalTurns               pgtype.Int4
	HighTurn                 pgtype.Int4
	HighGame                 pgtype.Int4
	Timeouts                 pgtype.Int4
	BlanksPlayed             pgtype.Int4
	TotalTilesPlayed         pgtype.Int4
	TotalOpponentTilesPlayed pgtype.Int4
}

// Standings operations
// Note: rank column is not upserted - it's calculated on-demand from wins/losses/draws/spread
func (q *Queries) UpsertStanding(ctx context.Context, arg UpsertStandingParams) error {
	_, err := q.db.Exec(ctx, upsertStanding,
		arg.DivisionID,
		arg.UserID,
		arg.Wins,
		arg.Losses,
		arg.Draws,
		arg.Spread,
		arg.GamesPlayed,
		arg.GamesRemaining,
		arg.Result,
		arg.TotalScore,
		arg.TotalOpponentScore,
		arg.TotalBingos,
		arg.TotalOpponentBingos,
		arg.TotalTurns,
		arg.HighTurn,
		arg.HighGame,
		arg.Timeouts,
		arg.BlanksPlayed,
		arg.TotalTilesPlayed,
		arg.TotalOpponentTilesPlayed,
	)
	return err
}
