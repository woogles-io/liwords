// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: leagues.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countDivisionGamesComplete = `-- name: CountDivisionGamesComplete :one
SELECT COUNT(*) FROM games
WHERE league_division_id = $1 AND game_end_reason != 0
`

func (q *Queries) CountDivisionGamesComplete(ctx context.Context, leagueDivisionID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDivisionGamesComplete, leagueDivisionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDivisionGamesTotal = `-- name: CountDivisionGamesTotal :one
SELECT COUNT(*) FROM games
WHERE league_division_id = $1
`

func (q *Queries) CountDivisionGamesTotal(ctx context.Context, leagueDivisionID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDivisionGamesTotal, leagueDivisionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDivision = `-- name: CreateDivision :one

INSERT INTO league_divisions (uuid, season_id, division_number, division_name, player_count, is_complete)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, uuid, season_id, division_number, division_name, player_count, is_complete, created_at, updated_at
`

type CreateDivisionParams struct {
	Uuid           uuid.UUID
	SeasonID       uuid.UUID
	DivisionNumber int32
	DivisionName   pgtype.Text
	PlayerCount    pgtype.Int4
	IsComplete     pgtype.Bool
}

// Division operations
func (q *Queries) CreateDivision(ctx context.Context, arg CreateDivisionParams) (LeagueDivision, error) {
	row := q.db.QueryRow(ctx, createDivision,
		arg.Uuid,
		arg.SeasonID,
		arg.DivisionNumber,
		arg.DivisionName,
		arg.PlayerCount,
		arg.IsComplete,
	)
	var i LeagueDivision
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.SeasonID,
		&i.DivisionNumber,
		&i.DivisionName,
		&i.PlayerCount,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeague = `-- name: CreateLeague :one

INSERT INTO leagues (uuid, name, description, slug, settings, is_active, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by
`

type CreateLeagueParams struct {
	Uuid        uuid.UUID
	Name        string
	Description pgtype.Text
	Slug        string
	Settings    []byte
	IsActive    pgtype.Bool
	CreatedBy   pgtype.Int8
}

// League operations
func (q *Queries) CreateLeague(ctx context.Context, arg CreateLeagueParams) (League, error) {
	row := q.db.QueryRow(ctx, createLeague,
		arg.Uuid,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.Settings,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Slug,
		&i.Settings,
		&i.CurrentSeasonID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createSeason = `-- name: CreateSeason :one

INSERT INTO league_seasons (uuid, league_id, season_number, start_date, end_date, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at
`

type CreateSeasonParams struct {
	Uuid         uuid.UUID
	LeagueID     uuid.UUID
	SeasonNumber int32
	StartDate    pgtype.Timestamptz
	EndDate      pgtype.Timestamptz
	Status       int32
}

// Season operations
func (q *Queries) CreateSeason(ctx context.Context, arg CreateSeasonParams) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, createSeason,
		arg.Uuid,
		arg.LeagueID,
		arg.SeasonNumber,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
	)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDivision = `-- name: DeleteDivision :exec
DELETE FROM league_divisions
WHERE uuid = $1
`

func (q *Queries) DeleteDivision(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDivision, argUuid)
	return err
}

const deleteDivisionStandings = `-- name: DeleteDivisionStandings :exec
DELETE FROM league_standings
WHERE division_id = $1
`

func (q *Queries) DeleteDivisionStandings(ctx context.Context, divisionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDivisionStandings, divisionID)
	return err
}

const forceFinishGame = `-- name: ForceFinishGame :exec
UPDATE games
SET game_end_reason = 8,  -- FORCE_FORFEIT
    winner_idx = $2,
    loser_idx = $3,
    updated_at = NOW()
WHERE uuid = $1
`

type ForceFinishGameParams struct {
	Uuid      pgtype.Text
	WinnerIdx pgtype.Int4
	LoserIdx  pgtype.Int4
}

func (q *Queries) ForceFinishGame(ctx context.Context, arg ForceFinishGameParams) error {
	_, err := q.db.Exec(ctx, forceFinishGame, arg.Uuid, arg.WinnerIdx, arg.LoserIdx)
	return err
}

const getAllLeagues = `-- name: GetAllLeagues :many
SELECT id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by FROM leagues
WHERE ($1::boolean = false OR is_active = true)
ORDER BY name
`

func (q *Queries) GetAllLeagues(ctx context.Context, activeOnly bool) ([]League, error) {
	rows, err := q.db.Query(ctx, getAllLeagues, activeOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []League
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.Slug,
			&i.Settings,
			&i.CurrentSeasonID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentSeason = `-- name: GetCurrentSeason :one
SELECT ls.id, ls.uuid, ls.league_id, ls.season_number, ls.start_date, ls.end_date, ls.actual_end_date, ls.status, ls.created_at, ls.updated_at FROM league_seasons ls
JOIN leagues l ON l.current_season_id = ls.uuid
WHERE l.uuid = $1
`

func (q *Queries) GetCurrentSeason(ctx context.Context, argUuid uuid.UUID) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, getCurrentSeason, argUuid)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDivision = `-- name: GetDivision :one
SELECT id, uuid, season_id, division_number, division_name, player_count, is_complete, created_at, updated_at FROM league_divisions WHERE uuid = $1
`

func (q *Queries) GetDivision(ctx context.Context, argUuid uuid.UUID) (LeagueDivision, error) {
	row := q.db.QueryRow(ctx, getDivision, argUuid)
	var i LeagueDivision
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.SeasonID,
		&i.DivisionNumber,
		&i.DivisionName,
		&i.PlayerCount,
		&i.IsComplete,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDivisionGameResults = `-- name: GetDivisionGameResults :many
SELECT
    g.uuid,
    g.player0_id,
    g.player1_id,
    gp0.score as player0_score,
    gp1.score as player1_score,
    gp0.won as player0_won,
    gp1.won as player1_won,
    gp0.game_end_reason
FROM games g
INNER JOIN game_players gp0 ON g.uuid = gp0.game_uuid AND gp0.player_index = 0
INNER JOIN game_players gp1 ON g.uuid = gp1.game_uuid AND gp1.player_index = 1
WHERE g.league_division_id = $1
  AND gp0.game_end_reason != 0  -- Only finished games
  AND gp0.game_end_reason != 5  -- Exclude ABORTED
  AND gp0.game_end_reason != 7
`

type GetDivisionGameResultsRow struct {
	Uuid          pgtype.Text
	Player0ID     pgtype.Int4
	Player1ID     pgtype.Int4
	Player0Score  int32
	Player1Score  int32
	Player0Won    pgtype.Bool
	Player1Won    pgtype.Bool
	GameEndReason int16
}

func (q *Queries) GetDivisionGameResults(ctx context.Context, leagueDivisionID pgtype.UUID) ([]GetDivisionGameResultsRow, error) {
	rows, err := q.db.Query(ctx, getDivisionGameResults, leagueDivisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDivisionGameResultsRow
	for rows.Next() {
		var i GetDivisionGameResultsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Player0Score,
			&i.Player1Score,
			&i.Player0Won,
			&i.Player1Won,
			&i.GameEndReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDivisionRegistrations = `-- name: GetDivisionRegistrations :many
SELECT lr.id, lr.user_id, lr.season_id, lr.division_id, lr.registration_date, lr.firsts_count, lr.status, lr.placement_status, lr.previous_division_rank, lr.seasons_away, lr.created_at, lr.updated_at, u.uuid as user_uuid FROM league_registrations lr
JOIN users u ON lr.user_id = u.id
WHERE lr.division_id = $1
ORDER BY lr.registration_date
`

type GetDivisionRegistrationsRow struct {
	ID                   int64
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	UserUuid             pgtype.Text
}

func (q *Queries) GetDivisionRegistrations(ctx context.Context, divisionID pgtype.UUID) ([]GetDivisionRegistrationsRow, error) {
	rows, err := q.db.Query(ctx, getDivisionRegistrations, divisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDivisionRegistrationsRow
	for rows.Next() {
		var i GetDivisionRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDivisionsBySeason = `-- name: GetDivisionsBySeason :many
SELECT id, uuid, season_id, division_number, division_name, player_count, is_complete, created_at, updated_at FROM league_divisions
WHERE season_id = $1
ORDER BY division_number ASC
`

func (q *Queries) GetDivisionsBySeason(ctx context.Context, seasonID uuid.UUID) ([]LeagueDivision, error) {
	rows, err := q.db.Query(ctx, getDivisionsBySeason, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueDivision
	for rows.Next() {
		var i LeagueDivision
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.SeasonID,
			&i.DivisionNumber,
			&i.DivisionName,
			&i.PlayerCount,
			&i.IsComplete,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameLeagueInfo = `-- name: GetGameLeagueInfo :one

SELECT
    g.league_division_id,
    g.season_id,
    g.league_id,
    g.player0_id,
    g.player1_id,
    gp0.score as player0_score,
    gp1.score as player1_score,
    gp0.won as player0_won,
    gp1.won as player1_won,
    gp0.game_end_reason
FROM games g
LEFT JOIN game_players gp0 ON g.uuid = gp0.game_uuid AND gp0.player_index = 0
LEFT JOIN game_players gp1 ON g.uuid = gp1.game_uuid AND gp1.player_index = 1
WHERE g.uuid = $1
`

type GetGameLeagueInfoRow struct {
	LeagueDivisionID pgtype.UUID
	SeasonID         pgtype.UUID
	LeagueID         pgtype.UUID
	Player0ID        pgtype.Int4
	Player1ID        pgtype.Int4
	Player0Score     pgtype.Int4
	Player1Score     pgtype.Int4
	Player0Won       pgtype.Bool
	Player1Won       pgtype.Bool
	GameEndReason    pgtype.Int2
}

// Exclude CANCELLED
func (q *Queries) GetGameLeagueInfo(ctx context.Context, argUuid pgtype.Text) (GetGameLeagueInfoRow, error) {
	row := q.db.QueryRow(ctx, getGameLeagueInfo, argUuid)
	var i GetGameLeagueInfoRow
	err := row.Scan(
		&i.LeagueDivisionID,
		&i.SeasonID,
		&i.LeagueID,
		&i.Player0ID,
		&i.Player1ID,
		&i.Player0Score,
		&i.Player1Score,
		&i.Player0Won,
		&i.Player1Won,
		&i.GameEndReason,
	)
	return i, err
}

const getLeagueBySlug = `-- name: GetLeagueBySlug :one
SELECT id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by FROM leagues WHERE LOWER(slug) = LOWER($1)
`

func (q *Queries) GetLeagueBySlug(ctx context.Context, lower string) (League, error) {
	row := q.db.QueryRow(ctx, getLeagueBySlug, lower)
	var i League
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Slug,
		&i.Settings,
		&i.CurrentSeasonID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getLeagueByUUID = `-- name: GetLeagueByUUID :one
SELECT id, uuid, name, description, slug, settings, current_season_id, is_active, created_at, updated_at, created_by FROM leagues WHERE uuid = $1
`

func (q *Queries) GetLeagueByUUID(ctx context.Context, argUuid uuid.UUID) (League, error) {
	row := q.db.QueryRow(ctx, getLeagueByUUID, argUuid)
	var i League
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Slug,
		&i.Settings,
		&i.CurrentSeasonID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getLeagueGames = `-- name: GetLeagueGames :many

SELECT id, created_at, updated_at, deleted_at, uuid, player0_id, player1_id, timers, started, game_end_reason, winner_idx, loser_idx, history, stats, quickdata, tournament_data, tournament_id, ready_flag, meta_events, type, game_request, history_in_s3, player_on_turn, league_id, season_id, league_division_id FROM games
WHERE league_division_id = $1
ORDER BY created_at
`

// Game queries for league games
func (q *Queries) GetLeagueGames(ctx context.Context, leagueDivisionID pgtype.UUID) ([]Game, error) {
	rows, err := q.db.Query(ctx, getLeagueGames, leagueDivisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.History,
			&i.Stats,
			&i.Quickdata,
			&i.TournamentData,
			&i.TournamentID,
			&i.ReadyFlag,
			&i.MetaEvents,
			&i.Type,
			&i.GameRequest,
			&i.HistoryInS3,
			&i.PlayerOnTurn,
			&i.LeagueID,
			&i.SeasonID,
			&i.LeagueDivisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueGamesByStatus = `-- name: GetLeagueGamesByStatus :many
SELECT id, created_at, updated_at, deleted_at, uuid, player0_id, player1_id, timers, started, game_end_reason, winner_idx, loser_idx, history, stats, quickdata, tournament_data, tournament_id, ready_flag, meta_events, type, game_request, history_in_s3, player_on_turn, league_id, season_id, league_division_id FROM games
WHERE league_division_id = $1
  AND ($2::boolean = true OR game_end_reason = 0)
ORDER BY created_at
`

type GetLeagueGamesByStatusParams struct {
	LeagueDivisionID pgtype.UUID
	IncludeFinished  bool
}

func (q *Queries) GetLeagueGamesByStatus(ctx context.Context, arg GetLeagueGamesByStatusParams) ([]Game, error) {
	rows, err := q.db.Query(ctx, getLeagueGamesByStatus, arg.LeagueDivisionID, arg.IncludeFinished)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Uuid,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.History,
			&i.Stats,
			&i.Quickdata,
			&i.TournamentData,
			&i.TournamentID,
			&i.ReadyFlag,
			&i.MetaEvents,
			&i.Type,
			&i.GameRequest,
			&i.HistoryInS3,
			&i.PlayerOnTurn,
			&i.LeagueID,
			&i.SeasonID,
			&i.LeagueDivisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPastSeasons = `-- name: GetPastSeasons :many
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at FROM league_seasons
WHERE league_id = $1 AND status = 2  -- SeasonStatus.SEASON_COMPLETED
ORDER BY season_number DESC
`

func (q *Queries) GetPastSeasons(ctx context.Context, leagueID uuid.UUID) ([]LeagueSeason, error) {
	rows, err := q.db.Query(ctx, getPastSeasons, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueSeason
	for rows.Next() {
		var i LeagueSeason
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.LeagueID,
			&i.SeasonNumber,
			&i.StartDate,
			&i.EndDate,
			&i.ActualEndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerRegistration = `-- name: GetPlayerRegistration :one
SELECT id, user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away, created_at, updated_at FROM league_registrations
WHERE season_id = $1 AND user_id = $2
`

type GetPlayerRegistrationParams struct {
	SeasonID uuid.UUID
	UserID   int32
}

func (q *Queries) GetPlayerRegistration(ctx context.Context, arg GetPlayerRegistrationParams) (LeagueRegistration, error) {
	row := q.db.QueryRow(ctx, getPlayerRegistration, arg.SeasonID, arg.UserID)
	var i LeagueRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SeasonID,
		&i.DivisionID,
		&i.RegistrationDate,
		&i.FirstsCount,
		&i.Status,
		&i.PlacementStatus,
		&i.PreviousDivisionRank,
		&i.SeasonsAway,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerSeasonHistory = `-- name: GetPlayerSeasonHistory :many
SELECT lr.id, lr.user_id, lr.season_id, lr.division_id, lr.registration_date, lr.firsts_count, lr.status, lr.placement_status, lr.previous_division_rank, lr.seasons_away, lr.created_at, lr.updated_at, ls.season_number, ls.league_id
FROM league_registrations lr
JOIN league_seasons ls ON lr.season_id = ls.uuid
WHERE lr.user_id = $1
  AND ($2::uuid IS NULL OR ls.league_id = $2)
ORDER BY ls.season_number DESC
`

type GetPlayerSeasonHistoryParams struct {
	UserID   int32
	LeagueID uuid.UUID
}

type GetPlayerSeasonHistoryRow struct {
	ID                   int64
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	SeasonNumber         int32
	LeagueID             uuid.UUID
}

func (q *Queries) GetPlayerSeasonHistory(ctx context.Context, arg GetPlayerSeasonHistoryParams) ([]GetPlayerSeasonHistoryRow, error) {
	rows, err := q.db.Query(ctx, getPlayerSeasonHistory, arg.UserID, arg.LeagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerSeasonHistoryRow
	for rows.Next() {
		var i GetPlayerSeasonHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeasonNumber,
			&i.LeagueID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStanding = `-- name: GetPlayerStanding :one
SELECT id, division_id, user_id, rank, wins, losses, draws, spread, games_played, games_remaining, result, updated_at FROM league_standings
WHERE division_id = $1 AND user_id = $2
`

type GetPlayerStandingParams struct {
	DivisionID uuid.UUID
	UserID     int32
}

func (q *Queries) GetPlayerStanding(ctx context.Context, arg GetPlayerStandingParams) (LeagueStanding, error) {
	row := q.db.QueryRow(ctx, getPlayerStanding, arg.DivisionID, arg.UserID)
	var i LeagueStanding
	err := row.Scan(
		&i.ID,
		&i.DivisionID,
		&i.UserID,
		&i.Rank,
		&i.Wins,
		&i.Losses,
		&i.Draws,
		&i.Spread,
		&i.GamesPlayed,
		&i.GamesRemaining,
		&i.Result,
		&i.UpdatedAt,
	)
	return i, err
}

const getRegistrationsByDivision = `-- name: GetRegistrationsByDivision :many
SELECT id, user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away, created_at, updated_at FROM league_registrations
WHERE division_id = $1
ORDER BY placement_status, previous_division_rank
`

func (q *Queries) GetRegistrationsByDivision(ctx context.Context, divisionID pgtype.UUID) ([]LeagueRegistration, error) {
	rows, err := q.db.Query(ctx, getRegistrationsByDivision, divisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueRegistration
	for rows.Next() {
		var i LeagueRegistration
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeason = `-- name: GetSeason :one
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at FROM league_seasons WHERE uuid = $1
`

func (q *Queries) GetSeason(ctx context.Context, argUuid uuid.UUID) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, getSeason, argUuid)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeasonByLeagueAndNumber = `-- name: GetSeasonByLeagueAndNumber :one
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at FROM league_seasons
WHERE league_id = $1 AND season_number = $2
`

type GetSeasonByLeagueAndNumberParams struct {
	LeagueID     uuid.UUID
	SeasonNumber int32
}

func (q *Queries) GetSeasonByLeagueAndNumber(ctx context.Context, arg GetSeasonByLeagueAndNumberParams) (LeagueSeason, error) {
	row := q.db.QueryRow(ctx, getSeasonByLeagueAndNumber, arg.LeagueID, arg.SeasonNumber)
	var i LeagueSeason
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.LeagueID,
		&i.SeasonNumber,
		&i.StartDate,
		&i.EndDate,
		&i.ActualEndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeasonRegistrations = `-- name: GetSeasonRegistrations :many
SELECT lr.id, lr.user_id, lr.season_id, lr.division_id, lr.registration_date, lr.firsts_count, lr.status, lr.placement_status, lr.previous_division_rank, lr.seasons_away, lr.created_at, lr.updated_at, u.uuid as user_uuid FROM league_registrations lr
JOIN users u ON lr.user_id = u.id
WHERE lr.season_id = $1
ORDER BY lr.registration_date
`

type GetSeasonRegistrationsRow struct {
	ID                   int64
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	UserUuid             pgtype.Text
}

func (q *Queries) GetSeasonRegistrations(ctx context.Context, seasonID uuid.UUID) ([]GetSeasonRegistrationsRow, error) {
	rows, err := q.db.Query(ctx, getSeasonRegistrations, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonRegistrationsRow
	for rows.Next() {
		var i GetSeasonRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeasonID,
			&i.DivisionID,
			&i.RegistrationDate,
			&i.FirstsCount,
			&i.Status,
			&i.PlacementStatus,
			&i.PreviousDivisionRank,
			&i.SeasonsAway,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonsByLeague = `-- name: GetSeasonsByLeague :many
SELECT id, uuid, league_id, season_number, start_date, end_date, actual_end_date, status, created_at, updated_at FROM league_seasons
WHERE league_id = $1
ORDER BY season_number DESC
`

func (q *Queries) GetSeasonsByLeague(ctx context.Context, leagueID uuid.UUID) ([]LeagueSeason, error) {
	rows, err := q.db.Query(ctx, getSeasonsByLeague, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueSeason
	for rows.Next() {
		var i LeagueSeason
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.LeagueID,
			&i.SeasonNumber,
			&i.StartDate,
			&i.EndDate,
			&i.ActualEndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStandings = `-- name: GetStandings :many
SELECT ls.id, ls.division_id, ls.user_id, ls.rank, ls.wins, ls.losses, ls.draws, ls.spread, ls.games_played, ls.games_remaining, ls.result, ls.updated_at, u.uuid as user_uuid, u.username FROM league_standings ls
JOIN users u ON ls.user_id = u.id
WHERE ls.division_id = $1
ORDER BY ls.rank ASC
`

type GetStandingsRow struct {
	ID             int64
	DivisionID     uuid.UUID
	UserID         int32
	Rank           pgtype.Int4
	Wins           pgtype.Int4
	Losses         pgtype.Int4
	Draws          pgtype.Int4
	Spread         pgtype.Int4
	GamesPlayed    pgtype.Int4
	GamesRemaining pgtype.Int4
	Result         pgtype.Int4
	UpdatedAt      pgtype.Timestamptz
	UserUuid       pgtype.Text
	Username       pgtype.Text
}

func (q *Queries) GetStandings(ctx context.Context, divisionID uuid.UUID) ([]GetStandingsRow, error) {
	rows, err := q.db.Query(ctx, getStandings, divisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStandingsRow
	for rows.Next() {
		var i GetStandingsRow
		if err := rows.Scan(
			&i.ID,
			&i.DivisionID,
			&i.UserID,
			&i.Rank,
			&i.Wins,
			&i.Losses,
			&i.Draws,
			&i.Spread,
			&i.GamesPlayed,
			&i.GamesRemaining,
			&i.Result,
			&i.UpdatedAt,
			&i.UserUuid,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnfinishedLeagueGames = `-- name: GetUnfinishedLeagueGames :many
SELECT
    uuid as game_id,
    player0_id,
    player1_id
FROM games
WHERE season_id = $1
  AND game_end_reason = 0
`

type GetUnfinishedLeagueGamesRow struct {
	GameID    pgtype.Text
	Player0ID pgtype.Int4
	Player1ID pgtype.Int4
}

func (q *Queries) GetUnfinishedLeagueGames(ctx context.Context, seasonID pgtype.UUID) ([]GetUnfinishedLeagueGamesRow, error) {
	rows, err := q.db.Query(ctx, getUnfinishedLeagueGames, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnfinishedLeagueGamesRow
	for rows.Next() {
		var i GetUnfinishedLeagueGamesRow
		if err := rows.Scan(&i.GameID, &i.Player0ID, &i.Player1ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementStandingsAtomic = `-- name: IncrementStandingsAtomic :exec
INSERT INTO league_standings (division_id, user_id, rank, wins, losses, draws, spread, games_played, games_remaining, result, updated_at)
VALUES ($1, $2, 0, $3, $4, $5, $6, 1, $7, 0, NOW())
ON CONFLICT (division_id, user_id)
DO UPDATE SET
    wins = league_standings.wins + EXCLUDED.wins,
    losses = league_standings.losses + EXCLUDED.losses,
    draws = league_standings.draws + EXCLUDED.draws,
    spread = league_standings.spread + EXCLUDED.spread,
    games_played = league_standings.games_played + 1,
    games_remaining = GREATEST(league_standings.games_remaining - 1, 0),
    updated_at = NOW()
`

type IncrementStandingsAtomicParams struct {
	DivisionID     uuid.UUID
	UserID         int32
	Wins           pgtype.Int4
	Losses         pgtype.Int4
	Draws          pgtype.Int4
	Spread         pgtype.Int4
	GamesRemaining pgtype.Int4
}

// Atomically increment standings for a player after a game completes
// This avoids race conditions by using database-level arithmetic
func (q *Queries) IncrementStandingsAtomic(ctx context.Context, arg IncrementStandingsAtomicParams) error {
	_, err := q.db.Exec(ctx, incrementStandingsAtomic,
		arg.DivisionID,
		arg.UserID,
		arg.Wins,
		arg.Losses,
		arg.Draws,
		arg.Spread,
		arg.GamesRemaining,
	)
	return err
}

const markDivisionComplete = `-- name: MarkDivisionComplete :exec
UPDATE league_divisions
SET is_complete = true, updated_at = NOW()
WHERE uuid = $1
`

func (q *Queries) MarkDivisionComplete(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDivisionComplete, argUuid)
	return err
}

const markSeasonComplete = `-- name: MarkSeasonComplete :exec
UPDATE league_seasons
SET status = 2, actual_end_date = NOW(), updated_at = NOW()  -- SeasonStatus.SEASON_COMPLETED
WHERE uuid = $1
`

func (q *Queries) MarkSeasonComplete(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, markSeasonComplete, argUuid)
	return err
}

const recalculateRanks = `-- name: RecalculateRanks :exec
WITH ranked AS (
    SELECT
        ls.division_id,
        ls.user_id,
        ROW_NUMBER() OVER (
            PARTITION BY ls.division_id
            ORDER BY ls.wins DESC, ls.spread DESC
        ) as new_rank
    FROM league_standings ls
    WHERE ls.division_id = $1
)
UPDATE league_standings
SET rank = ranked.new_rank,
    updated_at = NOW()
FROM ranked
WHERE league_standings.division_id = ranked.division_id
  AND league_standings.user_id = ranked.user_id
`

// Recalculate ranks for all players in a division
// Ranks are based on: wins (DESC), then spread (DESC)
func (q *Queries) RecalculateRanks(ctx context.Context, divisionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, recalculateRanks, divisionID)
	return err
}

const registerPlayer = `-- name: RegisterPlayer :one

INSERT INTO league_registrations (user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (user_id, season_id)
DO UPDATE SET
    division_id = EXCLUDED.division_id,
    firsts_count = EXCLUDED.firsts_count,
    status = EXCLUDED.status,
    placement_status = EXCLUDED.placement_status,
    previous_division_rank = EXCLUDED.previous_division_rank,
    seasons_away = EXCLUDED.seasons_away
RETURNING id, user_id, season_id, division_id, registration_date, firsts_count, status, placement_status, previous_division_rank, seasons_away, created_at, updated_at
`

type RegisterPlayerParams struct {
	UserID               int32
	SeasonID             uuid.UUID
	DivisionID           pgtype.UUID
	RegistrationDate     pgtype.Timestamptz
	FirstsCount          pgtype.Int4
	Status               pgtype.Text
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
}

// Registration operations
func (q *Queries) RegisterPlayer(ctx context.Context, arg RegisterPlayerParams) (LeagueRegistration, error) {
	row := q.db.QueryRow(ctx, registerPlayer,
		arg.UserID,
		arg.SeasonID,
		arg.DivisionID,
		arg.RegistrationDate,
		arg.FirstsCount,
		arg.Status,
		arg.PlacementStatus,
		arg.PreviousDivisionRank,
		arg.SeasonsAway,
	)
	var i LeagueRegistration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SeasonID,
		&i.DivisionID,
		&i.RegistrationDate,
		&i.FirstsCount,
		&i.Status,
		&i.PlacementStatus,
		&i.PreviousDivisionRank,
		&i.SeasonsAway,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setCurrentSeason = `-- name: SetCurrentSeason :exec
UPDATE leagues
SET current_season_id = $2, updated_at = NOW()
WHERE uuid = $1
`

type SetCurrentSeasonParams struct {
	Uuid            uuid.UUID
	CurrentSeasonID pgtype.UUID
}

func (q *Queries) SetCurrentSeason(ctx context.Context, arg SetCurrentSeasonParams) error {
	_, err := q.db.Exec(ctx, setCurrentSeason, arg.Uuid, arg.CurrentSeasonID)
	return err
}

const unregisterPlayer = `-- name: UnregisterPlayer :exec
DELETE FROM league_registrations
WHERE season_id = $1 AND user_id = $2
`

type UnregisterPlayerParams struct {
	SeasonID uuid.UUID
	UserID   int32
}

func (q *Queries) UnregisterPlayer(ctx context.Context, arg UnregisterPlayerParams) error {
	_, err := q.db.Exec(ctx, unregisterPlayer, arg.SeasonID, arg.UserID)
	return err
}

const updateDivisionNumber = `-- name: UpdateDivisionNumber :exec
UPDATE league_divisions
SET division_number = $2, division_name = $3, updated_at = NOW()
WHERE uuid = $1
`

type UpdateDivisionNumberParams struct {
	Uuid           uuid.UUID
	DivisionNumber int32
	DivisionName   pgtype.Text
}

func (q *Queries) UpdateDivisionNumber(ctx context.Context, arg UpdateDivisionNumberParams) error {
	_, err := q.db.Exec(ctx, updateDivisionNumber, arg.Uuid, arg.DivisionNumber, arg.DivisionName)
	return err
}

const updateDivisionPlayerCount = `-- name: UpdateDivisionPlayerCount :exec
UPDATE league_divisions
SET player_count = $2, updated_at = NOW()
WHERE uuid = $1
`

type UpdateDivisionPlayerCountParams struct {
	Uuid        uuid.UUID
	PlayerCount pgtype.Int4
}

func (q *Queries) UpdateDivisionPlayerCount(ctx context.Context, arg UpdateDivisionPlayerCountParams) error {
	_, err := q.db.Exec(ctx, updateDivisionPlayerCount, arg.Uuid, arg.PlayerCount)
	return err
}

const updateLeagueSettings = `-- name: UpdateLeagueSettings :exec
UPDATE leagues
SET settings = $2, updated_at = NOW()
WHERE uuid = $1
`

type UpdateLeagueSettingsParams struct {
	Uuid     uuid.UUID
	Settings []byte
}

func (q *Queries) UpdateLeagueSettings(ctx context.Context, arg UpdateLeagueSettingsParams) error {
	_, err := q.db.Exec(ctx, updateLeagueSettings, arg.Uuid, arg.Settings)
	return err
}

const updatePlacementStatus = `-- name: UpdatePlacementStatus :exec
UPDATE league_registrations
SET placement_status = $2, previous_division_rank = $3, updated_at = NOW()
WHERE user_id = $1 AND season_id = $4
`

type UpdatePlacementStatusParams struct {
	UserID               int32
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonID             uuid.UUID
}

func (q *Queries) UpdatePlacementStatus(ctx context.Context, arg UpdatePlacementStatusParams) error {
	_, err := q.db.Exec(ctx, updatePlacementStatus,
		arg.UserID,
		arg.PlacementStatus,
		arg.PreviousDivisionRank,
		arg.SeasonID,
	)
	return err
}

const updatePlacementStatusWithSeasonsAway = `-- name: UpdatePlacementStatusWithSeasonsAway :exec
UPDATE league_registrations
SET placement_status = $2, previous_division_rank = $3, seasons_away = $4, updated_at = NOW()
WHERE user_id = $1 AND season_id = $5
`

type UpdatePlacementStatusWithSeasonsAwayParams struct {
	UserID               int32
	PlacementStatus      pgtype.Int4
	PreviousDivisionRank pgtype.Int4
	SeasonsAway          pgtype.Int4
	SeasonID             uuid.UUID
}

func (q *Queries) UpdatePlacementStatusWithSeasonsAway(ctx context.Context, arg UpdatePlacementStatusWithSeasonsAwayParams) error {
	_, err := q.db.Exec(ctx, updatePlacementStatusWithSeasonsAway,
		arg.UserID,
		arg.PlacementStatus,
		arg.PreviousDivisionRank,
		arg.SeasonsAway,
		arg.SeasonID,
	)
	return err
}

const updatePlayerDivision = `-- name: UpdatePlayerDivision :exec
UPDATE league_registrations
SET division_id = $1, firsts_count = $2
WHERE user_id = $3 AND season_id = $4
`

type UpdatePlayerDivisionParams struct {
	DivisionID  pgtype.UUID
	FirstsCount pgtype.Int4
	UserID      int32
	SeasonID    uuid.UUID
}

func (q *Queries) UpdatePlayerDivision(ctx context.Context, arg UpdatePlayerDivisionParams) error {
	_, err := q.db.Exec(ctx, updatePlayerDivision,
		arg.DivisionID,
		arg.FirstsCount,
		arg.UserID,
		arg.SeasonID,
	)
	return err
}

const updateRegistrationDivision = `-- name: UpdateRegistrationDivision :exec
UPDATE league_registrations
SET division_id = $2, firsts_count = $3, updated_at = NOW()
WHERE season_id = $1 AND user_id = $4
`

type UpdateRegistrationDivisionParams struct {
	SeasonID    uuid.UUID
	DivisionID  pgtype.UUID
	FirstsCount pgtype.Int4
	UserID      int32
}

func (q *Queries) UpdateRegistrationDivision(ctx context.Context, arg UpdateRegistrationDivisionParams) error {
	_, err := q.db.Exec(ctx, updateRegistrationDivision,
		arg.SeasonID,
		arg.DivisionID,
		arg.FirstsCount,
		arg.UserID,
	)
	return err
}

const updateSeasonStatus = `-- name: UpdateSeasonStatus :exec
UPDATE league_seasons
SET status = $2, updated_at = NOW()
WHERE uuid = $1
`

type UpdateSeasonStatusParams struct {
	Uuid   uuid.UUID
	Status int32
}

func (q *Queries) UpdateSeasonStatus(ctx context.Context, arg UpdateSeasonStatusParams) error {
	_, err := q.db.Exec(ctx, updateSeasonStatus, arg.Uuid, arg.Status)
	return err
}

const upsertStanding = `-- name: UpsertStanding :exec

INSERT INTO league_standings (division_id, user_id, rank, wins, losses, draws, spread, games_played, games_remaining, result, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
ON CONFLICT (division_id, user_id)
DO UPDATE SET
    rank = EXCLUDED.rank,
    wins = EXCLUDED.wins,
    losses = EXCLUDED.losses,
    draws = EXCLUDED.draws,
    spread = EXCLUDED.spread,
    games_played = EXCLUDED.games_played,
    games_remaining = EXCLUDED.games_remaining,
    result = EXCLUDED.result,
    updated_at = NOW()
`

type UpsertStandingParams struct {
	DivisionID     uuid.UUID
	UserID         int32
	Rank           pgtype.Int4
	Wins           pgtype.Int4
	Losses         pgtype.Int4
	Draws          pgtype.Int4
	Spread         pgtype.Int4
	GamesPlayed    pgtype.Int4
	GamesRemaining pgtype.Int4
	Result         pgtype.Int4
}

// Standings operations
func (q *Queries) UpsertStanding(ctx context.Context, arg UpsertStandingParams) error {
	_, err := q.db.Exec(ctx, upsertStanding,
		arg.DivisionID,
		arg.UserID,
		arg.Rank,
		arg.Wins,
		arg.Losses,
		arg.Draws,
		arg.Spread,
		arg.GamesPlayed,
		arg.GamesRemaining,
		arg.Result,
	)
	return err
}
