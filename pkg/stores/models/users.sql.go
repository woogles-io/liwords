// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBriefProfiles = `-- name: GetBriefProfiles :many
SELECT
    u.uuid,
    u.username,
    u.internal_bot,
    p.country_code,
    p.avatar_url,
    p.first_name,
    p.last_name,
    p.birth_date,
    (COALESCE(b.badge_codes, '{}'::text[]))::text[] AS badge_codes
FROM users u
LEFT JOIN profiles p ON u.id = p.user_id
LEFT JOIN LATERAL (
    SELECT array_agg(b.code ORDER BY b.code) AS badge_codes
    FROM user_badges ub
    JOIN badges b ON ub.badge_id = b.id
    WHERE ub.user_id = u.id
) b ON TRUE
WHERE u.uuid = ANY($1::text[])
`

type GetBriefProfilesRow struct {
	Uuid        pgtype.Text
	Username    pgtype.Text
	InternalBot pgtype.Bool
	CountryCode pgtype.Text
	AvatarUrl   pgtype.Text
	FirstName   pgtype.Text
	LastName    pgtype.Text
	BirthDate   pgtype.Text
	BadgeCodes  []string
}

func (q *Queries) GetBriefProfiles(ctx context.Context, userUuids []string) ([]GetBriefProfilesRow, error) {
	rows, err := q.db.Query(ctx, getBriefProfiles, userUuids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBriefProfilesRow
	for rows.Next() {
		var i GetBriefProfilesRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Username,
			&i.InternalBot,
			&i.CountryCode,
			&i.AvatarUrl,
			&i.FirstName,
			&i.LastName,
			&i.BirthDate,
			&i.BadgeCodes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchingEmails = `-- name: GetMatchingEmails :many
SELECT u.uuid, u.email, u.created_at, u.username, p.birth_date
FROM users u
JOIN profiles p on u.id = p.user_id
WHERE lower(u.email) LIKE $1
LIMIT 100
`

type GetMatchingEmailsRow struct {
	Uuid      pgtype.Text
	Email     pgtype.Text
	CreatedAt pgtype.Timestamptz
	Username  pgtype.Text
	BirthDate pgtype.Text
}

func (q *Queries) GetMatchingEmails(ctx context.Context, lowercasedEmailLike pgtype.Text) ([]GetMatchingEmailsRow, error) {
	rows, err := q.db.Query(ctx, getMatchingEmails, lowercasedEmailLike)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchingEmailsRow
	for rows.Next() {
		var i GetMatchingEmailsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Email,
			&i.CreatedAt,
			&i.Username,
			&i.BirthDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDetails = `-- name: GetUserDetails :one
SELECT
    u.uuid, u.email, u.created_at, u.username, p.birth_date
FROM users u
JOIN profiles p on u.id = p.user_id
WHERE lower(u.username) = $1
`

type GetUserDetailsRow struct {
	Uuid      pgtype.Text
	Email     pgtype.Text
	CreatedAt pgtype.Timestamptz
	Username  pgtype.Text
	BirthDate pgtype.Text
}

func (q *Queries) GetUserDetails(ctx context.Context, lowercasedUsername pgtype.Text) (GetUserDetailsRow, error) {
	row := q.db.QueryRow(ctx, getUserDetails, lowercasedUsername)
	var i GetUserDetailsRow
	err := row.Scan(
		&i.Uuid,
		&i.Email,
		&i.CreatedAt,
		&i.Username,
		&i.BirthDate,
	)
	return i, err
}
