// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/woogles-io/liwords/pkg/entity"
)

const createGame = `-- name: CreateGame :exec
INSERT INTO games (
    created_at, updated_at, uuid, type, player0_id, player1_id,
    ready_flag, timers, started, game_end_reason, winner_idx, loser_idx,
    quickdata, history, meta_events, stats, tournament_id, tournament_data, game_request
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11, $12,
    $13, $14, $15, $16, $17, $18, $19
)
`

type CreateGameParams struct {
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	ReadyFlag      pgtype.Int8
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	History        []byte
	MetaEvents     entity.MetaEventData
	Stats          entity.Stats
	TournamentID   pgtype.Text
	TournamentData entity.TournamentData
	GameRequest    entity.GameRequest
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) error {
	_, err := q.db.Exec(ctx, createGame,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Uuid,
		arg.Type,
		arg.Player0ID,
		arg.Player1ID,
		arg.ReadyFlag,
		arg.Timers,
		arg.Started,
		arg.GameEndReason,
		arg.WinnerIdx,
		arg.LoserIdx,
		arg.Quickdata,
		arg.History,
		arg.MetaEvents,
		arg.Stats,
		arg.TournamentID,
		arg.TournamentData,
		arg.GameRequest,
	)
	return err
}

const createRawGame = `-- name: CreateRawGame :exec
INSERT INTO games (
    uuid, history, quickdata, timers, game_end_reason, type, game_request
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type CreateRawGameParams struct {
	Uuid          pgtype.Text
	History       []byte
	Quickdata     entity.Quickdata
	Timers        entity.Timers
	GameEndReason pgtype.Int4
	Type          pgtype.Int4
	GameRequest   entity.GameRequest
}

func (q *Queries) CreateRawGame(ctx context.Context, arg CreateRawGameParams) error {
	_, err := q.db.Exec(ctx, createRawGame,
		arg.Uuid,
		arg.History,
		arg.Quickdata,
		arg.Timers,
		arg.GameEndReason,
		arg.Type,
		arg.GameRequest,
	)
	return err
}

const gameCount = `-- name: GameCount :one
SELECT COUNT(*) FROM games
`

func (q *Queries) GameCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, gameCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const gameExists = `-- name: GameExists :one
SELECT EXISTS (
    SELECT 1 FROM games WHERE uuid = $1
) AS exists
`

func (q *Queries) GameExists(ctx context.Context, uuid pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, gameExists, uuid)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getGame = `-- name: GetGame :one
SELECT id, created_at, updated_at, deleted_at, uuid, player0_id, player1_id, timers, started, game_end_reason, winner_idx, loser_idx, history, stats, quickdata, tournament_data, tournament_id, ready_flag, meta_events, type, game_request, history_in_s3 FROM games WHERE uuid = $1
`

func (q *Queries) GetGame(ctx context.Context, uuid pgtype.Text) (Game, error) {
	row := q.db.QueryRow(ctx, getGame, uuid)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Uuid,
		&i.Player0ID,
		&i.Player1ID,
		&i.Timers,
		&i.Started,
		&i.GameEndReason,
		&i.WinnerIdx,
		&i.LoserIdx,
		&i.History,
		&i.Stats,
		&i.Quickdata,
		&i.TournamentData,
		&i.TournamentID,
		&i.ReadyFlag,
		&i.MetaEvents,
		&i.Type,
		&i.GameRequest,
		&i.HistoryInS3,
	)
	return i, err
}

const getGameMetadata = `-- name: GetGameMetadata :one
SELECT
    id, uuid, type, player0_id, player1_id,
    timers, started, game_end_reason, winner_idx, loser_idx,
    quickdata, tournament_data, tournament_id,
    created_at, updated_at, game_request
FROM games
WHERE uuid = $1
`

type GetGameMetadataRow struct {
	ID             int32
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	TournamentData entity.TournamentData
	TournamentID   pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	GameRequest    entity.GameRequest
}

func (q *Queries) GetGameMetadata(ctx context.Context, uuid pgtype.Text) (GetGameMetadataRow, error) {
	row := q.db.QueryRow(ctx, getGameMetadata, uuid)
	var i GetGameMetadataRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Type,
		&i.Player0ID,
		&i.Player1ID,
		&i.Timers,
		&i.Started,
		&i.GameEndReason,
		&i.WinnerIdx,
		&i.LoserIdx,
		&i.Quickdata,
		&i.TournamentData,
		&i.TournamentID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GameRequest,
	)
	return i, err
}

const getGameOwner = `-- name: GetGameOwner :one

SELECT
    agm.creator_uuid,
    u.username
FROM annotated_game_metadata agm
JOIN users u ON agm.creator_uuid = u.uuid
WHERE agm.game_uuid = $1
`

type GetGameOwnerRow struct {
	CreatorUuid string
	Username    pgtype.Text
}

// this is not even a uuid, sigh.
func (q *Queries) GetGameOwner(ctx context.Context, gameUuid string) (GetGameOwnerRow, error) {
	row := q.db.QueryRow(ctx, getGameOwner, gameUuid)
	var i GetGameOwnerRow
	err := row.Scan(&i.CreatorUuid, &i.Username)
	return i, err
}

const getHistory = `-- name: GetHistory :one
SELECT history FROM games
WHERE uuid = $1
`

func (q *Queries) GetHistory(ctx context.Context, uuid pgtype.Text) ([]byte, error) {
	row := q.db.QueryRow(ctx, getHistory, uuid)
	var history []byte
	err := row.Scan(&history)
	return history, err
}

const getRecentGamesByUsername = `-- name: GetRecentGamesByUsername :many
WITH user_id AS (
    SELECT id FROM users WHERE lower(username) = lower($3)
)
SELECT g.id, g.uuid, g.type, g.player0_id, g.player1_id,
        g.timers, g.started, g.game_end_reason, g.winner_idx, g.loser_idx,
        g.quickdata, g.tournament_data, g.created_at, g.updated_at,
        g.game_request
FROM games g, user_id u
WHERE (g.player0_id = u.id OR g.player1_id = u.id)
AND g.game_end_reason NOT IN (0, 5, 7)
ORDER BY g.id DESC
LIMIT $2::integer
OFFSET $1::integer
`

type GetRecentGamesByUsernameParams struct {
	OffsetGames int32
	NumGames    int32
	Username    string
}

type GetRecentGamesByUsernameRow struct {
	ID             int32
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	TournamentData entity.TournamentData
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	GameRequest    entity.GameRequest
}

func (q *Queries) GetRecentGamesByUsername(ctx context.Context, arg GetRecentGamesByUsernameParams) ([]GetRecentGamesByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getRecentGamesByUsername, arg.OffsetGames, arg.NumGames, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentGamesByUsernameRow
	for rows.Next() {
		var i GetRecentGamesByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Type,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.Quickdata,
			&i.TournamentData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GameRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTourneyGames = `-- name: GetRecentTourneyGames :many
SELECT
    id, uuid, type, player0_id, player1_id,
    timers, started, game_end_reason, winner_idx, loser_idx,
    quickdata, tournament_data, created_at, updated_at, game_request
FROM games
WHERE tournament_id = $1::text
    AND game_end_reason NOT IN (0, 5, 7) -- NONE, ABORTED, CANCELLED
ORDER BY updated_at DESC
LIMIT $3::integer
OFFSET $2::integer
`

type GetRecentTourneyGamesParams struct {
	TourneyID   string
	OffsetGames int32
	NumGames    int32
}

type GetRecentTourneyGamesRow struct {
	ID             int32
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	TournamentData entity.TournamentData
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	GameRequest    entity.GameRequest
}

func (q *Queries) GetRecentTourneyGames(ctx context.Context, arg GetRecentTourneyGamesParams) ([]GetRecentTourneyGamesRow, error) {
	rows, err := q.db.Query(ctx, getRecentTourneyGames, arg.TourneyID, arg.OffsetGames, arg.NumGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentTourneyGamesRow
	for rows.Next() {
		var i GetRecentTourneyGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Type,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.Quickdata,
			&i.TournamentData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GameRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRematchStreak = `-- name: GetRematchStreak :many
SELECT uuid, winner_idx, quickdata
FROM games
WHERE quickdata->>'o' = $1::text
    AND game_end_reason NOT IN (0, 5, 7) -- NONE, ABORTED, CANCELLED
ORDER BY created_at DESC
`

type GetRematchStreakRow struct {
	Uuid      pgtype.Text
	WinnerIdx pgtype.Int4
	Quickdata entity.Quickdata
}

func (q *Queries) GetRematchStreak(ctx context.Context, originalRequestID string) ([]GetRematchStreakRow, error) {
	rows, err := q.db.Query(ctx, getRematchStreak, originalRequestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRematchStreakRow
	for rows.Next() {
		var i GetRematchStreakRow
		if err := rows.Scan(&i.Uuid, &i.WinnerIdx, &i.Quickdata); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGamePlayers = `-- name: InsertGamePlayers :exec
INSERT INTO game_players (
    game_uuid,
    player_id,
    player_index,
    score,
    won,
    game_end_reason,
    created_at,
    game_type,
    opponent_id,
    opponent_score,
    original_request_id
) VALUES
    -- Player 0
    (
        $1,
        $2,
        0,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10
    ),
    -- Player 1
    (
        $1,
        $8,
        1,
        $9,
        $11,
        $5,
        $6,
        $7,
        $2,
        $3,
        $10
    )
ON CONFLICT (game_uuid, player_id) DO NOTHING
`

type InsertGamePlayersParams struct {
	GameUuid          string
	Player0ID         int32
	Player0Score      int32
	Player0Won        pgtype.Bool
	GameEndReason     int16
	CreatedAt         pgtype.Timestamptz
	GameType          int16
	Player1ID         int32
	Player1Score      int32
	OriginalRequestID pgtype.Text
	Player1Won        pgtype.Bool
}

func (q *Queries) InsertGamePlayers(ctx context.Context, arg InsertGamePlayersParams) error {
	_, err := q.db.Exec(ctx, insertGamePlayers,
		arg.GameUuid,
		arg.Player0ID,
		arg.Player0Score,
		arg.Player0Won,
		arg.GameEndReason,
		arg.CreatedAt,
		arg.GameType,
		arg.Player1ID,
		arg.Player1Score,
		arg.OriginalRequestID,
		arg.Player1Won,
	)
	return err
}

const listActiveGames = `-- name: ListActiveGames :many
SELECT quickdata, uuid, started, tournament_data, game_request
FROM games
WHERE game_end_reason = 0 -- NONE (ongoing games)
ORDER BY id
`

type ListActiveGamesRow struct {
	Quickdata      entity.Quickdata
	Uuid           pgtype.Text
	Started        pgtype.Bool
	TournamentData entity.TournamentData
	GameRequest    entity.GameRequest
}

func (q *Queries) ListActiveGames(ctx context.Context) ([]ListActiveGamesRow, error) {
	rows, err := q.db.Query(ctx, listActiveGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveGamesRow
	for rows.Next() {
		var i ListActiveGamesRow
		if err := rows.Scan(
			&i.Quickdata,
			&i.Uuid,
			&i.Started,
			&i.TournamentData,
			&i.GameRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveTournamentGames = `-- name: ListActiveTournamentGames :many
SELECT quickdata, uuid, started, tournament_data, game_request
FROM games
WHERE game_end_reason = 0 -- NONE (ongoing games)
    AND tournament_id = $1::text
ORDER BY id
`

type ListActiveTournamentGamesRow struct {
	Quickdata      entity.Quickdata
	Uuid           pgtype.Text
	Started        pgtype.Bool
	TournamentData entity.TournamentData
	GameRequest    entity.GameRequest
}

func (q *Queries) ListActiveTournamentGames(ctx context.Context, tournamentID string) ([]ListActiveTournamentGamesRow, error) {
	rows, err := q.db.Query(ctx, listActiveTournamentGames, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveTournamentGamesRow
	for rows.Next() {
		var i ListActiveTournamentGamesRow
		if err := rows.Scan(
			&i.Quickdata,
			&i.Uuid,
			&i.Started,
			&i.TournamentData,
			&i.GameRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllIDs = `-- name: ListAllIDs :many
SELECT uuid FROM games
ORDER BY created_at ASC
`

func (q *Queries) ListAllIDs(ctx context.Context) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listAllIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var uuid pgtype.Text
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setReady = `-- name: SetReady :one
UPDATE games
SET ready_flag = ready_flag | (1 << $1::integer)
WHERE uuid = $2
    AND ready_flag & (1 << $1::integer) = 0
RETURNING ready_flag
`

type SetReadyParams struct {
	PlayerIdx int32
	Uuid      pgtype.Text
}

func (q *Queries) SetReady(ctx context.Context, arg SetReadyParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, setReady, arg.PlayerIdx, arg.Uuid)
	var ready_flag pgtype.Int8
	err := row.Scan(&ready_flag)
	return ready_flag, err
}

const updateGame = `-- name: UpdateGame :exec
UPDATE games SET
    updated_at = $1,
    player0_id = $2,
    player1_id = $3,
    timers = $4,
    started = $5,
    game_end_reason = $6,
    winner_idx = $7,
    loser_idx = $8,
    quickdata = $9,
    history = $10,
    meta_events = $11,
    stats = $12,
    tournament_data = $13,
    tournament_id = $14,
    ready_flag = $15,
    game_request = $16
WHERE uuid = $17
`

type UpdateGameParams struct {
	UpdatedAt      pgtype.Timestamptz
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	History        []byte
	MetaEvents     entity.MetaEventData
	Stats          entity.Stats
	TournamentData entity.TournamentData
	TournamentID   pgtype.Text
	ReadyFlag      pgtype.Int8
	GameRequest    entity.GameRequest
	Uuid           pgtype.Text
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) error {
	_, err := q.db.Exec(ctx, updateGame,
		arg.UpdatedAt,
		arg.Player0ID,
		arg.Player1ID,
		arg.Timers,
		arg.Started,
		arg.GameEndReason,
		arg.WinnerIdx,
		arg.LoserIdx,
		arg.Quickdata,
		arg.History,
		arg.MetaEvents,
		arg.Stats,
		arg.TournamentData,
		arg.TournamentID,
		arg.ReadyFlag,
		arg.GameRequest,
		arg.Uuid,
	)
	return err
}
