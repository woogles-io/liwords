// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/woogles-io/liwords/pkg/entity"
)

const countActiveCorrespondenceGames = `-- name: CountActiveCorrespondenceGames :one
SELECT COUNT(*)::int
FROM games
WHERE game_end_reason = 0 -- NONE (ongoing games)
    AND (game_request->>'game_mode')::int = 1
`

func (q *Queries) CountActiveCorrespondenceGames(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countActiveCorrespondenceGames)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createGame = `-- name: CreateGame :exec
INSERT INTO games (
    created_at, updated_at, uuid, type, player0_id, player1_id,
    ready_flag, timers, started, game_end_reason, winner_idx, loser_idx,
    quickdata, history, meta_events, stats, tournament_id, tournament_data, game_request, player_on_turn,
    league_id, season_id, league_division_id
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11, $12,
    $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23
)
`

type CreateGameParams struct {
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	Uuid             pgtype.Text
	Type             pgtype.Int4
	Player0ID        pgtype.Int4
	Player1ID        pgtype.Int4
	ReadyFlag        pgtype.Int8
	Timers           entity.Timers
	Started          pgtype.Bool
	GameEndReason    pgtype.Int4
	WinnerIdx        pgtype.Int4
	LoserIdx         pgtype.Int4
	Quickdata        entity.Quickdata
	History          []byte
	MetaEvents       entity.MetaEventData
	Stats            entity.Stats
	TournamentID     pgtype.Text
	TournamentData   entity.TournamentData
	GameRequest      entity.GameRequest
	PlayerOnTurn     pgtype.Int4
	LeagueID         pgtype.UUID
	SeasonID         pgtype.UUID
	LeagueDivisionID pgtype.UUID
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) error {
	_, err := q.db.Exec(ctx, createGame,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Uuid,
		arg.Type,
		arg.Player0ID,
		arg.Player1ID,
		arg.ReadyFlag,
		arg.Timers,
		arg.Started,
		arg.GameEndReason,
		arg.WinnerIdx,
		arg.LoserIdx,
		arg.Quickdata,
		arg.History,
		arg.MetaEvents,
		arg.Stats,
		arg.TournamentID,
		arg.TournamentData,
		arg.GameRequest,
		arg.PlayerOnTurn,
		arg.LeagueID,
		arg.SeasonID,
		arg.LeagueDivisionID,
	)
	return err
}

const createRawGame = `-- name: CreateRawGame :exec
INSERT INTO games (
    uuid, history, quickdata, timers, game_end_reason, type, game_request
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type CreateRawGameParams struct {
	Uuid          pgtype.Text
	History       []byte
	Quickdata     entity.Quickdata
	Timers        entity.Timers
	GameEndReason pgtype.Int4
	Type          pgtype.Int4
	GameRequest   entity.GameRequest
}

func (q *Queries) CreateRawGame(ctx context.Context, arg CreateRawGameParams) error {
	_, err := q.db.Exec(ctx, createRawGame,
		arg.Uuid,
		arg.History,
		arg.Quickdata,
		arg.Timers,
		arg.GameEndReason,
		arg.Type,
		arg.GameRequest,
	)
	return err
}

const gameCount = `-- name: GameCount :one
SELECT COUNT(*) FROM games
`

func (q *Queries) GameCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, gameCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const gameExists = `-- name: GameExists :one
SELECT EXISTS (
    SELECT 1 FROM games WHERE uuid = $1
) AS exists
`

func (q *Queries) GameExists(ctx context.Context, uuid pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, gameExists, uuid)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getGame = `-- name: GetGame :one
SELECT id, created_at, updated_at, deleted_at, uuid, player0_id, player1_id, timers, started, game_end_reason, winner_idx, loser_idx, history, stats, quickdata, tournament_data, tournament_id, ready_flag, meta_events, type, game_request, history_in_s3, player_on_turn, league_id, season_id, league_division_id FROM games WHERE uuid = $1
`

func (q *Queries) GetGame(ctx context.Context, uuid pgtype.Text) (Game, error) {
	row := q.db.QueryRow(ctx, getGame, uuid)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Uuid,
		&i.Player0ID,
		&i.Player1ID,
		&i.Timers,
		&i.Started,
		&i.GameEndReason,
		&i.WinnerIdx,
		&i.LoserIdx,
		&i.History,
		&i.Stats,
		&i.Quickdata,
		&i.TournamentData,
		&i.TournamentID,
		&i.ReadyFlag,
		&i.MetaEvents,
		&i.Type,
		&i.GameRequest,
		&i.HistoryInS3,
		&i.PlayerOnTurn,
		&i.LeagueID,
		&i.SeasonID,
		&i.LeagueDivisionID,
	)
	return i, err
}

const getGameMetadata = `-- name: GetGameMetadata :one
SELECT
    id, uuid, type, player0_id, player1_id,
    timers, started, game_end_reason, winner_idx, loser_idx,
    quickdata, tournament_data, tournament_id,
    created_at, updated_at, game_request
FROM games
WHERE uuid = $1
`

type GetGameMetadataRow struct {
	ID             int32
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	TournamentData entity.TournamentData
	TournamentID   pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	GameRequest    entity.GameRequest
}

func (q *Queries) GetGameMetadata(ctx context.Context, uuid pgtype.Text) (GetGameMetadataRow, error) {
	row := q.db.QueryRow(ctx, getGameMetadata, uuid)
	var i GetGameMetadataRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Type,
		&i.Player0ID,
		&i.Player1ID,
		&i.Timers,
		&i.Started,
		&i.GameEndReason,
		&i.WinnerIdx,
		&i.LoserIdx,
		&i.Quickdata,
		&i.TournamentData,
		&i.TournamentID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GameRequest,
	)
	return i, err
}

const getGameOwner = `-- name: GetGameOwner :one

SELECT
    agm.creator_uuid,
    u.username
FROM annotated_game_metadata agm
JOIN users u ON agm.creator_uuid = u.uuid
WHERE agm.game_uuid = $1
`

type GetGameOwnerRow struct {
	CreatorUuid string
	Username    pgtype.Text
}

// this is not even a uuid, sigh.
func (q *Queries) GetGameOwner(ctx context.Context, gameUuid string) (GetGameOwnerRow, error) {
	row := q.db.QueryRow(ctx, getGameOwner, gameUuid)
	var i GetGameOwnerRow
	err := row.Scan(&i.CreatorUuid, &i.Username)
	return i, err
}

const getHistory = `-- name: GetHistory :one
SELECT history FROM games
WHERE uuid = $1
`

func (q *Queries) GetHistory(ctx context.Context, uuid pgtype.Text) ([]byte, error) {
	row := q.db.QueryRow(ctx, getHistory, uuid)
	var history []byte
	err := row.Scan(&history)
	return history, err
}

const getRecentCorrespondenceGamesByUsername = `-- name: GetRecentCorrespondenceGamesByUsername :many
WITH recent_game_uuids AS (
  SELECT gp.game_uuid, gp.created_at
  FROM game_players gp
  JOIN games g ON gp.game_uuid = g.uuid
  WHERE gp.player_id = (SELECT id FROM users WHERE lower(username) = lower($1))
    AND gp.game_end_reason NOT IN (0, 5, 7)  -- NONE, ABORTED, CANCELLED
    AND (g.game_request->>'game_mode')::int = 1  -- CORRESPONDENCE only
  ORDER BY gp.created_at DESC
  LIMIT $2::integer
)
SELECT g.id, g.uuid, g.type, g.player0_id, g.player1_id,
       g.timers, g.started, g.game_end_reason, g.winner_idx, g.loser_idx,
       g.quickdata, g.tournament_data, g.created_at, g.updated_at,
       g.game_request
FROM recent_game_uuids rgu
JOIN games g ON rgu.game_uuid = g.uuid
ORDER BY rgu.created_at DESC
`

type GetRecentCorrespondenceGamesByUsernameParams struct {
	Username string
	NumGames int32
}

type GetRecentCorrespondenceGamesByUsernameRow struct {
	ID             int32
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	TournamentData entity.TournamentData
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	GameRequest    entity.GameRequest
}

func (q *Queries) GetRecentCorrespondenceGamesByUsername(ctx context.Context, arg GetRecentCorrespondenceGamesByUsernameParams) ([]GetRecentCorrespondenceGamesByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getRecentCorrespondenceGamesByUsername, arg.Username, arg.NumGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentCorrespondenceGamesByUsernameRow
	for rows.Next() {
		var i GetRecentCorrespondenceGamesByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Type,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.Quickdata,
			&i.TournamentData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GameRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentGamesByPlayerID = `-- name: GetRecentGamesByPlayerID :many
WITH recent_game_uuids AS (
  SELECT gp.game_uuid, gp.created_at
  FROM game_players gp
  WHERE gp.player_id = $1::integer
    AND gp.game_end_reason NOT IN (0, 5, 7)  -- NONE, ABORTED, CANCELLED
  ORDER BY gp.created_at DESC
  LIMIT $3::integer
  OFFSET $2::integer
)
SELECT g.id, g.uuid, g.type, g.player0_id, g.player1_id,
       g.timers, g.started, g.game_end_reason, g.winner_idx, g.loser_idx,
       g.quickdata, g.tournament_data, g.created_at, g.updated_at,
       g.game_request
FROM recent_game_uuids rgu
JOIN games g ON rgu.game_uuid = g.uuid
ORDER BY rgu.created_at DESC
`

type GetRecentGamesByPlayerIDParams struct {
	PlayerID    int32
	OffsetGames int32
	NumGames    int32
}

type GetRecentGamesByPlayerIDRow struct {
	ID             int32
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	TournamentData entity.TournamentData
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	GameRequest    entity.GameRequest
}

func (q *Queries) GetRecentGamesByPlayerID(ctx context.Context, arg GetRecentGamesByPlayerIDParams) ([]GetRecentGamesByPlayerIDRow, error) {
	rows, err := q.db.Query(ctx, getRecentGamesByPlayerID, arg.PlayerID, arg.OffsetGames, arg.NumGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentGamesByPlayerIDRow
	for rows.Next() {
		var i GetRecentGamesByPlayerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Type,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.Quickdata,
			&i.TournamentData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GameRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentGamesByUsername = `-- name: GetRecentGamesByUsername :many
WITH recent_game_uuids AS (
  SELECT gp.game_uuid, gp.created_at
  FROM game_players gp
  WHERE gp.player_id = (SELECT id FROM users WHERE lower(username) = lower($1))
    AND gp.game_end_reason NOT IN (0, 5, 7)  -- NONE, ABORTED, CANCELLED
  ORDER BY gp.created_at DESC
  LIMIT $3::integer
  OFFSET $2::integer
)
SELECT g.id, g.uuid, g.type, g.player0_id, g.player1_id,
       g.timers, g.started, g.game_end_reason, g.winner_idx, g.loser_idx,
       g.quickdata, g.tournament_data, g.created_at, g.updated_at,
       g.game_request
FROM recent_game_uuids rgu
JOIN games g ON rgu.game_uuid = g.uuid
ORDER BY rgu.created_at DESC
`

type GetRecentGamesByUsernameParams struct {
	Username    string
	OffsetGames int32
	NumGames    int32
}

type GetRecentGamesByUsernameRow struct {
	ID             int32
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	TournamentData entity.TournamentData
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	GameRequest    entity.GameRequest
}

func (q *Queries) GetRecentGamesByUsername(ctx context.Context, arg GetRecentGamesByUsernameParams) ([]GetRecentGamesByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getRecentGamesByUsername, arg.Username, arg.OffsetGames, arg.NumGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentGamesByUsernameRow
	for rows.Next() {
		var i GetRecentGamesByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Type,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.Quickdata,
			&i.TournamentData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GameRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentGamesByUsernameOptimized = `-- name: GetRecentGamesByUsernameOptimized :many
WITH recent_game_uuids AS (
  SELECT gp.game_uuid, gp.created_at
  FROM game_players gp
  WHERE gp.player_id = (SELECT id FROM users WHERE lower(username) = lower($1))
    AND gp.game_end_reason NOT IN (0, 5, 7)  -- NONE, ABORTED, CANCELLED
  ORDER BY gp.created_at DESC
  LIMIT $3::integer
  OFFSET $2::integer
)
SELECT g.id, g.uuid, g.type, g.player0_id, g.player1_id,
       g.timers, g.started, g.game_end_reason, g.winner_idx, g.loser_idx,
       g.quickdata, g.tournament_data, g.created_at, g.updated_at,
       g.game_request
FROM recent_game_uuids rgu
JOIN games g ON rgu.game_uuid = g.uuid
ORDER BY rgu.created_at DESC
`

type GetRecentGamesByUsernameOptimizedParams struct {
	Username    string
	OffsetGames int32
	NumGames    int32
}

type GetRecentGamesByUsernameOptimizedRow struct {
	ID             int32
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	TournamentData entity.TournamentData
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	GameRequest    entity.GameRequest
}

func (q *Queries) GetRecentGamesByUsernameOptimized(ctx context.Context, arg GetRecentGamesByUsernameOptimizedParams) ([]GetRecentGamesByUsernameOptimizedRow, error) {
	rows, err := q.db.Query(ctx, getRecentGamesByUsernameOptimized, arg.Username, arg.OffsetGames, arg.NumGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentGamesByUsernameOptimizedRow
	for rows.Next() {
		var i GetRecentGamesByUsernameOptimizedRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Type,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.Quickdata,
			&i.TournamentData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GameRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTourneyGames = `-- name: GetRecentTourneyGames :many
SELECT
    id, uuid, type, player0_id, player1_id,
    timers, started, game_end_reason, winner_idx, loser_idx,
    quickdata, tournament_data, created_at, updated_at, game_request
FROM games
WHERE tournament_id = $1::text
    AND game_end_reason NOT IN (0, 5, 7) -- NONE, ABORTED, CANCELLED
ORDER BY updated_at DESC
LIMIT $3::integer
OFFSET $2::integer
`

type GetRecentTourneyGamesParams struct {
	TourneyID   string
	OffsetGames int32
	NumGames    int32
}

type GetRecentTourneyGamesRow struct {
	ID             int32
	Uuid           pgtype.Text
	Type           pgtype.Int4
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	TournamentData entity.TournamentData
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	GameRequest    entity.GameRequest
}

func (q *Queries) GetRecentTourneyGames(ctx context.Context, arg GetRecentTourneyGamesParams) ([]GetRecentTourneyGamesRow, error) {
	rows, err := q.db.Query(ctx, getRecentTourneyGames, arg.TourneyID, arg.OffsetGames, arg.NumGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentTourneyGamesRow
	for rows.Next() {
		var i GetRecentTourneyGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Type,
			&i.Player0ID,
			&i.Player1ID,
			&i.Timers,
			&i.Started,
			&i.GameEndReason,
			&i.WinnerIdx,
			&i.LoserIdx,
			&i.Quickdata,
			&i.TournamentData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GameRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRematchStreak = `-- name: GetRematchStreak :many
SELECT g.uuid, g.winner_idx, g.quickdata
FROM games g
WHERE g.uuid IN (
  SELECT DISTINCT gp.game_uuid
  FROM game_players gp
  WHERE gp.original_request_id = $1::text
    AND gp.game_end_reason NOT IN (0, 5, 7) -- NONE, ABORTED, CANCELLED
)
ORDER BY g.created_at DESC
`

type GetRematchStreakRow struct {
	Uuid      pgtype.Text
	WinnerIdx pgtype.Int4
	Quickdata entity.Quickdata
}

func (q *Queries) GetRematchStreak(ctx context.Context, originalRequestID string) ([]GetRematchStreakRow, error) {
	rows, err := q.db.Query(ctx, getRematchStreak, originalRequestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRematchStreakRow
	for rows.Next() {
		var i GetRematchStreakRow
		if err := rows.Scan(&i.Uuid, &i.WinnerIdx, &i.Quickdata); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGamePlayers = `-- name: InsertGamePlayers :exec
INSERT INTO game_players (
    game_uuid,
    player_id,
    player_index,
    score,
    won,
    game_end_reason,
    created_at,
    game_type,
    opponent_id,
    opponent_score,
    original_request_id
) VALUES
    -- Player 0
    (
        $1,
        $2,
        0,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10
    ),
    -- Player 1
    (
        $1,
        $8,
        1,
        $9,
        $11,
        $5,
        $6,
        $7,
        $2,
        $3,
        $10
    )
ON CONFLICT (game_uuid, player_id) DO NOTHING
`

type InsertGamePlayersParams struct {
	GameUuid          string
	Player0ID         int32
	Player0Score      int32
	Player0Won        pgtype.Bool
	GameEndReason     int16
	CreatedAt         pgtype.Timestamptz
	GameType          int16
	Player1ID         int32
	Player1Score      int32
	OriginalRequestID pgtype.Text
	Player1Won        pgtype.Bool
}

func (q *Queries) InsertGamePlayers(ctx context.Context, arg InsertGamePlayersParams) error {
	_, err := q.db.Exec(ctx, insertGamePlayers,
		arg.GameUuid,
		arg.Player0ID,
		arg.Player0Score,
		arg.Player0Won,
		arg.GameEndReason,
		arg.CreatedAt,
		arg.GameType,
		arg.Player1ID,
		arg.Player1Score,
		arg.OriginalRequestID,
		arg.Player1Won,
	)
	return err
}

const listActiveCorrespondenceGames = `-- name: ListActiveCorrespondenceGames :many
SELECT quickdata, uuid, started, tournament_data, game_request, player_on_turn, timers, type, updated_at
FROM games
WHERE game_end_reason = 0 -- NONE (ongoing games)
    AND (game_request->>'game_mode')::int = 1 -- Only CORRESPONDENCE games
ORDER BY id
`

type ListActiveCorrespondenceGamesRow struct {
	Quickdata      entity.Quickdata
	Uuid           pgtype.Text
	Started        pgtype.Bool
	TournamentData entity.TournamentData
	GameRequest    entity.GameRequest
	PlayerOnTurn   pgtype.Int4
	Timers         entity.Timers
	Type           pgtype.Int4
	UpdatedAt      pgtype.Timestamptz
}

func (q *Queries) ListActiveCorrespondenceGames(ctx context.Context) ([]ListActiveCorrespondenceGamesRow, error) {
	rows, err := q.db.Query(ctx, listActiveCorrespondenceGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveCorrespondenceGamesRow
	for rows.Next() {
		var i ListActiveCorrespondenceGamesRow
		if err := rows.Scan(
			&i.Quickdata,
			&i.Uuid,
			&i.Started,
			&i.TournamentData,
			&i.GameRequest,
			&i.PlayerOnTurn,
			&i.Timers,
			&i.Type,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveCorrespondenceGamesForUser = `-- name: ListActiveCorrespondenceGamesForUser :many
SELECT quickdata, uuid, started, tournament_data, game_request, player_on_turn, updated_at
FROM games
WHERE game_end_reason = 0 -- NONE (ongoing games)
    AND (game_request->>'game_mode')::int = 1 -- Only CORRESPONDENCE games
    AND (
        player0_id = (SELECT id FROM users WHERE uuid = $1::text)
        OR player1_id = (SELECT id FROM users WHERE uuid = $1::text)
    )
ORDER BY id
`

type ListActiveCorrespondenceGamesForUserRow struct {
	Quickdata      entity.Quickdata
	Uuid           pgtype.Text
	Started        pgtype.Bool
	TournamentData entity.TournamentData
	GameRequest    entity.GameRequest
	PlayerOnTurn   pgtype.Int4
	UpdatedAt      pgtype.Timestamptz
}

func (q *Queries) ListActiveCorrespondenceGamesForUser(ctx context.Context, userUuid string) ([]ListActiveCorrespondenceGamesForUserRow, error) {
	rows, err := q.db.Query(ctx, listActiveCorrespondenceGamesForUser, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveCorrespondenceGamesForUserRow
	for rows.Next() {
		var i ListActiveCorrespondenceGamesForUserRow
		if err := rows.Scan(
			&i.Quickdata,
			&i.Uuid,
			&i.Started,
			&i.TournamentData,
			&i.GameRequest,
			&i.PlayerOnTurn,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveCorrespondenceGamesWithBotOnTurn = `-- name: ListActiveCorrespondenceGamesWithBotOnTurn :many

SELECT g.uuid
FROM games g
WHERE g.game_end_reason = 0 -- NONE (ongoing games)
    AND (g.game_request->>'game_mode')::int = 1 -- Only CORRESPONDENCE games
    AND g.player_on_turn IS NOT NULL
    AND (
        (g.player_on_turn = 0 AND EXISTS (
            SELECT 1 FROM users u WHERE u.id = g.player0_id AND u.internal_bot = true AND lower(u.username) != 'bestbot'
        ))
        OR
        (g.player_on_turn = 1 AND EXISTS (
            SELECT 1 FROM users u WHERE u.id = g.player1_id AND u.internal_bot = true AND lower(u.username) != 'bestbot'
        ))
    )
ORDER BY g.id
`

// Only CORRESPONDENCE games
func (q *Queries) ListActiveCorrespondenceGamesWithBotOnTurn(ctx context.Context) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listActiveCorrespondenceGamesWithBotOnTurn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var uuid pgtype.Text
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveGames = `-- name: ListActiveGames :many
SELECT quickdata, uuid, started, tournament_data, game_request, player_on_turn
FROM games
WHERE game_end_reason = 0 -- NONE (ongoing games)
    AND COALESCE((game_request->>'game_mode')::int, 0) != 1 -- Exclude CORRESPONDENCE games
ORDER BY id
`

type ListActiveGamesRow struct {
	Quickdata      entity.Quickdata
	Uuid           pgtype.Text
	Started        pgtype.Bool
	TournamentData entity.TournamentData
	GameRequest    entity.GameRequest
	PlayerOnTurn   pgtype.Int4
}

func (q *Queries) ListActiveGames(ctx context.Context) ([]ListActiveGamesRow, error) {
	rows, err := q.db.Query(ctx, listActiveGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveGamesRow
	for rows.Next() {
		var i ListActiveGamesRow
		if err := rows.Scan(
			&i.Quickdata,
			&i.Uuid,
			&i.Started,
			&i.TournamentData,
			&i.GameRequest,
			&i.PlayerOnTurn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveRealtimeGamesWithBotOnTurn = `-- name: ListActiveRealtimeGamesWithBotOnTurn :many
SELECT g.uuid
FROM games g
WHERE g.game_end_reason = 0 -- NONE (ongoing games)
    AND COALESCE((g.game_request->>'game_mode')::int, 0) != 1 -- Exclude CORRESPONDENCE games
    AND g.player_on_turn IS NOT NULL
    AND (
        (g.player_on_turn = 0 AND EXISTS (
            SELECT 1 FROM users u WHERE u.id = g.player0_id AND u.internal_bot = true AND lower(u.username) != 'bestbot'
        ))
        OR
        (g.player_on_turn = 1 AND EXISTS (
            SELECT 1 FROM users u WHERE u.id = g.player1_id AND u.internal_bot = true AND lower(u.username) != 'bestbot'
        ))
    )
ORDER BY g.id
`

func (q *Queries) ListActiveRealtimeGamesWithBotOnTurn(ctx context.Context) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listActiveRealtimeGamesWithBotOnTurn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var uuid pgtype.Text
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveTournamentGames = `-- name: ListActiveTournamentGames :many
SELECT quickdata, uuid, started, tournament_data, game_request, player_on_turn
FROM games
WHERE game_end_reason = 0 -- NONE (ongoing games)
    AND tournament_id = $1::text
    AND COALESCE((game_request->>'game_mode')::int, 0) != 1 -- Exclude CORRESPONDENCE games
ORDER BY id
`

type ListActiveTournamentGamesRow struct {
	Quickdata      entity.Quickdata
	Uuid           pgtype.Text
	Started        pgtype.Bool
	TournamentData entity.TournamentData
	GameRequest    entity.GameRequest
	PlayerOnTurn   pgtype.Int4
}

func (q *Queries) ListActiveTournamentGames(ctx context.Context, tournamentID string) ([]ListActiveTournamentGamesRow, error) {
	rows, err := q.db.Query(ctx, listActiveTournamentGames, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveTournamentGamesRow
	for rows.Next() {
		var i ListActiveTournamentGamesRow
		if err := rows.Scan(
			&i.Quickdata,
			&i.Uuid,
			&i.Started,
			&i.TournamentData,
			&i.GameRequest,
			&i.PlayerOnTurn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllIDs = `-- name: ListAllIDs :many
SELECT uuid FROM games
ORDER BY created_at ASC
`

func (q *Queries) ListAllIDs(ctx context.Context) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listAllIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var uuid pgtype.Text
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setReady = `-- name: SetReady :one
UPDATE games
SET ready_flag = ready_flag | (1 << $1::integer)
WHERE uuid = $2
    AND ready_flag & (1 << $1::integer) = 0
RETURNING ready_flag
`

type SetReadyParams struct {
	PlayerIdx int32
	Uuid      pgtype.Text
}

func (q *Queries) SetReady(ctx context.Context, arg SetReadyParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, setReady, arg.PlayerIdx, arg.Uuid)
	var ready_flag pgtype.Int8
	err := row.Scan(&ready_flag)
	return ready_flag, err
}

const updateGame = `-- name: UpdateGame :exec
UPDATE games SET
    updated_at = $1,
    player0_id = $2,
    player1_id = $3,
    timers = $4,
    started = $5,
    game_end_reason = $6,
    winner_idx = $7,
    loser_idx = $8,
    quickdata = $9,
    history = $10,
    meta_events = $11,
    stats = $12,
    tournament_data = $13,
    tournament_id = $14,
    ready_flag = $15,
    game_request = $16,
    player_on_turn = $17
WHERE uuid = $18
`

type UpdateGameParams struct {
	UpdatedAt      pgtype.Timestamptz
	Player0ID      pgtype.Int4
	Player1ID      pgtype.Int4
	Timers         entity.Timers
	Started        pgtype.Bool
	GameEndReason  pgtype.Int4
	WinnerIdx      pgtype.Int4
	LoserIdx       pgtype.Int4
	Quickdata      entity.Quickdata
	History        []byte
	MetaEvents     entity.MetaEventData
	Stats          entity.Stats
	TournamentData entity.TournamentData
	TournamentID   pgtype.Text
	ReadyFlag      pgtype.Int8
	GameRequest    entity.GameRequest
	PlayerOnTurn   pgtype.Int4
	Uuid           pgtype.Text
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) error {
	_, err := q.db.Exec(ctx, updateGame,
		arg.UpdatedAt,
		arg.Player0ID,
		arg.Player1ID,
		arg.Timers,
		arg.Started,
		arg.GameEndReason,
		arg.WinnerIdx,
		arg.LoserIdx,
		arg.Quickdata,
		arg.History,
		arg.MetaEvents,
		arg.Stats,
		arg.TournamentData,
		arg.TournamentID,
		arg.ReadyFlag,
		arg.GameRequest,
		arg.PlayerOnTurn,
		arg.Uuid,
	)
	return err
}
