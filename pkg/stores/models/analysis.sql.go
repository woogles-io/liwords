// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analysis.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const claimNextJob = `-- name: ClaimNextJob :one
UPDATE analysis_jobs
SET
    status = 'claimed',
    claimed_by_user_uuid = $1,
    claimed_at = NOW(),
    heartbeat_at = NOW()
WHERE id = (
    SELECT id
    FROM analysis_jobs
    WHERE status = 'pending'
    ORDER BY priority DESC, created_at ASC
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING id, game_id, config_json
`

type ClaimNextJobRow struct {
	ID         uuid.UUID
	GameID     string
	ConfigJson []byte
}

// Claims the next available job atomically using FOR UPDATE SKIP LOCKED
func (q *Queries) ClaimNextJob(ctx context.Context, claimedByUserUuid pgtype.Text) (ClaimNextJobRow, error) {
	row := q.db.QueryRow(ctx, claimNextJob, claimedByUserUuid)
	var i ClaimNextJobRow
	err := row.Scan(&i.ID, &i.GameID, &i.ConfigJson)
	return i, err
}

const completeJob = `-- name: CompleteJob :one
UPDATE analysis_jobs
SET
    status = 'completed',
    result_proto = $1,
    completed_at = NOW()
WHERE id = $2 AND claimed_by_user_uuid = $3 AND status IN ('claimed', 'processing')
RETURNING EXTRACT(EPOCH FROM (NOW() - claimed_at))::BIGINT * 1000 as duration_ms
`

type CompleteJobParams struct {
	ResultProto       []byte
	ID                uuid.UUID
	ClaimedByUserUuid pgtype.Text
}

// Marks job as completed and returns processing duration
func (q *Queries) CompleteJob(ctx context.Context, arg CompleteJobParams) (int32, error) {
	row := q.db.QueryRow(ctx, completeJob, arg.ResultProto, arg.ID, arg.ClaimedByUserUuid)
	var duration_ms int32
	err := row.Scan(&duration_ms)
	return duration_ms, err
}

const createAnalysisJob = `-- name: CreateAnalysisJob :one
INSERT INTO analysis_jobs (game_id, config_json, priority)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateAnalysisJobParams struct {
	GameID     string
	ConfigJson []byte
	Priority   pgtype.Int4
}

// Create a new analysis job
func (q *Queries) CreateAnalysisJob(ctx context.Context, arg CreateAnalysisJobParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createAnalysisJob, arg.GameID, arg.ConfigJson, arg.Priority)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const failJob = `-- name: FailJob :exec
UPDATE analysis_jobs
SET
    status = 'failed',
    error_message = $1,
    completed_at = NOW()
WHERE id = $2 AND claimed_by_user_uuid = $3
`

type FailJobParams struct {
	ErrorMessage      pgtype.Text
	ID                uuid.UUID
	ClaimedByUserUuid pgtype.Text
}

// Marks job as failed with error message
func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) error {
	_, err := q.db.Exec(ctx, failJob, arg.ErrorMessage, arg.ID, arg.ClaimedByUserUuid)
	return err
}

const getJobByGameID = `-- name: GetJobByGameID :one
SELECT id, status, result_proto, error_message, completed_at, created_at
FROM analysis_jobs
WHERE game_id = $1
ORDER BY created_at DESC
LIMIT 1
`

type GetJobByGameIDRow struct {
	ID           uuid.UUID
	Status       string
	ResultProto  []byte
	ErrorMessage pgtype.Text
	CompletedAt  pgtype.Timestamptz
	CreatedAt    pgtype.Timestamptz
}

// Get most recent job for a game
func (q *Queries) GetJobByGameID(ctx context.Context, gameID string) (GetJobByGameIDRow, error) {
	row := q.db.QueryRow(ctx, getJobByGameID, gameID)
	var i GetJobByGameIDRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ResultProto,
		&i.ErrorMessage,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserJobCount = `-- name: GetUserJobCount :one
SELECT COUNT(*) as total_jobs
FROM analysis_jobs
WHERE claimed_by_user_uuid = $1 AND completed_at IS NOT NULL
`

// Get count of jobs completed by a user
func (q *Queries) GetUserJobCount(ctx context.Context, claimedByUserUuid pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getUserJobCount, claimedByUserUuid)
	var total_jobs int64
	err := row.Scan(&total_jobs)
	return total_jobs, err
}

const reclaimStaleJobs = `-- name: ReclaimStaleJobs :exec
UPDATE analysis_jobs
SET
    status = CASE
        WHEN retry_count >= max_retries THEN 'failed'
        ELSE 'pending'
    END,
    claimed_by_user_uuid = NULL,
    retry_count = retry_count + 1,
    error_message = CASE
        WHEN retry_count >= max_retries THEN 'Max retries - worker timeout'
        ELSE NULL
    END
WHERE status IN ('claimed', 'processing')
  AND heartbeat_at < NOW() - INTERVAL '2 minutes'
`

// Reclaim jobs that haven't sent heartbeat in timeout period
func (q *Queries) ReclaimStaleJobs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, reclaimStaleJobs)
	return err
}

const updateHeartbeat = `-- name: UpdateHeartbeat :exec
UPDATE analysis_jobs
SET
    heartbeat_at = NOW(),
    status = CASE
        WHEN status = 'claimed' THEN 'processing'
        ELSE status
    END
WHERE id = $1 AND claimed_by_user_uuid = $2
`

type UpdateHeartbeatParams struct {
	ID                uuid.UUID
	ClaimedByUserUuid pgtype.Text
}

// Updates heartbeat timestamp and transitions to processing state
func (q *Queries) UpdateHeartbeat(ctx context.Context, arg UpdateHeartbeatParams) error {
	_, err := q.db.Exec(ctx, updateHeartbeat, arg.ID, arg.ClaimedByUserUuid)
	return err
}
