// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: stats.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTourneyStat = `-- name: AddTourneyStat :exec
insert into tournament_stats(tournament_id, division_name, player_id, stats)
select t.id, $2, $3, $4
from tournaments t
where t.uuid = $1
on conflict (tournament_id, division_name, player_id)
do update set stats = EXCLUDED.stats
`

type AddTourneyStatParams struct {
	Uuid         pgtype.Text
	DivisionName string
	PlayerID     string
	Stats        []byte
}

func (q *Queries) AddTourneyStat(ctx context.Context, arg AddTourneyStatParams) error {
	_, err := q.db.Exec(ctx, addTourneyStat,
		arg.Uuid,
		arg.DivisionName,
		arg.PlayerID,
		arg.Stats,
	)
	return err
}

const getHeadToHead = `-- name: GetHeadToHead :one
with
  affected_games as (
    select games.id, games.created_at, games.updated_at, games.deleted_at, games.uuid, games.player0_id, games.player1_id, games.timers, games.started, games.game_end_reason, games.winner_idx, games.loser_idx, games.request, games.history, games.stats, games.quickdata, games.tournament_data, games.tournament_id, games.ready_flag, games.meta_events, games.type
    from games
    inner join users u1 on u1.uuid = $3::text
    inner join users u2 on u2.uuid = $4::text
    where
      (games.player0_id = u1.id and games.player1_id = u2.id) or
      (games.player0_id = u2.id and games.player1_id = u1.id)
    order by games.created_at desc
    limit $1
    offset $2
  ),
  t as (
    select
      stats->>'i1' user_uuid,
      (d1."Wins"->>'t')::int wins,
      (d1."Losses"->>'t')::int losses,
      (d1."Draws"->>'t')::int draws,
      (d1."Bingos"->>'t')::int bingos,
      (d1."Tiles Played"->>'t')::int tiles_played,
      (d1."Tiles Played"->'s'->>'?')::int blanks_played,
      (d1."Score"->>'t')::int - (stats->'d2'->'Score'->>'t')::int score_difference
    from affected_games,
      jsonb_to_record(stats->'d1') d1("Wins" jsonb, "Losses" jsonb, "Draws" jsonb, "Bingos" jsonb, "Tiles Played" jsonb, "Score" jsonb)
  union all
    select
      stats->>'i2' user_uuid,
      (d2."Wins"->>'t')::int wins,
      (d2."Losses"->>'t')::int losses,
      (d2."Draws"->>'t')::int draws,
      (d2."Bingos"->>'t')::int bingos,
      (d2."Tiles Played"->>'t')::int tiles_played,
      (d2."Tiles Played"->'s'->>'?')::int blanks_played,
      (d2."Score"->>'t')::int - (stats->'d1'->'Score'->>'t')::int score_difference
    from affected_games,
      jsonb_to_record(stats->'d2') d2("Wins" jsonb, "Losses" jsonb, "Draws" jsonb, "Bingos" jsonb, "Tiles Played" jsonb, "Score" jsonb)
  )
  select
    user_uuid::text,
    sum(wins) wins,
    sum(losses) losses,
    sum(draws) draws,
    sum(bingos) bingos,
    sum(tiles_played) tiles_played,
    sum(blanks_played) blanks_played,
    sum(score_difference) spread
  from t
  group by user_uuid
  order by user_uuid
`

type GetHeadToHeadParams struct {
	Limit  int32
	Offset int32
	U1Uuid string
	U2Uuid string
}

type GetHeadToHeadRow struct {
	UserUuid     string
	Wins         int64
	Losses       int64
	Draws        int64
	Bingos       int64
	TilesPlayed  int64
	BlanksPlayed int64
	Spread       int64
}

func (q *Queries) GetHeadToHead(ctx context.Context, arg GetHeadToHeadParams) (GetHeadToHeadRow, error) {
	row := q.db.QueryRow(ctx, getHeadToHead,
		arg.Limit,
		arg.Offset,
		arg.U1Uuid,
		arg.U2Uuid,
	)
	var i GetHeadToHeadRow
	err := row.Scan(
		&i.UserUuid,
		&i.Wins,
		&i.Losses,
		&i.Draws,
		&i.Bingos,
		&i.TilesPlayed,
		&i.BlanksPlayed,
		&i.Spread,
	)
	return i, err
}

const getHighestTurnsFromGameUUIDs = `-- name: GetHighestTurnsFromGameUUIDs :many
select user_uuid::text, max(high_turn)::int high_turn
from
  (
    select stats->>'i1' user_uuid, (stats->'d1'->'High Turn'->>'t')::int high_turn
    from games
    where uuid = ANY ($1::text[])
  union all
    select stats->>'i2' user_uuid, (stats->'d2'->'High Turn'->>'t')::int high_turn
    from games
    where uuid = ANY ($1::text[])
  ) t
group by user_uuid
order by high_turn desc
`

type GetHighestTurnsFromGameUUIDsRow struct {
	UserUuid string
	HighTurn int32
}

func (q *Queries) GetHighestTurnsFromGameUUIDs(ctx context.Context, dollar_1 []string) ([]GetHighestTurnsFromGameUUIDsRow, error) {
	rows, err := q.db.Query(ctx, getHighestTurnsFromGameUUIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHighestTurnsFromGameUUIDsRow
	for rows.Next() {
		var i GetHighestTurnsFromGameUUIDsRow
		if err := rows.Scan(&i.UserUuid, &i.HighTurn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalBingosFromGameUUIDs = `-- name: GetTotalBingosFromGameUUIDs :many
select user_uuid::text, sum(bingos)::int total_bingos
from
  (
    select stats->>'i1' user_uuid, (stats->'d1'->'Bingos'->>'t')::int bingos
    from games
    where uuid = ANY ($1::text[])
  union all
    select stats->>'i2' user_uuid, (stats->'d2'->'Bingos'->>'t')::int bingos
    from games
    where uuid = ANY ($1::text[])
  ) t
group by user_uuid
order by total_bingos desc
`

type GetTotalBingosFromGameUUIDsRow struct {
	UserUuid    string
	TotalBingos int32
}

func (q *Queries) GetTotalBingosFromGameUUIDs(ctx context.Context, dollar_1 []string) ([]GetTotalBingosFromGameUUIDsRow, error) {
	rows, err := q.db.Query(ctx, getTotalBingosFromGameUUIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalBingosFromGameUUIDsRow
	for rows.Next() {
		var i GetTotalBingosFromGameUUIDsRow
		if err := rows.Scan(&i.UserUuid, &i.TotalBingos); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTourneyStatsForPlayer = `-- name: GetTourneyStatsForPlayer :one
select ts.stats
from tournament_stats ts
join tournaments t on ts.tournament_id = t.id
where t.uuid = $1 and ts.division_name = $2 and ts.player_id = $3
`

type GetTourneyStatsForPlayerParams struct {
	Uuid         pgtype.Text
	DivisionName string
	PlayerID     string
}

func (q *Queries) GetTourneyStatsForPlayer(ctx context.Context, arg GetTourneyStatsForPlayerParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getTourneyStatsForPlayer, arg.Uuid, arg.DivisionName, arg.PlayerID)
	var stats []byte
	err := row.Scan(&stats)
	return stats, err
}
