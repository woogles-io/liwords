// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: puzzles.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPotentialPuzzleGames = `-- name: GetPotentialPuzzleGames :many
SELECT past_games.gid FROM past_games
JOIN games ON past_games.gid = games.uuid
JOIN game_metadata ON game_metadata.game_uuid = past_games.gid
LEFT JOIN puzzles ON puzzles.game_id = games.id
WHERE puzzles.id IS NULL 
    AND past_games.created_at BETWEEN $1 AND $2
    AND (past_games.stats->'d1'->'Challenged Phonies'->'t' = '0')
    AND (past_games.stats->'d2'->'Challenged Phonies'->'t' = '0')
    AND (past_games.stats->'d1'->'Unchallenged Phonies'->'t' = '0')
    AND (past_games.stats->'d2'->'Unchallenged Phonies'->'t' = '0')
    AND game_metadata.game_request->>'lexicon' = $3::text
    AND game_metadata.game_request->'rules'->>'variantName' = 'classic'
    -- 0: none, 5: aborted, 7: canceled
    AND past_games.game_end_reason NOT IN (0, 5, 7)
    AND past_games.type = 0
    
    ORDER BY games.id DESC 
    LIMIT $4 OFFSET $5
`

type GetPotentialPuzzleGamesParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
	Column3     string
	Limit       int32
	Offset      int32
}

func (q *Queries) GetPotentialPuzzleGames(ctx context.Context, arg GetPotentialPuzzleGamesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getPotentialPuzzleGames,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var gid string
		if err := rows.Scan(&gid); err != nil {
			return nil, err
		}
		items = append(items, gid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPotentialPuzzleGamesAvoidBots = `-- name: GetPotentialPuzzleGamesAvoidBots :many

SELECT past_games.gid FROM past_games
JOIN games ON past_games.gid = games.uuid
JOIN game_metadata ON game_metadata.game_uuid = past_games.gid
LEFT JOIN puzzles ON puzzles.game_id = games.id
WHERE puzzles.id IS NULL 
    AND past_games.created_at BETWEEN $1 AND $2
    AND (past_games.stats->'d1'->'Challenged Phonies'->'t' = '0')
    AND (past_games.stats->'d2'->'Challenged Phonies'->'t' = '0')
    AND (past_games.stats->'d1'->'Unchallenged Phonies'->'t' = '0')
    AND (past_games.stats->'d2'->'Unchallenged Phonies'->'t' = '0')
    AND game_metadata.game_request->>'lexicon' = $3::text
    AND game_metadata.game_request->'rules'->>'variantName' = 'classic'
    -- 0: none, 5: aborted, 7: canceled
    AND past_games.game_end_reason NOT IN (0, 5, 7)
    AND NOT (past_games.quickdata @> '{"pi": [{"is_bot": true}]}'::jsonb)
    AND past_games.type = 0

    ORDER BY games.id DESC 
    LIMIT $4 OFFSET $5
`

type GetPotentialPuzzleGamesAvoidBotsParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
	Column3     string
	Limit       int32
	Offset      int32
}

// puzzle generation
func (q *Queries) GetPotentialPuzzleGamesAvoidBots(ctx context.Context, arg GetPotentialPuzzleGamesAvoidBotsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getPotentialPuzzleGamesAvoidBots,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var gid string
		if err := rows.Scan(&gid); err != nil {
			return nil, err
		}
		items = append(items, gid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
