// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organization_titles.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAllUsersWithOrganization = `-- name: GetAllUsersWithOrganization :many
SELECT users.uuid as user_uuid, users.username, integrations.integration_name, integrations.data
FROM integrations
JOIN users ON users.id = integrations.user_id
WHERE integration_name = $1
`

type GetAllUsersWithOrganizationRow struct {
	UserUuid        pgtype.Text
	Username        pgtype.Text
	IntegrationName string
	Data            []byte
}

func (q *Queries) GetAllUsersWithOrganization(ctx context.Context, integrationName string) ([]GetAllUsersWithOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersWithOrganization, integrationName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersWithOrganizationRow
	for rows.Next() {
		var i GetAllUsersWithOrganizationRow
		if err := rows.Scan(
			&i.UserUuid,
			&i.Username,
			&i.IntegrationName,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationIntegrations = `-- name: GetOrganizationIntegrations :many
SELECT integrations.uuid, integration_name, data, last_updated
FROM integrations
WHERE user_id = (SELECT id FROM users WHERE users.uuid = $1)
AND integration_name IN ('naspa', 'wespa', 'absp')
`

type GetOrganizationIntegrationsRow struct {
	Uuid            uuid.UUID
	IntegrationName string
	Data            []byte
	LastUpdated     pgtype.Timestamptz
}

func (q *Queries) GetOrganizationIntegrations(ctx context.Context, userUuid pgtype.Text) ([]GetOrganizationIntegrationsRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationIntegrations, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrganizationIntegrationsRow
	for rows.Next() {
		var i GetOrganizationIntegrationsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.IntegrationName,
			&i.Data,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProfileTitle = `-- name: GetUserProfileTitle :one
SELECT title FROM profiles
WHERE user_id = (SELECT id FROM users WHERE uuid = $1)
`

func (q *Queries) GetUserProfileTitle(ctx context.Context, userUuid pgtype.Text) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getUserProfileTitle, userUuid)
	var title pgtype.Text
	err := row.Scan(&title)
	return title, err
}

const getUsersWithExpiredTitles = `-- name: GetUsersWithExpiredTitles :many
SELECT users.uuid as user_uuid, users.username, integrations.integration_name, integrations.data
FROM integrations
JOIN users ON users.id = integrations.user_id
WHERE integration_name IN ('naspa', 'wespa', 'absp')
AND (integrations.data->>'last_fetched')::timestamptz < CURRENT_TIMESTAMP - INTERVAL '30 days'
`

type GetUsersWithExpiredTitlesRow struct {
	UserUuid        pgtype.Text
	Username        pgtype.Text
	IntegrationName string
	Data            []byte
}

func (q *Queries) GetUsersWithExpiredTitles(ctx context.Context) ([]GetUsersWithExpiredTitlesRow, error) {
	rows, err := q.db.Query(ctx, getUsersWithExpiredTitles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithExpiredTitlesRow
	for rows.Next() {
		var i GetUsersWithExpiredTitlesRow
		if err := rows.Scan(
			&i.UserUuid,
			&i.Username,
			&i.IntegrationName,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProfileTitle = `-- name: UpdateProfileTitle :exec
UPDATE profiles
SET title = $1
WHERE user_id = (SELECT id FROM users WHERE uuid = $2)
`

type UpdateProfileTitleParams struct {
	Title    pgtype.Text
	UserUuid pgtype.Text
}

func (q *Queries) UpdateProfileTitle(ctx context.Context, arg UpdateProfileTitleParams) error {
	_, err := q.db.Exec(ctx, updateProfileTitle, arg.Title, arg.UserUuid)
	return err
}
