package tournament

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/rs/zerolog/log"
	"github.com/woogles-io/liwords/pkg/entity"
	"github.com/woogles-io/liwords/pkg/integrations/organizations"
	"github.com/woogles-io/liwords/pkg/stores/models"
	"github.com/woogles-io/liwords/pkg/user"
	ipc "github.com/woogles-io/liwords/rpc/api/proto/ipc"
)

// ExportOptions contains options for exporting a tournament
type ExportOptions struct {
	UseRealNames bool
	Queries      *models.Queries
}

func ExportTournament(ctx context.Context, t *entity.Tournament, us user.Store, format string, opts *ExportOptions) (string, error) {
	if opts == nil {
		opts = &ExportOptions{}
	}
	switch format {
	case "tsh":
		return exportToTSH(ctx, t, us)
	case "standingsonly":
		return exportStandings(ctx, t)
	case "tou":
		return exportToTOU(ctx, t, us, opts)
	// case "aupair":
	// 	return exportToAUPair(ctx, t, us)
	default:
		return "", fmt.Errorf("the format %s is not supported", format)
	}
}

func sortedDivNames(t *entity.Tournament) []string {
	sortedKeys := make([]string, len(t.Divisions))
	idx := 0
	for dname := range t.Divisions {
		sortedKeys[idx] = dname
		idx += 1
	}
	sort.Strings(sortedKeys)
	return sortedKeys
}

func exportToTSH(ctx context.Context, t *entity.Tournament, us user.Store) (string, error) {
	// https://scrabbleplayers.org/tourneys/2022/tsh/04/202204301.tsh
	var sb strings.Builder
	sb.WriteString("# tsh archive file\n# automatically generated by Woogles\n")
	normalize := func(div string) string {
		return strings.ReplaceAll(div, " ", "")
	}
	divNames := sortedDivNames(t)
	for _, dname := range divNames {
		fmt.Fprintf(&sb, "division %s %s.t\n", normalize(dname), normalize(dname))
	}
	sb.WriteString("# tsh archive file\n")
	sb.WriteString("# config naspa_tournament_id = 1\n")
	sb.WriteString("# config naspa_director_id = \"AA000000\"\n")
	sb.WriteString("config rating_system = \"nsa2008\"\n")
	sb.WriteString("config archive_source_type = 'tsh'\n")
	sb.WriteString("# config event_name = \"Woogles, MI\"\n")
	sb.WriteString("# config event_date = \"April 30, 2022\"\n")

	for _, dname := range divNames {
		division := t.Divisions[dname]
		fmt.Fprintf(&sb, "#begin_file name=%s.t\n", normalize(dname))

		if division.DivisionManager == nil {
			return "", errors.New("nil division manager")
		}
		xhr, err := division.DivisionManager.GetXHRResponse()
		if err != nil {
			return "", err
		}

		// pre-parse pairing map to allow for faster lookup
		// create a map of user indexes to pairings with potential duplicates
		biggerMap := map[string]*ipc.Pairing{}
		for _, pairing := range xhr.PairingMap {
			for _, p := range pairing.Players {
				key := fmt.Sprintf("%d-%d", p, pairing.Round)
				biggerMap[key] = pairing
			}
		}

		for pidx, p := range xhr.Players.Persons {
			split := strings.Split(p.Id, ":")
			if len(split) != 2 {
				return "", fmt.Errorf("unexpected badly formatted player id %s", p.Id)
			}
			var realName string
			u, err := us.GetByUUID(ctx, split[0])
			if err == nil {
				realName = u.RealName()
			}
			// Otherwise, ignore the error. This will allow some flexibility
			// for users not actually registered in our system (i.e. IRL users)
			if realName == "" {
				realName = split[1]
			}
			// try to split
			split = strings.SplitN(realName, " ", 2)
			if len(split) == 2 {
				realName = split[1] + ", " + split[0]
			}
			fmt.Fprintf(&sb, "%v\t%d", realName, p.Rating)
			scores := make([]int, xhr.CurrentRound+1)
			// Write all pairings and then scores.
			for rd := int32(0); rd <= xhr.CurrentRound; rd++ {
				var score int
				key := fmt.Sprintf("%d-%d", pidx, rd)
				pairing := biggerMap[key]
				if pairing == nil {
					log.Info().Int32("rd", rd).Int("p", pidx).Msg("nil-pairing")
					continue
				}
				if pairing.Players[0] == pairing.Players[1] {
					// It's a bye; write a 0.
					sb.WriteString(" 0")
					switch pairing.Outcomes[0] {
					case ipc.TournamentGameResult_BYE, ipc.TournamentGameResult_FORFEIT_WIN:
						score = 50
					case ipc.TournamentGameResult_FORFEIT_LOSS:
						score = -50
					case ipc.TournamentGameResult_VOID:
						score = 0
					default:
						return "", fmt.Errorf("unexpected tournament game result; rd %v outcome %v pidx %v", rd, pairing.Outcomes[0], pidx)
					}
				} else {
					for idx, opp := range pairing.Players {
						if int(opp) != pidx {
							// This is the opponent.
							// Player-indexes are 1-indexed:
							fmt.Fprintf(&sb, " %d", opp+1)
							// This assumes 2 players per game but we've already made our bed:
							score = int(pairing.Games[0].Scores[1-idx])
						}
					}
				}
				scores[rd] = score
			}
			sb.WriteString(";")
			for _, score := range scores {
				fmt.Fprintf(&sb, " %d", score)
			}
			sb.WriteString("\n")
		}
		fmt.Fprintf(&sb, "#end_file name=%s.t\n", normalize(dname))
	}
	return sb.String(), nil
}

func exportStandings(ctx context.Context, t *entity.Tournament) (string, error) {
	var sb strings.Builder
	sb.WriteString("division,rank,username,wins,losses,draws,winpts,spread\n")
	divNames := sortedDivNames(t)
	for _, dname := range divNames {
		division := t.Divisions[dname]
		if division.DivisionManager == nil {
			return "", errors.New("nil division manager")
		}
		xhr, err := division.DivisionManager.GetXHRResponse()
		if err != nil {
			return "", err
		}
		rdStandings := xhr.Standings[xhr.CurrentRound]
		if rdStandings == nil {
			return "", errors.New("round standings are nil?")
		}
		for idx, std := range rdStandings.Standings {
			p := std.PlayerId
			split := strings.Split(p, ":")
			if len(split) != 2 {
				return "", fmt.Errorf("unexpected badly formatted player id %s", p)
			}
			username := split[1]
			fmt.Fprintf(&sb, "%s,%d,%s,%d,%d,%d,%0.1f,%d\n", dname, idx+1, username, std.Wins,
				std.Losses, std.Draws, float32(std.Wins)+0.5*float32(std.Draws),
				std.Spread)
		}
	}
	return sb.String(), nil
}

// toASCII converts a string to ASCII-only by replacing or removing non-ASCII characters.
func toASCII(s string) string {
	// Common replacements for accented characters
	replacements := map[rune]string{
		'á': "a", 'à': "a", 'ä': "a", 'â': "a", 'ã': "a", 'å': "a", 'ā': "a",
		'Á': "A", 'À': "A", 'Ä': "A", 'Â': "A", 'Ã': "A", 'Å': "A", 'Ā': "A",
		'é': "e", 'è': "e", 'ë': "e", 'ê': "e", 'ē': "e", 'ę': "e",
		'É': "E", 'È': "E", 'Ë': "E", 'Ê': "E", 'Ē': "E", 'Ę': "E",
		'í': "i", 'ì': "i", 'ï': "i", 'î': "i", 'ī': "i",
		'Í': "I", 'Ì': "I", 'Ï': "I", 'Î': "I", 'Ī': "I",
		'ó': "o", 'ò': "o", 'ö': "o", 'ô': "o", 'õ': "o", 'ō': "o", 'ø': "o",
		'Ó': "O", 'Ò': "O", 'Ö': "O", 'Ô': "O", 'Õ': "O", 'Ō': "O", 'Ø': "O",
		'ú': "u", 'ù': "u", 'ü': "u", 'û': "u", 'ū': "u",
		'Ú': "U", 'Ù': "U", 'Ü': "U", 'Û': "U", 'Ū': "U",
		'ñ': "n", 'Ñ': "N",
		'ç': "c", 'Ç': "C",
		'ß': "ss",
		'ł': "l", 'Ł': "L",
		'ž': "z", 'Ž': "Z",
		'š': "s", 'Š': "S",
		'ý': "y", 'Ý': "Y", 'ÿ': "y",
		'đ': "d", 'Đ': "D",
		'ř': "r", 'Ř': "R",
		'ť': "t", 'Ť': "T",
		'ň': "n", 'Ň': "N",
		'ě': "e", 'Ě': "E",
		'ů': "u", 'Ů': "U",
		'ć': "c", 'Ć': "C",
		'ą': "a", 'Ą': "A",
		'ś': "s", 'Ś': "S",
		'ź': "z", 'Ź': "Z",
		'ż': "z", 'Ż': "Z",
		'ń': "n", 'Ń': "N",
		'æ': "ae", 'Æ': "AE",
		'œ': "oe", 'Œ': "OE",
		0x2018: "'", 0x2019: "'", 0x201C: "\"", 0x201D: "\"",
		0x2013: "-", 0x2014: "-",
	}

	var result strings.Builder
	for _, r := range s {
		if r < 128 {
			result.WriteRune(r)
		} else if replacement, ok := replacements[r]; ok {
			result.WriteString(replacement)
		}
		// Non-ASCII characters without a replacement are dropped
	}
	return result.String()
}

// getPlayerDisplayName returns the display name for a player based on export options.
// If useRealNames is true, it tries to get the name from:
// 1. WESPA integration (if available)
// 2. NASPA integration (if available)
// 3. User's first/last name from profile
// 4. Username as fallback
func getPlayerDisplayName(ctx context.Context, userUUID, username string, us user.Store, opts *ExportOptions) string {
	if !opts.UseRealNames {
		return username
	}

	// Try to get name from integrations (WESPA first, then NASPA)
	if opts.Queries != nil {
		for _, orgCode := range []string{"wespa", "naspa"} {
			integData, err := opts.Queries.GetIntegrationData(ctx, models.GetIntegrationDataParams{
				IntegrationName: orgCode,
				UserUuid:        pgtype.Text{String: userUUID, Valid: true},
			})
			if err == nil && len(integData.Data) > 0 {
				var orgData organizations.OrganizationIntegrationData
				if err := json.Unmarshal(integData.Data, &orgData); err == nil && orgData.FullName != "" {
					return orgData.FullName
				}
			}
		}
	}

	// Try to get name from user profile
	u, err := us.GetByUUID(ctx, userUUID)
	if err == nil {
		realName := u.RealName()
		if realName != "" {
			return realName
		}
	}

	// Fall back to username
	return username
}

// exportToTOU exports tournament data to TOU format.
// TOU format is used by some tournament management software.
// Output is ASCII-only with DOS-style CRLF line endings.
func exportToTOU(ctx context.Context, t *entity.Tournament, us user.Store, opts *ExportOptions) (string, error) {
	var sb strings.Builder
	crlf := "\r\n"

	// Get tournament date - use scheduled start time or current date
	tournamentDate := time.Now()
	if t.ScheduledStartTime != nil {
		tournamentDate = *t.ScheduledStartTime
	}

	// Format date as DD.MM.YYYY
	dateStr := tournamentDate.Format("02.01.2006")

	// Get tournament name
	tournamentName := toASCII(t.Name)

	divNames := sortedDivNames(t)
	for _, dname := range divNames {
		division := t.Divisions[dname]

		// Write header line: *MDD.MM.YYYY Tournament Name
		fmt.Fprintf(&sb, "*M%s %s%s", dateStr, tournamentName, crlf)

		// Write division name line
		fmt.Fprintf(&sb, "*%s%s", toASCII(dname), crlf)

		// Write high word line
		// TODO: Implement high word tracking. For now, output placeholder.
		sb.WriteString("                                      0")
		sb.WriteString(crlf)

		if division.DivisionManager == nil {
			return "", errors.New("nil division manager")
		}
		xhr, err := division.DivisionManager.GetXHRResponse()
		if err != nil {
			return "", err
		}

		// Determine if we need 3-digit opponent IDs (9-char blocks instead of 8)
		numPlayers := len(xhr.Players.Persons)
		useThreeDigitIDs := numPlayers > 99

		// Pre-parse pairing map for faster lookup
		// Map: "playerIdx-round" -> pairing
		pairingMap := map[string]*ipc.Pairing{}
		for _, pairing := range xhr.PairingMap {
			for _, p := range pairing.Players {
				key := fmt.Sprintf("%d-%d", p, pairing.Round)
				pairingMap[key] = pairing
			}
		}

		// Write player data
		for pidx, p := range xhr.Players.Persons {
			split := strings.Split(p.Id, ":")
			if len(split) != 2 {
				return "", fmt.Errorf("unexpected badly formatted player id %s", p.Id)
			}
			userUUID := split[0]
			username := split[1]

			// Get display name and convert to ASCII
			displayName := toASCII(getPlayerDisplayName(ctx, userUUID, username, us, opts))

			// Pad/truncate name to 20 characters
			if len(displayName) > 20 {
				displayName = displayName[:20]
			}
			fmt.Fprintf(&sb, "%-20s", displayName)

			// Write game data for each round
			for rd := int32(0); rd <= xhr.CurrentRound; rd++ {
				key := fmt.Sprintf("%d-%d", pidx, rd)
				pairing := pairingMap[key]
				if pairing == nil {
					log.Info().Int32("rd", rd).Int("p", pidx).Msg("nil-pairing-tou")
					continue
				}

				sb.WriteString(" ")

				// Determine if this is a bye (player paired with themselves)
				isBye := pairing.Players[0] == pairing.Players[1]

				var score int
				var opponentIdx int32
				var wentFirst bool
				var outcome ipc.TournamentGameResult

				if isBye {
					// For byes: opponent is self
					opponentIdx = int32(pidx)
					wentFirst = false
					outcome = pairing.Outcomes[0]
					// Handle different bye types
					switch outcome {
					case ipc.TournamentGameResult_BYE:
						// True bye: score of 50, recorded as a loss (no outcome prefix)
						score = 50
						outcome = ipc.TournamentGameResult_LOSS // Force loss outcome for display
					case ipc.TournamentGameResult_FORFEIT_WIN:
						// Forfeit win: winner gets 150
						score = 150
					case ipc.TournamentGameResult_FORFEIT_LOSS:
						// Forfeit loss: loser gets 100
						score = 100
					case ipc.TournamentGameResult_VOID:
						score = 0
					default:
						// Default bye score
						score = 50
						outcome = ipc.TournamentGameResult_LOSS
					}
				} else {
					// Regular game
					// Find which index this player is in the pairing
					var playerIdxInPairing int
					for idx, opp := range pairing.Players {
						if int32(pidx) == opp {
							playerIdxInPairing = idx
						} else {
							opponentIdx = opp
						}
					}

					// Player went first if they are Players[0]
					wentFirst = pairing.Players[0] == int32(pidx)

					// Get score and outcome
					if len(pairing.Games) > 0 && len(pairing.Games[0].Scores) > playerIdxInPairing {
						score = int(pairing.Games[0].Scores[playerIdxInPairing])
					}
					if len(pairing.Outcomes) > playerIdxInPairing {
						outcome = pairing.Outcomes[playerIdxInPairing]
					}
				}

				// Build the game block
				// Format: <outcome><score> <start><opponent_id>
				// Outcome: 2=win, 1=draw, space=loss
				// Start: +=went first, space=went second

				var outcomeChar string
				switch outcome {
				case ipc.TournamentGameResult_WIN, ipc.TournamentGameResult_BYE, ipc.TournamentGameResult_FORFEIT_WIN:
					outcomeChar = "2"
				case ipc.TournamentGameResult_DRAW:
					outcomeChar = "1"
				default:
					outcomeChar = " "
				}

				// Opponent ID is 1-indexed (player 0 is opponent ID 1)
				opponentID := opponentIdx + 1

				// Format the start+opponent field (right-justified)
				// The start indicator (+) is part of the opponent field
				var oppField string
				if wentFirst {
					oppField = fmt.Sprintf("+%d", opponentID)
				} else {
					oppField = fmt.Sprintf("%d", opponentID)
				}

				// Format score (3 digits) and opponent ID field
				if useThreeDigitIDs {
					// 9-character block: <outcome:1><score:3><space:1><opponent-field:4>
					fmt.Fprintf(&sb, "%s%3d %4s", outcomeChar, score%1000, oppField)
				} else {
					// 8-character block: <outcome:1><score:3><space:1><opponent-field:3>
					fmt.Fprintf(&sb, "%s%3d %3s", outcomeChar, score%1000, oppField)
				}
			}
			sb.WriteString(crlf)
		}
	}

	sb.WriteString("*** END OF FILE ***")
	sb.WriteString(crlf)
	return sb.String(), nil
}
