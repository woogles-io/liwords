// messages related to the omgwords game, used mainly by IPC
// note: omgwords is the crossword board game, and includes variants dogworms,
// superomgwords, etc etc

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: proto/ipc/omgwords.proto

package ipc

import (
	macondo "github.com/domino14/macondo/gen/api/proto/macondo"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GameEndReason int32

const (
	// NONE: the game has not yet ended!
	GameEndReason_NONE GameEndReason = 0
	// TIME: one person timed out (and lost)
	GameEndReason_TIME GameEndReason = 1
	// WENT_OUT: game ended regularly, with one person having zero tiles on their
	// rack.
	GameEndReason_STANDARD GameEndReason = 2
	// 6 consecutive zeroes ends the game.
	GameEndReason_CONSECUTIVE_ZEROES GameEndReason = 3
	GameEndReason_RESIGNED           GameEndReason = 4
	// Aborted games are aborted by mutual agreement.
	GameEndReason_ABORTED          GameEndReason = 5
	GameEndReason_TRIPLE_CHALLENGE GameEndReason = 6
	// CANCELLED means the game never started. Game start signal was not sent.
	GameEndReason_CANCELLED GameEndReason = 7
	// FORCE_FORFEIT is a way to force an opponent to take a loss if they left a
	// game early without resigning.
	GameEndReason_FORCE_FORFEIT GameEndReason = 8
)

// Enum value maps for GameEndReason.
var (
	GameEndReason_name = map[int32]string{
		0: "NONE",
		1: "TIME",
		2: "STANDARD",
		3: "CONSECUTIVE_ZEROES",
		4: "RESIGNED",
		5: "ABORTED",
		6: "TRIPLE_CHALLENGE",
		7: "CANCELLED",
		8: "FORCE_FORFEIT",
	}
	GameEndReason_value = map[string]int32{
		"NONE":               0,
		"TIME":               1,
		"STANDARD":           2,
		"CONSECUTIVE_ZEROES": 3,
		"RESIGNED":           4,
		"ABORTED":            5,
		"TRIPLE_CHALLENGE":   6,
		"CANCELLED":          7,
		"FORCE_FORFEIT":      8,
	}
)

func (x GameEndReason) Enum() *GameEndReason {
	p := new(GameEndReason)
	*p = x
	return p
}

func (x GameEndReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GameEndReason) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[0].Descriptor()
}

func (GameEndReason) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[0]
}

func (x GameEndReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GameEndReason.Descriptor instead.
func (GameEndReason) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{0}
}

type GameMode int32

const (
	GameMode_REAL_TIME      GameMode = 0
	GameMode_CORRESPONDENCE GameMode = 1
)

// Enum value maps for GameMode.
var (
	GameMode_name = map[int32]string{
		0: "REAL_TIME",
		1: "CORRESPONDENCE",
	}
	GameMode_value = map[string]int32{
		"REAL_TIME":      0,
		"CORRESPONDENCE": 1,
	}
)

func (x GameMode) Enum() *GameMode {
	p := new(GameMode)
	*p = x
	return p
}

func (x GameMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GameMode) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[1].Descriptor()
}

func (GameMode) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[1]
}

func (x GameMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GameMode.Descriptor instead.
func (GameMode) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{1}
}

type RatingMode int32

const (
	RatingMode_RATED  RatingMode = 0
	RatingMode_CASUAL RatingMode = 1
)

// Enum value maps for RatingMode.
var (
	RatingMode_name = map[int32]string{
		0: "RATED",
		1: "CASUAL",
	}
	RatingMode_value = map[string]int32{
		"RATED":  0,
		"CASUAL": 1,
	}
)

func (x RatingMode) Enum() *RatingMode {
	p := new(RatingMode)
	*p = x
	return p
}

func (x RatingMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RatingMode) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[2].Descriptor()
}

func (RatingMode) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[2]
}

func (x RatingMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RatingMode.Descriptor instead.
func (RatingMode) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{2}
}

type GameType int32

const (
	// A NATIVE game is the default OMGWords game (or its variants)
	// created on the woogles site, between two players or between a player
	// and a bot.
	GameType_NATIVE GameType = 0
	// An ANNOTATED game does not feature Woogles players, but is instead
	// created by a broadcaster/annotator to represent a real-life game.
	// It is created using the liwords "editor" mode or by importing a GCG.
	GameType_ANNOTATED  GameType = 1
	GameType_BOT_VS_BOT GameType = 2
)

// Enum value maps for GameType.
var (
	GameType_name = map[int32]string{
		0: "NATIVE",
		1: "ANNOTATED",
		2: "BOT_VS_BOT",
	}
	GameType_value = map[string]int32{
		"NATIVE":     0,
		"ANNOTATED":  1,
		"BOT_VS_BOT": 2,
	}
)

func (x GameType) Enum() *GameType {
	p := new(GameType)
	*p = x
	return p
}

func (x GameType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GameType) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[3].Descriptor()
}

func (GameType) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[3]
}

func (x GameType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GameType.Descriptor instead.
func (GameType) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{3}
}

type PlayState int32

const (
	PlayState_PLAYING                PlayState = 0
	PlayState_WAITING_FOR_FINAL_PASS PlayState = 1
	PlayState_GAME_OVER              PlayState = 2
	PlayState_UNSTARTED              PlayState = 3
)

// Enum value maps for PlayState.
var (
	PlayState_name = map[int32]string{
		0: "PLAYING",
		1: "WAITING_FOR_FINAL_PASS",
		2: "GAME_OVER",
		3: "UNSTARTED",
	}
	PlayState_value = map[string]int32{
		"PLAYING":                0,
		"WAITING_FOR_FINAL_PASS": 1,
		"GAME_OVER":              2,
		"UNSTARTED":              3,
	}
)

func (x PlayState) Enum() *PlayState {
	p := new(PlayState)
	*p = x
	return p
}

func (x PlayState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PlayState) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[4].Descriptor()
}

func (PlayState) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[4]
}

func (x PlayState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PlayState.Descriptor instead.
func (PlayState) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{4}
}

type ChallengeRule int32

const (
	ChallengeRule_ChallengeRule_VOID       ChallengeRule = 0
	ChallengeRule_ChallengeRule_SINGLE     ChallengeRule = 1
	ChallengeRule_ChallengeRule_DOUBLE     ChallengeRule = 2
	ChallengeRule_ChallengeRule_FIVE_POINT ChallengeRule = 3
	ChallengeRule_ChallengeRule_TEN_POINT  ChallengeRule = 4
	ChallengeRule_ChallengeRule_TRIPLE     ChallengeRule = 5
)

// Enum value maps for ChallengeRule.
var (
	ChallengeRule_name = map[int32]string{
		0: "ChallengeRule_VOID",
		1: "ChallengeRule_SINGLE",
		2: "ChallengeRule_DOUBLE",
		3: "ChallengeRule_FIVE_POINT",
		4: "ChallengeRule_TEN_POINT",
		5: "ChallengeRule_TRIPLE",
	}
	ChallengeRule_value = map[string]int32{
		"ChallengeRule_VOID":       0,
		"ChallengeRule_SINGLE":     1,
		"ChallengeRule_DOUBLE":     2,
		"ChallengeRule_FIVE_POINT": 3,
		"ChallengeRule_TEN_POINT":  4,
		"ChallengeRule_TRIPLE":     5,
	}
)

func (x ChallengeRule) Enum() *ChallengeRule {
	p := new(ChallengeRule)
	*p = x
	return p
}

func (x ChallengeRule) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChallengeRule) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[5].Descriptor()
}

func (ChallengeRule) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[5]
}

func (x ChallengeRule) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChallengeRule.Descriptor instead.
func (ChallengeRule) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{5}
}

type ClientGameplayEvent_EventType int32

const (
	ClientGameplayEvent_TILE_PLACEMENT ClientGameplayEvent_EventType = 0
	ClientGameplayEvent_PASS           ClientGameplayEvent_EventType = 1
	ClientGameplayEvent_EXCHANGE       ClientGameplayEvent_EventType = 2
	ClientGameplayEvent_CHALLENGE_PLAY ClientGameplayEvent_EventType = 3
	ClientGameplayEvent_RESIGN         ClientGameplayEvent_EventType = 4
)

// Enum value maps for ClientGameplayEvent_EventType.
var (
	ClientGameplayEvent_EventType_name = map[int32]string{
		0: "TILE_PLACEMENT",
		1: "PASS",
		2: "EXCHANGE",
		3: "CHALLENGE_PLAY",
		4: "RESIGN",
	}
	ClientGameplayEvent_EventType_value = map[string]int32{
		"TILE_PLACEMENT": 0,
		"PASS":           1,
		"EXCHANGE":       2,
		"CHALLENGE_PLAY": 3,
		"RESIGN":         4,
	}
)

func (x ClientGameplayEvent_EventType) Enum() *ClientGameplayEvent_EventType {
	p := new(ClientGameplayEvent_EventType)
	*p = x
	return p
}

func (x ClientGameplayEvent_EventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClientGameplayEvent_EventType) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[6].Descriptor()
}

func (ClientGameplayEvent_EventType) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[6]
}

func (x ClientGameplayEvent_EventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClientGameplayEvent_EventType.Descriptor instead.
func (ClientGameplayEvent_EventType) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{0, 0}
}

type GameMetaEvent_EventType int32

const (
	// These are "original events"
	GameMetaEvent_REQUEST_ABORT GameMetaEvent_EventType = 0
	// Adjudication is just seen as a "nudge" on the front end.
	GameMetaEvent_REQUEST_ADJUDICATION GameMetaEvent_EventType = 1
	GameMetaEvent_REQUEST_UNDO         GameMetaEvent_EventType = 2
	GameMetaEvent_REQUEST_ADJOURN      GameMetaEvent_EventType = 3 // Are we going to implement this someday?
	// And these are responses:
	// A user can accept an abort, or the client will auto-accept when time
	// expires:
	GameMetaEvent_ABORT_ACCEPTED GameMetaEvent_EventType = 4
	GameMetaEvent_ABORT_DENIED   GameMetaEvent_EventType = 5
	// A user would not accept an adjudication. The client auto-accepts this
	// when time expires
	GameMetaEvent_ADJUDICATION_ACCEPTED GameMetaEvent_EventType = 6
	// An adjudication is denied when the receiver responds positively to a
	// nudge.
	GameMetaEvent_ADJUDICATION_DENIED GameMetaEvent_EventType = 7
	GameMetaEvent_UNDO_ACCEPTED       GameMetaEvent_EventType = 8
	GameMetaEvent_UNDO_DENIED         GameMetaEvent_EventType = 9
	// More:
	GameMetaEvent_ADD_TIME GameMetaEvent_EventType = 10 // add X seconds at a time (30?) to opponent's clock
	// Some meta events have a timer associated with them. Send this with the
	// original event id after time has expired.
	GameMetaEvent_TIMER_EXPIRED GameMetaEvent_EventType = 11
)

// Enum value maps for GameMetaEvent_EventType.
var (
	GameMetaEvent_EventType_name = map[int32]string{
		0:  "REQUEST_ABORT",
		1:  "REQUEST_ADJUDICATION",
		2:  "REQUEST_UNDO",
		3:  "REQUEST_ADJOURN",
		4:  "ABORT_ACCEPTED",
		5:  "ABORT_DENIED",
		6:  "ADJUDICATION_ACCEPTED",
		7:  "ADJUDICATION_DENIED",
		8:  "UNDO_ACCEPTED",
		9:  "UNDO_DENIED",
		10: "ADD_TIME",
		11: "TIMER_EXPIRED",
	}
	GameMetaEvent_EventType_value = map[string]int32{
		"REQUEST_ABORT":         0,
		"REQUEST_ADJUDICATION":  1,
		"REQUEST_UNDO":          2,
		"REQUEST_ADJOURN":       3,
		"ABORT_ACCEPTED":        4,
		"ABORT_DENIED":          5,
		"ADJUDICATION_ACCEPTED": 6,
		"ADJUDICATION_DENIED":   7,
		"UNDO_ACCEPTED":         8,
		"UNDO_DENIED":           9,
		"ADD_TIME":              10,
		"TIMER_EXPIRED":         11,
	}
)

func (x GameMetaEvent_EventType) Enum() *GameMetaEvent_EventType {
	p := new(GameMetaEvent_EventType)
	*p = x
	return p
}

func (x GameMetaEvent_EventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GameMetaEvent_EventType) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[7].Descriptor()
}

func (GameMetaEvent_EventType) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[7]
}

func (x GameMetaEvent_EventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GameMetaEvent_EventType.Descriptor instead.
func (GameMetaEvent_EventType) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{3, 0}
}

type GameEvent_Type int32

const (
	GameEvent_TILE_PLACEMENT_MOVE  GameEvent_Type = 0
	GameEvent_PHONY_TILES_RETURNED GameEvent_Type = 1
	GameEvent_PASS                 GameEvent_Type = 2
	GameEvent_CHALLENGE_BONUS      GameEvent_Type = 3
	GameEvent_EXCHANGE             GameEvent_Type = 4
	GameEvent_END_RACK_PTS         GameEvent_Type = 5
	GameEvent_TIME_PENALTY         GameEvent_Type = 6
	// Only for international rules (or after 6 zeroes)
	GameEvent_END_RACK_PENALTY GameEvent_Type = 7
	// Lose a turn for challenging a word incorrectly (only for double
	// challenge)
	GameEvent_UNSUCCESSFUL_CHALLENGE_TURN_LOSS GameEvent_Type = 8
	// Issue a challenge
	GameEvent_CHALLENGE GameEvent_Type = 9
	GameEvent_TIMED_OUT GameEvent_Type = 10
	GameEvent_RESIGNED  GameEvent_Type = 11
)

// Enum value maps for GameEvent_Type.
var (
	GameEvent_Type_name = map[int32]string{
		0:  "TILE_PLACEMENT_MOVE",
		1:  "PHONY_TILES_RETURNED",
		2:  "PASS",
		3:  "CHALLENGE_BONUS",
		4:  "EXCHANGE",
		5:  "END_RACK_PTS",
		6:  "TIME_PENALTY",
		7:  "END_RACK_PENALTY",
		8:  "UNSUCCESSFUL_CHALLENGE_TURN_LOSS",
		9:  "CHALLENGE",
		10: "TIMED_OUT",
		11: "RESIGNED",
	}
	GameEvent_Type_value = map[string]int32{
		"TILE_PLACEMENT_MOVE":              0,
		"PHONY_TILES_RETURNED":             1,
		"PASS":                             2,
		"CHALLENGE_BONUS":                  3,
		"EXCHANGE":                         4,
		"END_RACK_PTS":                     5,
		"TIME_PENALTY":                     6,
		"END_RACK_PENALTY":                 7,
		"UNSUCCESSFUL_CHALLENGE_TURN_LOSS": 8,
		"CHALLENGE":                        9,
		"TIMED_OUT":                        10,
		"RESIGNED":                         11,
	}
)

func (x GameEvent_Type) Enum() *GameEvent_Type {
	p := new(GameEvent_Type)
	*p = x
	return p
}

func (x GameEvent_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GameEvent_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[8].Descriptor()
}

func (GameEvent_Type) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[8]
}

func (x GameEvent_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GameEvent_Type.Descriptor instead.
func (GameEvent_Type) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{23, 0}
}

type GameEvent_Direction int32

const (
	GameEvent_HORIZONTAL GameEvent_Direction = 0
	GameEvent_VERTICAL   GameEvent_Direction = 1
)

// Enum value maps for GameEvent_Direction.
var (
	GameEvent_Direction_name = map[int32]string{
		0: "HORIZONTAL",
		1: "VERTICAL",
	}
	GameEvent_Direction_value = map[string]int32{
		"HORIZONTAL": 0,
		"VERTICAL":   1,
	}
)

func (x GameEvent_Direction) Enum() *GameEvent_Direction {
	p := new(GameEvent_Direction)
	*p = x
	return p
}

func (x GameEvent_Direction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GameEvent_Direction) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_ipc_omgwords_proto_enumTypes[9].Descriptor()
}

func (GameEvent_Direction) Type() protoreflect.EnumType {
	return &file_proto_ipc_omgwords_proto_enumTypes[9]
}

func (x GameEvent_Direction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GameEvent_Direction.Descriptor instead.
func (GameEvent_Direction) EnumDescriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{23, 1}
}

type ClientGameplayEvent struct {
	state  protoimpl.MessageState        `protogen:"open.v1"`
	Type   ClientGameplayEvent_EventType `protobuf:"varint,1,opt,name=type,proto3,enum=ipc.ClientGameplayEvent_EventType" json:"type,omitempty"`
	GameId string                        `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	// position coordinates, like H8 or G10. Only matters for TILE_PLACEMENT.
	PositionCoords string `protobuf:"bytes,3,opt,name=position_coords,json=positionCoords,proto3" json:"position_coords,omitempty"`
	// tiles that are being played (or exchanged). The `.` character is used
	// for thru, and lowercase characters are used for blanks.
	//
	// Deprecated: Marked as deprecated in proto/ipc/omgwords.proto.
	Tiles string `protobuf:"bytes,4,opt,name=tiles,proto3" json:"tiles,omitempty"`
	// machine_letters is tiles, but in binary.
	MachineLetters []byte `protobuf:"bytes,5,opt,name=machine_letters,json=machineLetters,proto3" json:"machine_letters,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ClientGameplayEvent) Reset() {
	*x = ClientGameplayEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientGameplayEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientGameplayEvent) ProtoMessage() {}

func (x *ClientGameplayEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientGameplayEvent.ProtoReflect.Descriptor instead.
func (*ClientGameplayEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{0}
}

func (x *ClientGameplayEvent) GetType() ClientGameplayEvent_EventType {
	if x != nil {
		return x.Type
	}
	return ClientGameplayEvent_TILE_PLACEMENT
}

func (x *ClientGameplayEvent) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

func (x *ClientGameplayEvent) GetPositionCoords() string {
	if x != nil {
		return x.PositionCoords
	}
	return ""
}

// Deprecated: Marked as deprecated in proto/ipc/omgwords.proto.
func (x *ClientGameplayEvent) GetTiles() string {
	if x != nil {
		return x.Tiles
	}
	return ""
}

func (x *ClientGameplayEvent) GetMachineLetters() []byte {
	if x != nil {
		return x.MachineLetters
	}
	return nil
}

// A GameRules is just the name of a board layout + the name of a letter
// distribution. These must exist in a database or file somewhere.
type GameRules struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The supported board layout names are CrosswordGame and SuperCrosswordGame
	BoardLayoutName string `protobuf:"bytes,1,opt,name=board_layout_name,json=boardLayoutName,proto3" json:"board_layout_name,omitempty"`
	// The supported letter distributions are english, french, norwegian, german,
	// catalan, spanish. There are more to come!
	LetterDistributionName string `protobuf:"bytes,2,opt,name=letter_distribution_name,json=letterDistributionName,proto3" json:"letter_distribution_name,omitempty"`
	// Use "classic" for our classic game, otherwise it could be some other game
	// (a is worth 100, dogworms, etc.)
	VariantName   string `protobuf:"bytes,3,opt,name=variant_name,json=variantName,proto3" json:"variant_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameRules) Reset() {
	*x = GameRules{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameRules) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameRules) ProtoMessage() {}

func (x *GameRules) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameRules.ProtoReflect.Descriptor instead.
func (*GameRules) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{1}
}

func (x *GameRules) GetBoardLayoutName() string {
	if x != nil {
		return x.BoardLayoutName
	}
	return ""
}

func (x *GameRules) GetLetterDistributionName() string {
	if x != nil {
		return x.LetterDistributionName
	}
	return ""
}

func (x *GameRules) GetVariantName() string {
	if x != nil {
		return x.VariantName
	}
	return ""
}

type GameRequest struct {
	state              protoimpl.MessageState     `protogen:"open.v1"`
	Lexicon            string                     `protobuf:"bytes,1,opt,name=lexicon,proto3" json:"lexicon,omitempty"`
	Rules              *GameRules                 `protobuf:"bytes,2,opt,name=rules,proto3" json:"rules,omitempty"`
	InitialTimeSeconds int32                      `protobuf:"varint,3,opt,name=initial_time_seconds,json=initialTimeSeconds,proto3" json:"initial_time_seconds,omitempty"`
	IncrementSeconds   int32                      `protobuf:"varint,4,opt,name=increment_seconds,json=incrementSeconds,proto3" json:"increment_seconds,omitempty"`
	ChallengeRule      macondo.ChallengeRule      `protobuf:"varint,5,opt,name=challenge_rule,json=challengeRule,proto3,enum=macondo.ChallengeRule" json:"challenge_rule,omitempty"`
	GameMode           GameMode                   `protobuf:"varint,6,opt,name=game_mode,json=gameMode,proto3,enum=ipc.GameMode" json:"game_mode,omitempty"`
	RatingMode         RatingMode                 `protobuf:"varint,7,opt,name=rating_mode,json=ratingMode,proto3,enum=ipc.RatingMode" json:"rating_mode,omitempty"`
	RequestId          string                     `protobuf:"bytes,8,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	MaxOvertimeMinutes int32                      `protobuf:"varint,9,opt,name=max_overtime_minutes,json=maxOvertimeMinutes,proto3" json:"max_overtime_minutes,omitempty"`
	PlayerVsBot        bool                       `protobuf:"varint,10,opt,name=player_vs_bot,json=playerVsBot,proto3" json:"player_vs_bot,omitempty"`
	OriginalRequestId  string                     `protobuf:"bytes,11,opt,name=original_request_id,json=originalRequestId,proto3" json:"original_request_id,omitempty"`
	BotType            macondo.BotRequest_BotCode `protobuf:"varint,12,opt,name=bot_type,json=botType,proto3,enum=macondo.BotRequest_BotCode" json:"bot_type,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *GameRequest) Reset() {
	*x = GameRequest{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameRequest) ProtoMessage() {}

func (x *GameRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameRequest.ProtoReflect.Descriptor instead.
func (*GameRequest) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{2}
}

func (x *GameRequest) GetLexicon() string {
	if x != nil {
		return x.Lexicon
	}
	return ""
}

func (x *GameRequest) GetRules() *GameRules {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *GameRequest) GetInitialTimeSeconds() int32 {
	if x != nil {
		return x.InitialTimeSeconds
	}
	return 0
}

func (x *GameRequest) GetIncrementSeconds() int32 {
	if x != nil {
		return x.IncrementSeconds
	}
	return 0
}

func (x *GameRequest) GetChallengeRule() macondo.ChallengeRule {
	if x != nil {
		return x.ChallengeRule
	}
	return macondo.ChallengeRule(0)
}

func (x *GameRequest) GetGameMode() GameMode {
	if x != nil {
		return x.GameMode
	}
	return GameMode_REAL_TIME
}

func (x *GameRequest) GetRatingMode() RatingMode {
	if x != nil {
		return x.RatingMode
	}
	return RatingMode_RATED
}

func (x *GameRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *GameRequest) GetMaxOvertimeMinutes() int32 {
	if x != nil {
		return x.MaxOvertimeMinutes
	}
	return 0
}

func (x *GameRequest) GetPlayerVsBot() bool {
	if x != nil {
		return x.PlayerVsBot
	}
	return false
}

func (x *GameRequest) GetOriginalRequestId() string {
	if x != nil {
		return x.OriginalRequestId
	}
	return ""
}

func (x *GameRequest) GetBotType() macondo.BotRequest_BotCode {
	if x != nil {
		return x.BotType
	}
	return macondo.BotRequest_BotCode(0)
}

// GameMetaEvent defines how we serialize meta events to the database.
type GameMetaEvent struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	OrigEventId   string                  `protobuf:"bytes,1,opt,name=orig_event_id,json=origEventId,proto3" json:"orig_event_id,omitempty"`
	Timestamp     *timestamppb.Timestamp  `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type          GameMetaEvent_EventType `protobuf:"varint,3,opt,name=type,proto3,enum=ipc.GameMetaEvent_EventType" json:"type,omitempty"`
	PlayerId      string                  `protobuf:"bytes,4,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"` // the player that performed the event.
	GameId        string                  `protobuf:"bytes,5,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Expiry        int32                   `protobuf:"varint,6,opt,name=expiry,proto3" json:"expiry,omitempty"` // how long should this event remain active, in milliseconds?
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameMetaEvent) Reset() {
	*x = GameMetaEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameMetaEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameMetaEvent) ProtoMessage() {}

func (x *GameMetaEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameMetaEvent.ProtoReflect.Descriptor instead.
func (*GameMetaEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{3}
}

func (x *GameMetaEvent) GetOrigEventId() string {
	if x != nil {
		return x.OrigEventId
	}
	return ""
}

func (x *GameMetaEvent) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *GameMetaEvent) GetType() GameMetaEvent_EventType {
	if x != nil {
		return x.Type
	}
	return GameMetaEvent_REQUEST_ABORT
}

func (x *GameMetaEvent) GetPlayerId() string {
	if x != nil {
		return x.PlayerId
	}
	return ""
}

func (x *GameMetaEvent) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

func (x *GameMetaEvent) GetExpiry() int32 {
	if x != nil {
		return x.Expiry
	}
	return 0
}

// A GameHistoryRefresher is sent to both players when the game starts,
// and any observers at the time that they begin observing. It can also be sent
// to a player who reconnects in the middle of a game.
type GameHistoryRefresher struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The history contains all the moves, points, as well as the last known racks
	// of each player. It also implicitly contains whose turn it is at the moment,
	// by the events / turns in the history.
	// The front-end is responsible for showing all this information in a nice
	// format.
	// Note: the racks of each player should not be sent to both players, only
	// to observers. The back-end will have to be smart enough to overwrite
	// this information with a blank string before sending it. It might not
	// even be that great of a big deal, as I'm sure people can devise other ways
	// to cheat, but shrug.
	History *macondo.GameHistory `protobuf:"bytes,1,opt,name=history,proto3" json:"history,omitempty"`
	// These represent how much time each player has remaining on their clock
	// as of the "refresher", in milliseconds.
	// player1 is the player who is listed first in the game history, regardless
	// of whether they went first.
	TimePlayer1        int32 `protobuf:"varint,2,opt,name=time_player1,json=timePlayer1,proto3" json:"time_player1,omitempty"`
	TimePlayer2        int32 `protobuf:"varint,3,opt,name=time_player2,json=timePlayer2,proto3" json:"time_player2,omitempty"`
	MaxOvertimeMinutes int32 `protobuf:"varint,4,opt,name=max_overtime_minutes,json=maxOvertimeMinutes,proto3" json:"max_overtime_minutes,omitempty"`
	// outstanding_event refers to any possible outstanding game meta event that
	// has not yet been responded to or expired.
	OutstandingEvent *GameMetaEvent `protobuf:"bytes,5,opt,name=outstanding_event,json=outstandingEvent,proto3" json:"outstanding_event,omitempty"`
	// time_of_last_update is when the last timer update occurred, in milliseconds.
	// For correspondence games, this is when the current player's turn started.
	TimeOfLastUpdate int64 `protobuf:"varint,6,opt,name=time_of_last_update,json=timeOfLastUpdate,proto3" json:"time_of_last_update,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *GameHistoryRefresher) Reset() {
	*x = GameHistoryRefresher{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameHistoryRefresher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameHistoryRefresher) ProtoMessage() {}

func (x *GameHistoryRefresher) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameHistoryRefresher.ProtoReflect.Descriptor instead.
func (*GameHistoryRefresher) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{4}
}

func (x *GameHistoryRefresher) GetHistory() *macondo.GameHistory {
	if x != nil {
		return x.History
	}
	return nil
}

func (x *GameHistoryRefresher) GetTimePlayer1() int32 {
	if x != nil {
		return x.TimePlayer1
	}
	return 0
}

func (x *GameHistoryRefresher) GetTimePlayer2() int32 {
	if x != nil {
		return x.TimePlayer2
	}
	return 0
}

func (x *GameHistoryRefresher) GetMaxOvertimeMinutes() int32 {
	if x != nil {
		return x.MaxOvertimeMinutes
	}
	return 0
}

func (x *GameHistoryRefresher) GetOutstandingEvent() *GameMetaEvent {
	if x != nil {
		return x.OutstandingEvent
	}
	return nil
}

func (x *GameHistoryRefresher) GetTimeOfLastUpdate() int64 {
	if x != nil {
		return x.TimeOfLastUpdate
	}
	return 0
}

// A GameDocumentEvent should eventually replace the GameHistoryRefresher. For
// now, it will be used for annotated games.
type GameDocumentEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Doc           *GameDocument          `protobuf:"bytes,1,opt,name=doc,proto3" json:"doc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameDocumentEvent) Reset() {
	*x = GameDocumentEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameDocumentEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameDocumentEvent) ProtoMessage() {}

func (x *GameDocumentEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameDocumentEvent.ProtoReflect.Descriptor instead.
func (*GameDocumentEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{5}
}

func (x *GameDocumentEvent) GetDoc() *GameDocument {
	if x != nil {
		return x.Doc
	}
	return nil
}

type TournamentDataForGame struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the tournament
	Tid           string `protobuf:"bytes,1,opt,name=tid,proto3" json:"tid,omitempty"`
	Division      string `protobuf:"bytes,2,opt,name=division,proto3" json:"division,omitempty"`
	Round         int32  `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	GameIndex     int32  `protobuf:"varint,4,opt,name=game_index,json=gameIndex,proto3" json:"game_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TournamentDataForGame) Reset() {
	*x = TournamentDataForGame{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TournamentDataForGame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TournamentDataForGame) ProtoMessage() {}

func (x *TournamentDataForGame) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TournamentDataForGame.ProtoReflect.Descriptor instead.
func (*TournamentDataForGame) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{6}
}

func (x *TournamentDataForGame) GetTid() string {
	if x != nil {
		return x.Tid
	}
	return ""
}

func (x *TournamentDataForGame) GetDivision() string {
	if x != nil {
		return x.Division
	}
	return ""
}

func (x *TournamentDataForGame) GetRound() int32 {
	if x != nil {
		return x.Round
	}
	return 0
}

func (x *TournamentDataForGame) GetGameIndex() int32 {
	if x != nil {
		return x.GameIndex
	}
	return 0
}

// Meta information about the player of a particular game.
type PlayerInfo struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	UserId      string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Nickname    string                 `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	FullName    string                 `protobuf:"bytes,3,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	CountryCode string                 `protobuf:"bytes,4,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty"`
	// Rating for the particular mode of the game. String because it could be
	// provisional or some other strings.
	Rating string `protobuf:"bytes,5,opt,name=rating,proto3" json:"rating,omitempty"`
	Title  string `protobuf:"bytes,6,opt,name=title,proto3" json:"title,omitempty"`
	// string avatar_url = 7; // the UserService now offers Avatar info
	IsBot bool `protobuf:"varint,8,opt,name=is_bot,json=isBot,proto3" json:"is_bot,omitempty"`
	// first is true if the player went first. This is deprecated because it
	// is assumed the player listed first went first.
	//
	// Deprecated: Marked as deprecated in proto/ipc/omgwords.proto.
	First         bool `protobuf:"varint,9,opt,name=first,proto3" json:"first,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlayerInfo) Reset() {
	*x = PlayerInfo{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlayerInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlayerInfo) ProtoMessage() {}

func (x *PlayerInfo) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlayerInfo.ProtoReflect.Descriptor instead.
func (*PlayerInfo) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{7}
}

func (x *PlayerInfo) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *PlayerInfo) GetNickname() string {
	if x != nil {
		return x.Nickname
	}
	return ""
}

func (x *PlayerInfo) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *PlayerInfo) GetCountryCode() string {
	if x != nil {
		return x.CountryCode
	}
	return ""
}

func (x *PlayerInfo) GetRating() string {
	if x != nil {
		return x.Rating
	}
	return ""
}

func (x *PlayerInfo) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *PlayerInfo) GetIsBot() bool {
	if x != nil {
		return x.IsBot
	}
	return false
}

// Deprecated: Marked as deprecated in proto/ipc/omgwords.proto.
func (x *PlayerInfo) GetFirst() bool {
	if x != nil {
		return x.First
	}
	return false
}

type GameInfoResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Players         []*PlayerInfo          `protobuf:"bytes,1,rep,name=players,proto3" json:"players,omitempty"`
	TimeControlName string                 `protobuf:"bytes,4,opt,name=time_control_name,json=timeControlName,proto3" json:"time_control_name,omitempty"`
	TournamentId    string                 `protobuf:"bytes,6,opt,name=tournament_id,json=tournamentId,proto3" json:"tournament_id,omitempty"`
	// done - is game done?
	// bool done = 9;
	GameEndReason      GameEndReason          `protobuf:"varint,11,opt,name=game_end_reason,json=gameEndReason,proto3,enum=ipc.GameEndReason" json:"game_end_reason,omitempty"`
	Scores             []int32                `protobuf:"varint,13,rep,packed,name=scores,proto3" json:"scores,omitempty"`
	Winner             int32                  `protobuf:"varint,14,opt,name=winner,proto3" json:"winner,omitempty"`
	CreatedAt          *timestamppb.Timestamp `protobuf:"bytes,15,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	GameId             string                 `protobuf:"bytes,16,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	LastUpdate         *timestamppb.Timestamp `protobuf:"bytes,18,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	GameRequest        *GameRequest           `protobuf:"bytes,19,opt,name=game_request,json=gameRequest,proto3" json:"game_request,omitempty"`
	TournamentDivision string                 `protobuf:"bytes,20,opt,name=tournament_division,json=tournamentDivision,proto3" json:"tournament_division,omitempty"`
	TournamentRound    int32                  `protobuf:"varint,21,opt,name=tournament_round,json=tournamentRound,proto3" json:"tournament_round,omitempty"`
	// a game index within a round.
	TournamentGameIndex int32    `protobuf:"varint,22,opt,name=tournament_game_index,json=tournamentGameIndex,proto3" json:"tournament_game_index,omitempty"`
	Type                GameType `protobuf:"varint,23,opt,name=type,proto3,enum=ipc.GameType" json:"type,omitempty"`
	// Index of the player whose turn it is (0 or 1). Optional for backwards compatibility.
	PlayerOnTurn  *uint32 `protobuf:"varint,24,opt,name=player_on_turn,json=playerOnTurn,proto3,oneof" json:"player_on_turn,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameInfoResponse) Reset() {
	*x = GameInfoResponse{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameInfoResponse) ProtoMessage() {}

func (x *GameInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameInfoResponse.ProtoReflect.Descriptor instead.
func (*GameInfoResponse) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{8}
}

func (x *GameInfoResponse) GetPlayers() []*PlayerInfo {
	if x != nil {
		return x.Players
	}
	return nil
}

func (x *GameInfoResponse) GetTimeControlName() string {
	if x != nil {
		return x.TimeControlName
	}
	return ""
}

func (x *GameInfoResponse) GetTournamentId() string {
	if x != nil {
		return x.TournamentId
	}
	return ""
}

func (x *GameInfoResponse) GetGameEndReason() GameEndReason {
	if x != nil {
		return x.GameEndReason
	}
	return GameEndReason_NONE
}

func (x *GameInfoResponse) GetScores() []int32 {
	if x != nil {
		return x.Scores
	}
	return nil
}

func (x *GameInfoResponse) GetWinner() int32 {
	if x != nil {
		return x.Winner
	}
	return 0
}

func (x *GameInfoResponse) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *GameInfoResponse) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

func (x *GameInfoResponse) GetLastUpdate() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUpdate
	}
	return nil
}

func (x *GameInfoResponse) GetGameRequest() *GameRequest {
	if x != nil {
		return x.GameRequest
	}
	return nil
}

func (x *GameInfoResponse) GetTournamentDivision() string {
	if x != nil {
		return x.TournamentDivision
	}
	return ""
}

func (x *GameInfoResponse) GetTournamentRound() int32 {
	if x != nil {
		return x.TournamentRound
	}
	return 0
}

func (x *GameInfoResponse) GetTournamentGameIndex() int32 {
	if x != nil {
		return x.TournamentGameIndex
	}
	return 0
}

func (x *GameInfoResponse) GetType() GameType {
	if x != nil {
		return x.Type
	}
	return GameType_NATIVE
}

func (x *GameInfoResponse) GetPlayerOnTurn() uint32 {
	if x != nil && x.PlayerOnTurn != nil {
		return *x.PlayerOnTurn
	}
	return 0
}

type GameInfoResponses struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GameInfo      []*GameInfoResponse    `protobuf:"bytes,1,rep,name=game_info,json=gameInfo,proto3" json:"game_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameInfoResponses) Reset() {
	*x = GameInfoResponses{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameInfoResponses) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameInfoResponses) ProtoMessage() {}

func (x *GameInfoResponses) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameInfoResponses.ProtoReflect.Descriptor instead.
func (*GameInfoResponses) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{9}
}

func (x *GameInfoResponses) GetGameInfo() []*GameInfoResponse {
	if x != nil {
		return x.GameInfo
	}
	return nil
}

// InstantiateGame is an internal message passed to gamesvc in order to
// instantiate a game.
type InstantiateGame struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	UserIds     []string               `protobuf:"bytes,1,rep,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
	GameRequest *GameRequest           `protobuf:"bytes,2,opt,name=game_request,json=gameRequest,proto3" json:"game_request,omitempty"`
	// assigned_first is -1 if random, or the player index in user_ids otherwise
	AssignedFirst  int32                  `protobuf:"varint,3,opt,name=assigned_first,json=assignedFirst,proto3" json:"assigned_first,omitempty"`
	TournamentData *TournamentDataForGame `protobuf:"bytes,4,opt,name=tournament_data,json=tournamentData,proto3" json:"tournament_data,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *InstantiateGame) Reset() {
	*x = InstantiateGame{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstantiateGame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstantiateGame) ProtoMessage() {}

func (x *InstantiateGame) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstantiateGame.ProtoReflect.Descriptor instead.
func (*InstantiateGame) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{10}
}

func (x *InstantiateGame) GetUserIds() []string {
	if x != nil {
		return x.UserIds
	}
	return nil
}

func (x *InstantiateGame) GetGameRequest() *GameRequest {
	if x != nil {
		return x.GameRequest
	}
	return nil
}

func (x *InstantiateGame) GetAssignedFirst() int32 {
	if x != nil {
		return x.AssignedFirst
	}
	return 0
}

func (x *InstantiateGame) GetTournamentData() *TournamentDataForGame {
	if x != nil {
		return x.TournamentData
	}
	return nil
}

type GameDeletion struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameDeletion) Reset() {
	*x = GameDeletion{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameDeletion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameDeletion) ProtoMessage() {}

func (x *GameDeletion) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameDeletion.ProtoReflect.Descriptor instead.
func (*GameDeletion) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{11}
}

func (x *GameDeletion) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type ActiveGamePlayer struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	UserId        string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ActiveGamePlayer) Reset() {
	*x = ActiveGamePlayer{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActiveGamePlayer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActiveGamePlayer) ProtoMessage() {}

func (x *ActiveGamePlayer) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActiveGamePlayer.ProtoReflect.Descriptor instead.
func (*ActiveGamePlayer) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{12}
}

func (x *ActiveGamePlayer) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *ActiveGamePlayer) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

type ActiveGameEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Player        []*ActiveGamePlayer    `protobuf:"bytes,2,rep,name=player,proto3" json:"player,omitempty"`
	Ttl           int64                  `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"` // time to live, in seconds
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ActiveGameEntry) Reset() {
	*x = ActiveGameEntry{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActiveGameEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActiveGameEntry) ProtoMessage() {}

func (x *ActiveGameEntry) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActiveGameEntry.ProtoReflect.Descriptor instead.
func (*ActiveGameEntry) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{13}
}

func (x *ActiveGameEntry) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ActiveGameEntry) GetPlayer() []*ActiveGamePlayer {
	if x != nil {
		return x.Player
	}
	return nil
}

func (x *ActiveGameEntry) GetTtl() int64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

type ReadyForGame struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GameId        string                 `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadyForGame) Reset() {
	*x = ReadyForGame{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadyForGame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadyForGame) ProtoMessage() {}

func (x *ReadyForGame) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadyForGame.ProtoReflect.Descriptor instead.
func (*ReadyForGame) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{14}
}

func (x *ReadyForGame) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

// The server will send back a ServerGameplayEvent to a ClientGameplayEvent.
// The server will also send these asynchronously for opponent gameplay
// events.
// XXX: This message type is obsolete and will be replaced by
// ServerOMGWordsEvent
type ServerGameplayEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Event         *macondo.GameEvent     `protobuf:"bytes,1,opt,name=event,proto3" json:"event,omitempty"` // XXX: move to ipc.GameEvent
	GameId        string                 `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	NewRack       string                 `protobuf:"bytes,3,opt,name=new_rack,json=newRack,proto3" json:"new_rack,omitempty"`
	TimeRemaining int32                  `protobuf:"varint,4,opt,name=time_remaining,json=timeRemaining,proto3" json:"time_remaining,omitempty"`
	Playing       macondo.PlayState      `protobuf:"varint,5,opt,name=playing,proto3,enum=macondo.PlayState" json:"playing,omitempty"` // XXX: move to ipc.PlayState
	UserId        string                 `protobuf:"bytes,6,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`             // the event has the nickname, but not the userid.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerGameplayEvent) Reset() {
	*x = ServerGameplayEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerGameplayEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerGameplayEvent) ProtoMessage() {}

func (x *ServerGameplayEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerGameplayEvent.ProtoReflect.Descriptor instead.
func (*ServerGameplayEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{15}
}

func (x *ServerGameplayEvent) GetEvent() *macondo.GameEvent {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *ServerGameplayEvent) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

func (x *ServerGameplayEvent) GetNewRack() string {
	if x != nil {
		return x.NewRack
	}
	return ""
}

func (x *ServerGameplayEvent) GetTimeRemaining() int32 {
	if x != nil {
		return x.TimeRemaining
	}
	return 0
}

func (x *ServerGameplayEvent) GetPlaying() macondo.PlayState {
	if x != nil {
		return x.Playing
	}
	return macondo.PlayState(0)
}

func (x *ServerGameplayEvent) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

// ServerOMGWordsEvent is a new event type.
type ServerOMGWordsEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Event         *GameEvent             `protobuf:"bytes,1,opt,name=event,proto3" json:"event,omitempty"`
	GameId        string                 `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	NewRack       []byte                 `protobuf:"bytes,3,opt,name=new_rack,json=newRack,proto3" json:"new_rack,omitempty"`
	TimeRemaining int32                  `protobuf:"varint,4,opt,name=time_remaining,json=timeRemaining,proto3" json:"time_remaining,omitempty"`
	Playing       PlayState              `protobuf:"varint,5,opt,name=playing,proto3,enum=ipc.PlayState" json:"playing,omitempty"`
	UserId        string                 `protobuf:"bytes,6,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerOMGWordsEvent) Reset() {
	*x = ServerOMGWordsEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerOMGWordsEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerOMGWordsEvent) ProtoMessage() {}

func (x *ServerOMGWordsEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerOMGWordsEvent.ProtoReflect.Descriptor instead.
func (*ServerOMGWordsEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{16}
}

func (x *ServerOMGWordsEvent) GetEvent() *GameEvent {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *ServerOMGWordsEvent) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

func (x *ServerOMGWordsEvent) GetNewRack() []byte {
	if x != nil {
		return x.NewRack
	}
	return nil
}

func (x *ServerOMGWordsEvent) GetTimeRemaining() int32 {
	if x != nil {
		return x.TimeRemaining
	}
	return 0
}

func (x *ServerOMGWordsEvent) GetPlaying() PlayState {
	if x != nil {
		return x.Playing
	}
	return PlayState_PLAYING
}

func (x *ServerOMGWordsEvent) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

// The server will send back a challenge result event only in the case of
// a challenge. In all other cases, the server will send back a
// ServerGameplayEvent.
// A ServerChallengeResultEvent is sent back along with a list of
// ServerGameplayEvents, instead of trying to reconstruct and send the
// right incremental events. The reason is that the logic is complex and
// has many special cases, and is already fully implemented in Macondo.
// We don't wish to re-implement it both in this repo's backend and frontend.
// XXX: This message type is obsolete, and will be replaced by
// OMGWordsChallengeResultEvent
type ServerChallengeResultEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Valid         bool                   `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	Challenger    string                 `protobuf:"bytes,2,opt,name=challenger,proto3" json:"challenger,omitempty"`
	ChallengeRule macondo.ChallengeRule  `protobuf:"varint,3,opt,name=challenge_rule,json=challengeRule,proto3,enum=macondo.ChallengeRule" json:"challenge_rule,omitempty"`
	ReturnedTiles string                 `protobuf:"bytes,4,opt,name=returned_tiles,json=returnedTiles,proto3" json:"returned_tiles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerChallengeResultEvent) Reset() {
	*x = ServerChallengeResultEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerChallengeResultEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerChallengeResultEvent) ProtoMessage() {}

func (x *ServerChallengeResultEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerChallengeResultEvent.ProtoReflect.Descriptor instead.
func (*ServerChallengeResultEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{17}
}

func (x *ServerChallengeResultEvent) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *ServerChallengeResultEvent) GetChallenger() string {
	if x != nil {
		return x.Challenger
	}
	return ""
}

func (x *ServerChallengeResultEvent) GetChallengeRule() macondo.ChallengeRule {
	if x != nil {
		return x.ChallengeRule
	}
	return macondo.ChallengeRule(0)
}

func (x *ServerChallengeResultEvent) GetReturnedTiles() string {
	if x != nil {
		return x.ReturnedTiles
	}
	return ""
}

type OMGWordsChallengeResultEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Valid         bool                   `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	Challenger    string                 `protobuf:"bytes,2,opt,name=challenger,proto3" json:"challenger,omitempty"`
	ChallengeRule ChallengeRule          `protobuf:"varint,3,opt,name=challenge_rule,json=challengeRule,proto3,enum=ipc.ChallengeRule" json:"challenge_rule,omitempty"`
	ReturnedTiles []byte                 `protobuf:"bytes,4,opt,name=returned_tiles,json=returnedTiles,proto3" json:"returned_tiles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OMGWordsChallengeResultEvent) Reset() {
	*x = OMGWordsChallengeResultEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OMGWordsChallengeResultEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OMGWordsChallengeResultEvent) ProtoMessage() {}

func (x *OMGWordsChallengeResultEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OMGWordsChallengeResultEvent.ProtoReflect.Descriptor instead.
func (*OMGWordsChallengeResultEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{18}
}

func (x *OMGWordsChallengeResultEvent) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *OMGWordsChallengeResultEvent) GetChallenger() string {
	if x != nil {
		return x.Challenger
	}
	return ""
}

func (x *OMGWordsChallengeResultEvent) GetChallengeRule() ChallengeRule {
	if x != nil {
		return x.ChallengeRule
	}
	return ChallengeRule_ChallengeRule_VOID
}

func (x *OMGWordsChallengeResultEvent) GetReturnedTiles() []byte {
	if x != nil {
		return x.ReturnedTiles
	}
	return nil
}

// GameEndedEvent is always sent from the server to both clients.
type GameEndedEvent struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Scores     map[string]int32       `protobuf:"bytes,1,rep,name=scores,proto3" json:"scores,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	NewRatings map[string]int32       `protobuf:"bytes,2,rep,name=new_ratings,json=newRatings,proto3" json:"new_ratings,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	EndReason  GameEndReason          `protobuf:"varint,3,opt,name=end_reason,json=endReason,proto3,enum=ipc.GameEndReason" json:"end_reason,omitempty"`
	// The winner is not always the highest scoring player; one player can
	// time out. The end_reason should make it clear what happened.
	Winner string `protobuf:"bytes,4,opt,name=winner,proto3" json:"winner,omitempty"`
	Loser  string `protobuf:"bytes,5,opt,name=loser,proto3" json:"loser,omitempty"`
	// If it was a tie, the winner and loser above can be interchanged.
	Tie bool `protobuf:"varint,6,opt,name=tie,proto3" json:"tie,omitempty"`
	// Time that the game ended
	Time         int64            `protobuf:"varint,7,opt,name=time,proto3" json:"time,omitempty"`
	RatingDeltas map[string]int32 `protobuf:"bytes,8,rep,name=rating_deltas,json=ratingDeltas,proto3" json:"rating_deltas,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// Send the full game history again. This will have rack information in it.
	History       *macondo.GameHistory `protobuf:"bytes,9,opt,name=history,proto3" json:"history,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameEndedEvent) Reset() {
	*x = GameEndedEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameEndedEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameEndedEvent) ProtoMessage() {}

func (x *GameEndedEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameEndedEvent.ProtoReflect.Descriptor instead.
func (*GameEndedEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{19}
}

func (x *GameEndedEvent) GetScores() map[string]int32 {
	if x != nil {
		return x.Scores
	}
	return nil
}

func (x *GameEndedEvent) GetNewRatings() map[string]int32 {
	if x != nil {
		return x.NewRatings
	}
	return nil
}

func (x *GameEndedEvent) GetEndReason() GameEndReason {
	if x != nil {
		return x.EndReason
	}
	return GameEndReason_NONE
}

func (x *GameEndedEvent) GetWinner() string {
	if x != nil {
		return x.Winner
	}
	return ""
}

func (x *GameEndedEvent) GetLoser() string {
	if x != nil {
		return x.Loser
	}
	return ""
}

func (x *GameEndedEvent) GetTie() bool {
	if x != nil {
		return x.Tie
	}
	return false
}

func (x *GameEndedEvent) GetTime() int64 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *GameEndedEvent) GetRatingDeltas() map[string]int32 {
	if x != nil {
		return x.RatingDeltas
	}
	return nil
}

func (x *GameEndedEvent) GetHistory() *macondo.GameHistory {
	if x != nil {
		return x.History
	}
	return nil
}

// RematchStartedEvent gets sent to a game for which there is a rematch.
// It notifies that observers of the game that a rematch has started.
type RematchStartedEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// rematch_game_id is the new game ID.
	RematchGameId string `protobuf:"bytes,1,opt,name=rematch_game_id,json=rematchGameId,proto3" json:"rematch_game_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RematchStartedEvent) Reset() {
	*x = RematchStartedEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RematchStartedEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RematchStartedEvent) ProtoMessage() {}

func (x *RematchStartedEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RematchStartedEvent.ProtoReflect.Descriptor instead.
func (*RematchStartedEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{20}
}

func (x *RematchStartedEvent) GetRematchGameId() string {
	if x != nil {
		return x.RematchGameId
	}
	return ""
}

// A NewGameEvent gets sent from the server to the involved clients when a new
// game is about to begin. It should follow a SoughtGameProcessEvent.
type NewGameEvent struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	GameId string                 `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	// These are the connection IDs of the requesting and accepting users.
	RequesterCid  string `protobuf:"bytes,2,opt,name=requester_cid,json=requesterCid,proto3" json:"requester_cid,omitempty"`
	AccepterCid   string `protobuf:"bytes,3,opt,name=accepter_cid,json=accepterCid,proto3" json:"accepter_cid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NewGameEvent) Reset() {
	*x = NewGameEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NewGameEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewGameEvent) ProtoMessage() {}

func (x *NewGameEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewGameEvent.ProtoReflect.Descriptor instead.
func (*NewGameEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{21}
}

func (x *NewGameEvent) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

func (x *NewGameEvent) GetRequesterCid() string {
	if x != nil {
		return x.RequesterCid
	}
	return ""
}

func (x *NewGameEvent) GetAccepterCid() string {
	if x != nil {
		return x.AccepterCid
	}
	return ""
}

type TimedOut struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GameId        string                 `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	UserId        string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimedOut) Reset() {
	*x = TimedOut{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimedOut) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimedOut) ProtoMessage() {}

func (x *TimedOut) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimedOut.ProtoReflect.Descriptor instead.
func (*TimedOut) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{22}
}

func (x *TimedOut) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

func (x *TimedOut) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

// GameEvent is an internal game event, saved in the GameDocument.
type GameEvent struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Note        string                 `protobuf:"bytes,2,opt,name=note,proto3" json:"note,omitempty"`
	Rack        []byte                 `protobuf:"bytes,3,opt,name=rack,proto3" json:"rack,omitempty"`
	Type        GameEvent_Type         `protobuf:"varint,4,opt,name=type,proto3,enum=ipc.GameEvent_Type" json:"type,omitempty"`
	Cumulative  int32                  `protobuf:"varint,5,opt,name=cumulative,proto3" json:"cumulative,omitempty"`
	Row         int32                  `protobuf:"varint,6,opt,name=row,proto3" json:"row,omitempty"`
	Column      int32                  `protobuf:"varint,7,opt,name=column,proto3" json:"column,omitempty"`
	Direction   GameEvent_Direction    `protobuf:"varint,8,opt,name=direction,proto3,enum=ipc.GameEvent_Direction" json:"direction,omitempty"`
	Position    string                 `protobuf:"bytes,9,opt,name=position,proto3" json:"position,omitempty"`
	PlayedTiles []byte                 `protobuf:"bytes,10,opt,name=played_tiles,json=playedTiles,proto3" json:"played_tiles,omitempty"`
	// An event will not have all of these; it depends on the type of the event.
	Exchanged     []byte `protobuf:"bytes,11,opt,name=exchanged,proto3" json:"exchanged,omitempty"`
	Score         int32  `protobuf:"varint,12,opt,name=score,proto3" json:"score,omitempty"`
	Bonus         int32  `protobuf:"varint,13,opt,name=bonus,proto3" json:"bonus,omitempty"`
	EndRackPoints int32  `protobuf:"varint,14,opt,name=end_rack_points,json=endRackPoints,proto3" json:"end_rack_points,omitempty"`
	LostScore     int32  `protobuf:"varint,15,opt,name=lost_score,json=lostScore,proto3" json:"lost_score,omitempty"`
	IsBingo       bool   `protobuf:"varint,16,opt,name=is_bingo,json=isBingo,proto3" json:"is_bingo,omitempty"`
	// words_formed is a list of all words made by this play
	WordsFormed     [][]byte `protobuf:"bytes,17,rep,name=words_formed,json=wordsFormed,proto3" json:"words_formed,omitempty"`
	MillisRemaining int32    `protobuf:"varint,18,opt,name=millis_remaining,json=millisRemaining,proto3" json:"millis_remaining,omitempty"`
	// The player who played this move is encoded in player_index. This should
	// be the index in GameDocument.players.
	PlayerIndex         uint32   `protobuf:"varint,19,opt,name=player_index,json=playerIndex,proto3" json:"player_index,omitempty"`
	WordsFormedFriendly []string `protobuf:"bytes,20,rep,name=words_formed_friendly,json=wordsFormedFriendly,proto3" json:"words_formed_friendly,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *GameEvent) Reset() {
	*x = GameEvent{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameEvent) ProtoMessage() {}

func (x *GameEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameEvent.ProtoReflect.Descriptor instead.
func (*GameEvent) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{23}
}

func (x *GameEvent) GetNote() string {
	if x != nil {
		return x.Note
	}
	return ""
}

func (x *GameEvent) GetRack() []byte {
	if x != nil {
		return x.Rack
	}
	return nil
}

func (x *GameEvent) GetType() GameEvent_Type {
	if x != nil {
		return x.Type
	}
	return GameEvent_TILE_PLACEMENT_MOVE
}

func (x *GameEvent) GetCumulative() int32 {
	if x != nil {
		return x.Cumulative
	}
	return 0
}

func (x *GameEvent) GetRow() int32 {
	if x != nil {
		return x.Row
	}
	return 0
}

func (x *GameEvent) GetColumn() int32 {
	if x != nil {
		return x.Column
	}
	return 0
}

func (x *GameEvent) GetDirection() GameEvent_Direction {
	if x != nil {
		return x.Direction
	}
	return GameEvent_HORIZONTAL
}

func (x *GameEvent) GetPosition() string {
	if x != nil {
		return x.Position
	}
	return ""
}

func (x *GameEvent) GetPlayedTiles() []byte {
	if x != nil {
		return x.PlayedTiles
	}
	return nil
}

func (x *GameEvent) GetExchanged() []byte {
	if x != nil {
		return x.Exchanged
	}
	return nil
}

func (x *GameEvent) GetScore() int32 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *GameEvent) GetBonus() int32 {
	if x != nil {
		return x.Bonus
	}
	return 0
}

func (x *GameEvent) GetEndRackPoints() int32 {
	if x != nil {
		return x.EndRackPoints
	}
	return 0
}

func (x *GameEvent) GetLostScore() int32 {
	if x != nil {
		return x.LostScore
	}
	return 0
}

func (x *GameEvent) GetIsBingo() bool {
	if x != nil {
		return x.IsBingo
	}
	return false
}

func (x *GameEvent) GetWordsFormed() [][]byte {
	if x != nil {
		return x.WordsFormed
	}
	return nil
}

func (x *GameEvent) GetMillisRemaining() int32 {
	if x != nil {
		return x.MillisRemaining
	}
	return 0
}

func (x *GameEvent) GetPlayerIndex() uint32 {
	if x != nil {
		return x.PlayerIndex
	}
	return 0
}

func (x *GameEvent) GetWordsFormedFriendly() []string {
	if x != nil {
		return x.WordsFormedFriendly
	}
	return nil
}

type Timers struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// time_of_last_update is the timestamp of the last update, in milliseconds
	// If no update has been made, this defaults to timeStarted.
	TimeOfLastUpdate int64 `protobuf:"varint,1,opt,name=time_of_last_update,json=timeOfLastUpdate,proto3" json:"time_of_last_update,omitempty"`
	// time_started is a unix timestamp, in milliseconds.
	TimeStarted int64 `protobuf:"varint,2,opt,name=time_started,json=timeStarted,proto3" json:"time_started,omitempty"`
	// time_remaining is an array of remaining time per player, in milliseconds
	TimeRemaining []int64 `protobuf:"varint,3,rep,packed,name=time_remaining,json=timeRemaining,proto3" json:"time_remaining,omitempty"`
	// max_overtime is the number of minutes that the game is allowed to go
	// overtime
	MaxOvertime int32 `protobuf:"varint,4,opt,name=max_overtime,json=maxOvertime,proto3" json:"max_overtime,omitempty"`
	// increment_seconds is the amount of seconds that is added to the timer
	// after every move
	IncrementSeconds int32 `protobuf:"varint,5,opt,name=increment_seconds,json=incrementSeconds,proto3" json:"increment_seconds,omitempty"`
	// reset_to_increment_after_turn sets the timer for the player to
	// increment_seconds. this can be used for correspondence games; for example,
	// time_remaining and increment_seconds can be set to the same number of
	// seconds (let's say 5 days) at the beginning, and this flag can be set to
	// on. Then we should always have 5 days to make any move.
	ResetToIncrementAfterTurn bool `protobuf:"varint,6,opt,name=reset_to_increment_after_turn,json=resetToIncrementAfterTurn,proto3" json:"reset_to_increment_after_turn,omitempty"`
	// If untimed is true, then Timers are not updated at all.
	Untimed bool `protobuf:"varint,7,opt,name=untimed,proto3" json:"untimed,omitempty"`
	// time_bank is an array of time bank per player, in milliseconds.
	// Used for correspondence/league games. Once time_remaining reaches 0,
	// time is deducted from time_bank. Player only loses when both are exhausted.
	TimeBank      []int64 `protobuf:"varint,8,rep,packed,name=time_bank,json=timeBank,proto3" json:"time_bank,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Timers) Reset() {
	*x = Timers{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Timers) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Timers) ProtoMessage() {}

func (x *Timers) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Timers.ProtoReflect.Descriptor instead.
func (*Timers) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{24}
}

func (x *Timers) GetTimeOfLastUpdate() int64 {
	if x != nil {
		return x.TimeOfLastUpdate
	}
	return 0
}

func (x *Timers) GetTimeStarted() int64 {
	if x != nil {
		return x.TimeStarted
	}
	return 0
}

func (x *Timers) GetTimeRemaining() []int64 {
	if x != nil {
		return x.TimeRemaining
	}
	return nil
}

func (x *Timers) GetMaxOvertime() int32 {
	if x != nil {
		return x.MaxOvertime
	}
	return 0
}

func (x *Timers) GetIncrementSeconds() int32 {
	if x != nil {
		return x.IncrementSeconds
	}
	return 0
}

func (x *Timers) GetResetToIncrementAfterTurn() bool {
	if x != nil {
		return x.ResetToIncrementAfterTurn
	}
	return false
}

func (x *Timers) GetUntimed() bool {
	if x != nil {
		return x.Untimed
	}
	return false
}

func (x *Timers) GetTimeBank() []int64 {
	if x != nil {
		return x.TimeBank
	}
	return nil
}

type MetaEventData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Events        []*GameMetaEvent       `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MetaEventData) Reset() {
	*x = MetaEventData{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetaEventData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetaEventData) ProtoMessage() {}

func (x *MetaEventData) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetaEventData.ProtoReflect.Descriptor instead.
func (*MetaEventData) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{25}
}

func (x *MetaEventData) GetEvents() []*GameMetaEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

type GameBoard struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	NumRows int32                  `protobuf:"varint,1,opt,name=num_rows,json=numRows,proto3" json:"num_rows,omitempty"`
	NumCols int32                  `protobuf:"varint,2,opt,name=num_cols,json=numCols,proto3" json:"num_cols,omitempty"`
	// tiles are laid out in row-major form
	Tiles         []byte `protobuf:"bytes,3,opt,name=tiles,proto3" json:"tiles,omitempty"`
	IsEmpty       bool   `protobuf:"varint,4,opt,name=is_empty,json=isEmpty,proto3" json:"is_empty,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameBoard) Reset() {
	*x = GameBoard{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameBoard) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameBoard) ProtoMessage() {}

func (x *GameBoard) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameBoard.ProtoReflect.Descriptor instead.
func (*GameBoard) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{26}
}

func (x *GameBoard) GetNumRows() int32 {
	if x != nil {
		return x.NumRows
	}
	return 0
}

func (x *GameBoard) GetNumCols() int32 {
	if x != nil {
		return x.NumCols
	}
	return 0
}

func (x *GameBoard) GetTiles() []byte {
	if x != nil {
		return x.Tiles
	}
	return nil
}

func (x *GameBoard) GetIsEmpty() bool {
	if x != nil {
		return x.IsEmpty
	}
	return false
}

type Bag struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tiles         []byte                 `protobuf:"bytes,1,opt,name=tiles,proto3" json:"tiles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Bag) Reset() {
	*x = Bag{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Bag) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Bag) ProtoMessage() {}

func (x *Bag) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Bag.ProtoReflect.Descriptor instead.
func (*Bag) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{27}
}

func (x *Bag) GetTiles() []byte {
	if x != nil {
		return x.Tiles
	}
	return nil
}

// A GameDocument encodes the entire state of a game. It includes a history
// of events, as well as information about the current state of the bag,
// timers, etc. It should be possible to recreate an entire omgwords game
// from a GameDocument state at any given time.
type GameDocument struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// players are in order of who went first.
	Players       []*GameDocument_MinimalPlayerInfo `protobuf:"bytes,1,rep,name=players,proto3" json:"players,omitempty"`
	Events        []*GameEvent                      `protobuf:"bytes,2,rep,name=events,proto3" json:"events,omitempty"`
	Version       uint32                            `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	Lexicon       string                            `protobuf:"bytes,4,opt,name=lexicon,proto3" json:"lexicon,omitempty"`
	Uid           string                            `protobuf:"bytes,5,opt,name=uid,proto3" json:"uid,omitempty"`
	Description   string                            `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	Racks         [][]byte                          `protobuf:"bytes,7,rep,name=racks,proto3" json:"racks,omitempty"`
	ChallengeRule ChallengeRule                     `protobuf:"varint,8,opt,name=challenge_rule,json=challengeRule,proto3,enum=ipc.ChallengeRule" json:"challenge_rule,omitempty"`
	PlayState     PlayState                         `protobuf:"varint,9,opt,name=play_state,json=playState,proto3,enum=ipc.PlayState" json:"play_state,omitempty"`
	CurrentScores []int32                           `protobuf:"varint,10,rep,packed,name=current_scores,json=currentScores,proto3" json:"current_scores,omitempty"`
	Variant       string                            `protobuf:"bytes,11,opt,name=variant,proto3" json:"variant,omitempty"`
	// The index of the player who won, or -1 if it was a tie.
	Winner int32 `protobuf:"varint,12,opt,name=winner,proto3" json:"winner,omitempty"`
	// The board layout is just the name for the layout of the board.
	// It should have a sensible default, if blank.
	BoardLayout string `protobuf:"bytes,13,opt,name=board_layout,json=boardLayout,proto3" json:"board_layout,omitempty"`
	// The letter distribution is the name of the distribution of tiles used for
	// this game. If blank, should default to "english".
	LetterDistribution string                 `protobuf:"bytes,14,opt,name=letter_distribution,json=letterDistribution,proto3" json:"letter_distribution,omitempty"`
	Type               GameType               `protobuf:"varint,15,opt,name=type,proto3,enum=ipc.GameType" json:"type,omitempty"`
	TimersStarted      bool                   `protobuf:"varint,16,opt,name=timers_started,json=timersStarted,proto3" json:"timers_started,omitempty"`
	EndReason          GameEndReason          `protobuf:"varint,17,opt,name=end_reason,json=endReason,proto3,enum=ipc.GameEndReason" json:"end_reason,omitempty"`
	MetaEventData      *MetaEventData         `protobuf:"bytes,18,opt,name=meta_event_data,json=metaEventData,proto3" json:"meta_event_data,omitempty"`
	CreatedAt          *timestamppb.Timestamp `protobuf:"bytes,19,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// gameplay-specific structures:
	// board is the current state of the board
	Board *GameBoard `protobuf:"bytes,20,opt,name=board,proto3" json:"board,omitempty"`
	// bag is the current tiles in the bag.
	Bag            *Bag   `protobuf:"bytes,21,opt,name=bag,proto3" json:"bag,omitempty"`
	ScorelessTurns uint32 `protobuf:"varint,22,opt,name=scoreless_turns,json=scorelessTurns,proto3" json:"scoreless_turns,omitempty"`
	// The index of the player on turn
	PlayerOnTurn  uint32  `protobuf:"varint,23,opt,name=player_on_turn,json=playerOnTurn,proto3" json:"player_on_turn,omitempty"`
	Timers        *Timers `protobuf:"bytes,24,opt,name=timers,proto3" json:"timers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameDocument) Reset() {
	*x = GameDocument{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameDocument) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameDocument) ProtoMessage() {}

func (x *GameDocument) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameDocument.ProtoReflect.Descriptor instead.
func (*GameDocument) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{28}
}

func (x *GameDocument) GetPlayers() []*GameDocument_MinimalPlayerInfo {
	if x != nil {
		return x.Players
	}
	return nil
}

func (x *GameDocument) GetEvents() []*GameEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

func (x *GameDocument) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *GameDocument) GetLexicon() string {
	if x != nil {
		return x.Lexicon
	}
	return ""
}

func (x *GameDocument) GetUid() string {
	if x != nil {
		return x.Uid
	}
	return ""
}

func (x *GameDocument) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *GameDocument) GetRacks() [][]byte {
	if x != nil {
		return x.Racks
	}
	return nil
}

func (x *GameDocument) GetChallengeRule() ChallengeRule {
	if x != nil {
		return x.ChallengeRule
	}
	return ChallengeRule_ChallengeRule_VOID
}

func (x *GameDocument) GetPlayState() PlayState {
	if x != nil {
		return x.PlayState
	}
	return PlayState_PLAYING
}

func (x *GameDocument) GetCurrentScores() []int32 {
	if x != nil {
		return x.CurrentScores
	}
	return nil
}

func (x *GameDocument) GetVariant() string {
	if x != nil {
		return x.Variant
	}
	return ""
}

func (x *GameDocument) GetWinner() int32 {
	if x != nil {
		return x.Winner
	}
	return 0
}

func (x *GameDocument) GetBoardLayout() string {
	if x != nil {
		return x.BoardLayout
	}
	return ""
}

func (x *GameDocument) GetLetterDistribution() string {
	if x != nil {
		return x.LetterDistribution
	}
	return ""
}

func (x *GameDocument) GetType() GameType {
	if x != nil {
		return x.Type
	}
	return GameType_NATIVE
}

func (x *GameDocument) GetTimersStarted() bool {
	if x != nil {
		return x.TimersStarted
	}
	return false
}

func (x *GameDocument) GetEndReason() GameEndReason {
	if x != nil {
		return x.EndReason
	}
	return GameEndReason_NONE
}

func (x *GameDocument) GetMetaEventData() *MetaEventData {
	if x != nil {
		return x.MetaEventData
	}
	return nil
}

func (x *GameDocument) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *GameDocument) GetBoard() *GameBoard {
	if x != nil {
		return x.Board
	}
	return nil
}

func (x *GameDocument) GetBag() *Bag {
	if x != nil {
		return x.Bag
	}
	return nil
}

func (x *GameDocument) GetScorelessTurns() uint32 {
	if x != nil {
		return x.ScorelessTurns
	}
	return 0
}

func (x *GameDocument) GetPlayerOnTurn() uint32 {
	if x != nil {
		return x.PlayerOnTurn
	}
	return 0
}

func (x *GameDocument) GetTimers() *Timers {
	if x != nil {
		return x.Timers
	}
	return nil
}

type GameDocument_MinimalPlayerInfo struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Nickname string                 `protobuf:"bytes,1,opt,name=nickname,proto3" json:"nickname,omitempty"`
	RealName string                 `protobuf:"bytes,2,opt,name=real_name,json=realName,proto3" json:"real_name,omitempty"`
	// user_id is an internal, unchangeable user ID, whereas the other two user
	// identifiers might possibly be mutable.
	UserId        string `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Quit          bool   `protobuf:"varint,4,opt,name=quit,proto3" json:"quit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameDocument_MinimalPlayerInfo) Reset() {
	*x = GameDocument_MinimalPlayerInfo{}
	mi := &file_proto_ipc_omgwords_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameDocument_MinimalPlayerInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameDocument_MinimalPlayerInfo) ProtoMessage() {}

func (x *GameDocument_MinimalPlayerInfo) ProtoReflect() protoreflect.Message {
	mi := &file_proto_ipc_omgwords_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameDocument_MinimalPlayerInfo.ProtoReflect.Descriptor instead.
func (*GameDocument_MinimalPlayerInfo) Descriptor() ([]byte, []int) {
	return file_proto_ipc_omgwords_proto_rawDescGZIP(), []int{28, 0}
}

func (x *GameDocument_MinimalPlayerInfo) GetNickname() string {
	if x != nil {
		return x.Nickname
	}
	return ""
}

func (x *GameDocument_MinimalPlayerInfo) GetRealName() string {
	if x != nil {
		return x.RealName
	}
	return ""
}

func (x *GameDocument_MinimalPlayerInfo) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *GameDocument_MinimalPlayerInfo) GetQuit() bool {
	if x != nil {
		return x.Quit
	}
	return false
}

var File_proto_ipc_omgwords_proto protoreflect.FileDescriptor

const file_proto_ipc_omgwords_proto_rawDesc = "" +
	"\n" +
	"\x18proto/ipc/omgwords.proto\x12\x03ipc\x1a\x1cvendor/macondo/macondo.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xab\x02\n" +
	"\x13ClientGameplayEvent\x126\n" +
	"\x04type\x18\x01 \x01(\x0e2\".ipc.ClientGameplayEvent.EventTypeR\x04type\x12\x17\n" +
	"\agame_id\x18\x02 \x01(\tR\x06gameId\x12'\n" +
	"\x0fposition_coords\x18\x03 \x01(\tR\x0epositionCoords\x12\x18\n" +
	"\x05tiles\x18\x04 \x01(\tB\x02\x18\x01R\x05tiles\x12'\n" +
	"\x0fmachine_letters\x18\x05 \x01(\fR\x0emachineLetters\"W\n" +
	"\tEventType\x12\x12\n" +
	"\x0eTILE_PLACEMENT\x10\x00\x12\b\n" +
	"\x04PASS\x10\x01\x12\f\n" +
	"\bEXCHANGE\x10\x02\x12\x12\n" +
	"\x0eCHALLENGE_PLAY\x10\x03\x12\n" +
	"\n" +
	"\x06RESIGN\x10\x04\"\x94\x01\n" +
	"\tGameRules\x12*\n" +
	"\x11board_layout_name\x18\x01 \x01(\tR\x0fboardLayoutName\x128\n" +
	"\x18letter_distribution_name\x18\x02 \x01(\tR\x16letterDistributionName\x12!\n" +
	"\fvariant_name\x18\x03 \x01(\tR\vvariantName\"\xa6\x04\n" +
	"\vGameRequest\x12\x18\n" +
	"\alexicon\x18\x01 \x01(\tR\alexicon\x12$\n" +
	"\x05rules\x18\x02 \x01(\v2\x0e.ipc.GameRulesR\x05rules\x120\n" +
	"\x14initial_time_seconds\x18\x03 \x01(\x05R\x12initialTimeSeconds\x12+\n" +
	"\x11increment_seconds\x18\x04 \x01(\x05R\x10incrementSeconds\x12=\n" +
	"\x0echallenge_rule\x18\x05 \x01(\x0e2\x16.macondo.ChallengeRuleR\rchallengeRule\x12*\n" +
	"\tgame_mode\x18\x06 \x01(\x0e2\r.ipc.GameModeR\bgameMode\x120\n" +
	"\vrating_mode\x18\a \x01(\x0e2\x0f.ipc.RatingModeR\n" +
	"ratingMode\x12\x1d\n" +
	"\n" +
	"request_id\x18\b \x01(\tR\trequestId\x120\n" +
	"\x14max_overtime_minutes\x18\t \x01(\x05R\x12maxOvertimeMinutes\x12\"\n" +
	"\rplayer_vs_bot\x18\n" +
	" \x01(\bR\vplayerVsBot\x12.\n" +
	"\x13original_request_id\x18\v \x01(\tR\x11originalRequestId\x126\n" +
	"\bbot_type\x18\f \x01(\x0e2\x1b.macondo.BotRequest.BotCodeR\abotType\"\xee\x03\n" +
	"\rGameMetaEvent\x12\"\n" +
	"\rorig_event_id\x18\x01 \x01(\tR\vorigEventId\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x120\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1c.ipc.GameMetaEvent.EventTypeR\x04type\x12\x1b\n" +
	"\tplayer_id\x18\x04 \x01(\tR\bplayerId\x12\x17\n" +
	"\agame_id\x18\x05 \x01(\tR\x06gameId\x12\x16\n" +
	"\x06expiry\x18\x06 \x01(\x05R\x06expiry\"\xfe\x01\n" +
	"\tEventType\x12\x11\n" +
	"\rREQUEST_ABORT\x10\x00\x12\x18\n" +
	"\x14REQUEST_ADJUDICATION\x10\x01\x12\x10\n" +
	"\fREQUEST_UNDO\x10\x02\x12\x13\n" +
	"\x0fREQUEST_ADJOURN\x10\x03\x12\x12\n" +
	"\x0eABORT_ACCEPTED\x10\x04\x12\x10\n" +
	"\fABORT_DENIED\x10\x05\x12\x19\n" +
	"\x15ADJUDICATION_ACCEPTED\x10\x06\x12\x17\n" +
	"\x13ADJUDICATION_DENIED\x10\a\x12\x11\n" +
	"\rUNDO_ACCEPTED\x10\b\x12\x0f\n" +
	"\vUNDO_DENIED\x10\t\x12\f\n" +
	"\bADD_TIME\x10\n" +
	"\x12\x11\n" +
	"\rTIMER_EXPIRED\x10\v\"\xae\x02\n" +
	"\x14GameHistoryRefresher\x12.\n" +
	"\ahistory\x18\x01 \x01(\v2\x14.macondo.GameHistoryR\ahistory\x12!\n" +
	"\ftime_player1\x18\x02 \x01(\x05R\vtimePlayer1\x12!\n" +
	"\ftime_player2\x18\x03 \x01(\x05R\vtimePlayer2\x120\n" +
	"\x14max_overtime_minutes\x18\x04 \x01(\x05R\x12maxOvertimeMinutes\x12?\n" +
	"\x11outstanding_event\x18\x05 \x01(\v2\x12.ipc.GameMetaEventR\x10outstandingEvent\x12-\n" +
	"\x13time_of_last_update\x18\x06 \x01(\x03R\x10timeOfLastUpdate\"8\n" +
	"\x11GameDocumentEvent\x12#\n" +
	"\x03doc\x18\x01 \x01(\v2\x11.ipc.GameDocumentR\x03doc\"z\n" +
	"\x15TournamentDataForGame\x12\x10\n" +
	"\x03tid\x18\x01 \x01(\tR\x03tid\x12\x1a\n" +
	"\bdivision\x18\x02 \x01(\tR\bdivision\x12\x14\n" +
	"\x05round\x18\x03 \x01(\x05R\x05round\x12\x1d\n" +
	"\n" +
	"game_index\x18\x04 \x01(\x05R\tgameIndex\"\xe0\x01\n" +
	"\n" +
	"PlayerInfo\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12\x1a\n" +
	"\bnickname\x18\x02 \x01(\tR\bnickname\x12\x1b\n" +
	"\tfull_name\x18\x03 \x01(\tR\bfullName\x12!\n" +
	"\fcountry_code\x18\x04 \x01(\tR\vcountryCode\x12\x16\n" +
	"\x06rating\x18\x05 \x01(\tR\x06rating\x12\x14\n" +
	"\x05title\x18\x06 \x01(\tR\x05title\x12\x15\n" +
	"\x06is_bot\x18\b \x01(\bR\x05isBot\x12\x18\n" +
	"\x05first\x18\t \x01(\bB\x02\x18\x01R\x05first\"\xb1\x05\n" +
	"\x10GameInfoResponse\x12)\n" +
	"\aplayers\x18\x01 \x03(\v2\x0f.ipc.PlayerInfoR\aplayers\x12*\n" +
	"\x11time_control_name\x18\x04 \x01(\tR\x0ftimeControlName\x12#\n" +
	"\rtournament_id\x18\x06 \x01(\tR\ftournamentId\x12:\n" +
	"\x0fgame_end_reason\x18\v \x01(\x0e2\x12.ipc.GameEndReasonR\rgameEndReason\x12\x16\n" +
	"\x06scores\x18\r \x03(\x05R\x06scores\x12\x16\n" +
	"\x06winner\x18\x0e \x01(\x05R\x06winner\x129\n" +
	"\n" +
	"created_at\x18\x0f \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12\x17\n" +
	"\agame_id\x18\x10 \x01(\tR\x06gameId\x12;\n" +
	"\vlast_update\x18\x12 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"lastUpdate\x123\n" +
	"\fgame_request\x18\x13 \x01(\v2\x10.ipc.GameRequestR\vgameRequest\x12/\n" +
	"\x13tournament_division\x18\x14 \x01(\tR\x12tournamentDivision\x12)\n" +
	"\x10tournament_round\x18\x15 \x01(\x05R\x0ftournamentRound\x122\n" +
	"\x15tournament_game_index\x18\x16 \x01(\x05R\x13tournamentGameIndex\x12!\n" +
	"\x04type\x18\x17 \x01(\x0e2\r.ipc.GameTypeR\x04type\x12)\n" +
	"\x0eplayer_on_turn\x18\x18 \x01(\rH\x00R\fplayerOnTurn\x88\x01\x01B\x11\n" +
	"\x0f_player_on_turn\"G\n" +
	"\x11GameInfoResponses\x122\n" +
	"\tgame_info\x18\x01 \x03(\v2\x15.ipc.GameInfoResponseR\bgameInfo\"\xcd\x01\n" +
	"\x0fInstantiateGame\x12\x19\n" +
	"\buser_ids\x18\x01 \x03(\tR\auserIds\x123\n" +
	"\fgame_request\x18\x02 \x01(\v2\x10.ipc.GameRequestR\vgameRequest\x12%\n" +
	"\x0eassigned_first\x18\x03 \x01(\x05R\rassignedFirst\x12C\n" +
	"\x0ftournament_data\x18\x04 \x01(\v2\x1a.ipc.TournamentDataForGameR\x0etournamentData\"\x1e\n" +
	"\fGameDeletion\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"G\n" +
	"\x10ActiveGamePlayer\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\"b\n" +
	"\x0fActiveGameEntry\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12-\n" +
	"\x06player\x18\x02 \x03(\v2\x15.ipc.ActiveGamePlayerR\x06player\x12\x10\n" +
	"\x03ttl\x18\x03 \x01(\x03R\x03ttl\"'\n" +
	"\fReadyForGame\x12\x17\n" +
	"\agame_id\x18\x01 \x01(\tR\x06gameId\"\xe1\x01\n" +
	"\x13ServerGameplayEvent\x12(\n" +
	"\x05event\x18\x01 \x01(\v2\x12.macondo.GameEventR\x05event\x12\x17\n" +
	"\agame_id\x18\x02 \x01(\tR\x06gameId\x12\x19\n" +
	"\bnew_rack\x18\x03 \x01(\tR\anewRack\x12%\n" +
	"\x0etime_remaining\x18\x04 \x01(\x05R\rtimeRemaining\x12,\n" +
	"\aplaying\x18\x05 \x01(\x0e2\x12.macondo.PlayStateR\aplaying\x12\x17\n" +
	"\auser_id\x18\x06 \x01(\tR\x06userId\"\xd9\x01\n" +
	"\x13ServerOMGWordsEvent\x12$\n" +
	"\x05event\x18\x01 \x01(\v2\x0e.ipc.GameEventR\x05event\x12\x17\n" +
	"\agame_id\x18\x02 \x01(\tR\x06gameId\x12\x19\n" +
	"\bnew_rack\x18\x03 \x01(\fR\anewRack\x12%\n" +
	"\x0etime_remaining\x18\x04 \x01(\x05R\rtimeRemaining\x12(\n" +
	"\aplaying\x18\x05 \x01(\x0e2\x0e.ipc.PlayStateR\aplaying\x12\x17\n" +
	"\auser_id\x18\x06 \x01(\tR\x06userId\"\xb8\x01\n" +
	"\x1aServerChallengeResultEvent\x12\x14\n" +
	"\x05valid\x18\x01 \x01(\bR\x05valid\x12\x1e\n" +
	"\n" +
	"challenger\x18\x02 \x01(\tR\n" +
	"challenger\x12=\n" +
	"\x0echallenge_rule\x18\x03 \x01(\x0e2\x16.macondo.ChallengeRuleR\rchallengeRule\x12%\n" +
	"\x0ereturned_tiles\x18\x04 \x01(\tR\rreturnedTiles\"\xb6\x01\n" +
	"\x1cOMGWordsChallengeResultEvent\x12\x14\n" +
	"\x05valid\x18\x01 \x01(\bR\x05valid\x12\x1e\n" +
	"\n" +
	"challenger\x18\x02 \x01(\tR\n" +
	"challenger\x129\n" +
	"\x0echallenge_rule\x18\x03 \x01(\x0e2\x12.ipc.ChallengeRuleR\rchallengeRule\x12%\n" +
	"\x0ereturned_tiles\x18\x04 \x01(\fR\rreturnedTiles\"\xcd\x04\n" +
	"\x0eGameEndedEvent\x127\n" +
	"\x06scores\x18\x01 \x03(\v2\x1f.ipc.GameEndedEvent.ScoresEntryR\x06scores\x12D\n" +
	"\vnew_ratings\x18\x02 \x03(\v2#.ipc.GameEndedEvent.NewRatingsEntryR\n" +
	"newRatings\x121\n" +
	"\n" +
	"end_reason\x18\x03 \x01(\x0e2\x12.ipc.GameEndReasonR\tendReason\x12\x16\n" +
	"\x06winner\x18\x04 \x01(\tR\x06winner\x12\x14\n" +
	"\x05loser\x18\x05 \x01(\tR\x05loser\x12\x10\n" +
	"\x03tie\x18\x06 \x01(\bR\x03tie\x12\x12\n" +
	"\x04time\x18\a \x01(\x03R\x04time\x12J\n" +
	"\rrating_deltas\x18\b \x03(\v2%.ipc.GameEndedEvent.RatingDeltasEntryR\fratingDeltas\x12.\n" +
	"\ahistory\x18\t \x01(\v2\x14.macondo.GameHistoryR\ahistory\x1a9\n" +
	"\vScoresEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\x1a=\n" +
	"\x0fNewRatingsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\x1a?\n" +
	"\x11RatingDeltasEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"=\n" +
	"\x13RematchStartedEvent\x12&\n" +
	"\x0frematch_game_id\x18\x01 \x01(\tR\rrematchGameId\"o\n" +
	"\fNewGameEvent\x12\x17\n" +
	"\agame_id\x18\x01 \x01(\tR\x06gameId\x12#\n" +
	"\rrequester_cid\x18\x02 \x01(\tR\frequesterCid\x12!\n" +
	"\faccepter_cid\x18\x03 \x01(\tR\vaccepterCid\"<\n" +
	"\bTimedOut\x12\x17\n" +
	"\agame_id\x18\x01 \x01(\tR\x06gameId\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\"\x8e\a\n" +
	"\tGameEvent\x12\x12\n" +
	"\x04note\x18\x02 \x01(\tR\x04note\x12\x12\n" +
	"\x04rack\x18\x03 \x01(\fR\x04rack\x12'\n" +
	"\x04type\x18\x04 \x01(\x0e2\x13.ipc.GameEvent.TypeR\x04type\x12\x1e\n" +
	"\n" +
	"cumulative\x18\x05 \x01(\x05R\n" +
	"cumulative\x12\x10\n" +
	"\x03row\x18\x06 \x01(\x05R\x03row\x12\x16\n" +
	"\x06column\x18\a \x01(\x05R\x06column\x126\n" +
	"\tdirection\x18\b \x01(\x0e2\x18.ipc.GameEvent.DirectionR\tdirection\x12\x1a\n" +
	"\bposition\x18\t \x01(\tR\bposition\x12!\n" +
	"\fplayed_tiles\x18\n" +
	" \x01(\fR\vplayedTiles\x12\x1c\n" +
	"\texchanged\x18\v \x01(\fR\texchanged\x12\x14\n" +
	"\x05score\x18\f \x01(\x05R\x05score\x12\x14\n" +
	"\x05bonus\x18\r \x01(\x05R\x05bonus\x12&\n" +
	"\x0fend_rack_points\x18\x0e \x01(\x05R\rendRackPoints\x12\x1d\n" +
	"\n" +
	"lost_score\x18\x0f \x01(\x05R\tlostScore\x12\x19\n" +
	"\bis_bingo\x18\x10 \x01(\bR\aisBingo\x12!\n" +
	"\fwords_formed\x18\x11 \x03(\fR\vwordsFormed\x12)\n" +
	"\x10millis_remaining\x18\x12 \x01(\x05R\x0fmillisRemaining\x12!\n" +
	"\fplayer_index\x18\x13 \x01(\rR\vplayerIndex\x122\n" +
	"\x15words_formed_friendly\x18\x14 \x03(\tR\x13wordsFormedFriendly\"\xf2\x01\n" +
	"\x04Type\x12\x17\n" +
	"\x13TILE_PLACEMENT_MOVE\x10\x00\x12\x18\n" +
	"\x14PHONY_TILES_RETURNED\x10\x01\x12\b\n" +
	"\x04PASS\x10\x02\x12\x13\n" +
	"\x0fCHALLENGE_BONUS\x10\x03\x12\f\n" +
	"\bEXCHANGE\x10\x04\x12\x10\n" +
	"\fEND_RACK_PTS\x10\x05\x12\x10\n" +
	"\fTIME_PENALTY\x10\x06\x12\x14\n" +
	"\x10END_RACK_PENALTY\x10\a\x12$\n" +
	" UNSUCCESSFUL_CHALLENGE_TURN_LOSS\x10\b\x12\r\n" +
	"\tCHALLENGE\x10\t\x12\r\n" +
	"\tTIMED_OUT\x10\n" +
	"\x12\f\n" +
	"\bRESIGNED\x10\v\")\n" +
	"\tDirection\x12\x0e\n" +
	"\n" +
	"HORIZONTAL\x10\x00\x12\f\n" +
	"\bVERTICAL\x10\x01\"\xca\x02\n" +
	"\x06Timers\x12-\n" +
	"\x13time_of_last_update\x18\x01 \x01(\x03R\x10timeOfLastUpdate\x12!\n" +
	"\ftime_started\x18\x02 \x01(\x03R\vtimeStarted\x12%\n" +
	"\x0etime_remaining\x18\x03 \x03(\x03R\rtimeRemaining\x12!\n" +
	"\fmax_overtime\x18\x04 \x01(\x05R\vmaxOvertime\x12+\n" +
	"\x11increment_seconds\x18\x05 \x01(\x05R\x10incrementSeconds\x12@\n" +
	"\x1dreset_to_increment_after_turn\x18\x06 \x01(\bR\x19resetToIncrementAfterTurn\x12\x18\n" +
	"\auntimed\x18\a \x01(\bR\auntimed\x12\x1b\n" +
	"\ttime_bank\x18\b \x03(\x03R\btimeBank\";\n" +
	"\rMetaEventData\x12*\n" +
	"\x06events\x18\x01 \x03(\v2\x12.ipc.GameMetaEventR\x06events\"r\n" +
	"\tGameBoard\x12\x19\n" +
	"\bnum_rows\x18\x01 \x01(\x05R\anumRows\x12\x19\n" +
	"\bnum_cols\x18\x02 \x01(\x05R\anumCols\x12\x14\n" +
	"\x05tiles\x18\x03 \x01(\fR\x05tiles\x12\x19\n" +
	"\bis_empty\x18\x04 \x01(\bR\aisEmpty\"\x1b\n" +
	"\x03Bag\x12\x14\n" +
	"\x05tiles\x18\x01 \x01(\fR\x05tiles\"\xaf\b\n" +
	"\fGameDocument\x12=\n" +
	"\aplayers\x18\x01 \x03(\v2#.ipc.GameDocument.MinimalPlayerInfoR\aplayers\x12&\n" +
	"\x06events\x18\x02 \x03(\v2\x0e.ipc.GameEventR\x06events\x12\x18\n" +
	"\aversion\x18\x03 \x01(\rR\aversion\x12\x18\n" +
	"\alexicon\x18\x04 \x01(\tR\alexicon\x12\x10\n" +
	"\x03uid\x18\x05 \x01(\tR\x03uid\x12 \n" +
	"\vdescription\x18\x06 \x01(\tR\vdescription\x12\x14\n" +
	"\x05racks\x18\a \x03(\fR\x05racks\x129\n" +
	"\x0echallenge_rule\x18\b \x01(\x0e2\x12.ipc.ChallengeRuleR\rchallengeRule\x12-\n" +
	"\n" +
	"play_state\x18\t \x01(\x0e2\x0e.ipc.PlayStateR\tplayState\x12%\n" +
	"\x0ecurrent_scores\x18\n" +
	" \x03(\x05R\rcurrentScores\x12\x18\n" +
	"\avariant\x18\v \x01(\tR\avariant\x12\x16\n" +
	"\x06winner\x18\f \x01(\x05R\x06winner\x12!\n" +
	"\fboard_layout\x18\r \x01(\tR\vboardLayout\x12/\n" +
	"\x13letter_distribution\x18\x0e \x01(\tR\x12letterDistribution\x12!\n" +
	"\x04type\x18\x0f \x01(\x0e2\r.ipc.GameTypeR\x04type\x12%\n" +
	"\x0etimers_started\x18\x10 \x01(\bR\rtimersStarted\x121\n" +
	"\n" +
	"end_reason\x18\x11 \x01(\x0e2\x12.ipc.GameEndReasonR\tendReason\x12:\n" +
	"\x0fmeta_event_data\x18\x12 \x01(\v2\x12.ipc.MetaEventDataR\rmetaEventData\x129\n" +
	"\n" +
	"created_at\x18\x13 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12$\n" +
	"\x05board\x18\x14 \x01(\v2\x0e.ipc.GameBoardR\x05board\x12\x1a\n" +
	"\x03bag\x18\x15 \x01(\v2\b.ipc.BagR\x03bag\x12'\n" +
	"\x0fscoreless_turns\x18\x16 \x01(\rR\x0escorelessTurns\x12$\n" +
	"\x0eplayer_on_turn\x18\x17 \x01(\rR\fplayerOnTurn\x12#\n" +
	"\x06timers\x18\x18 \x01(\v2\v.ipc.TimersR\x06timers\x1ay\n" +
	"\x11MinimalPlayerInfo\x12\x1a\n" +
	"\bnickname\x18\x01 \x01(\tR\bnickname\x12\x1b\n" +
	"\treal_name\x18\x02 \x01(\tR\brealName\x12\x17\n" +
	"\auser_id\x18\x03 \x01(\tR\x06userId\x12\x12\n" +
	"\x04quit\x18\x04 \x01(\bR\x04quit*\x9c\x01\n" +
	"\rGameEndReason\x12\b\n" +
	"\x04NONE\x10\x00\x12\b\n" +
	"\x04TIME\x10\x01\x12\f\n" +
	"\bSTANDARD\x10\x02\x12\x16\n" +
	"\x12CONSECUTIVE_ZEROES\x10\x03\x12\f\n" +
	"\bRESIGNED\x10\x04\x12\v\n" +
	"\aABORTED\x10\x05\x12\x14\n" +
	"\x10TRIPLE_CHALLENGE\x10\x06\x12\r\n" +
	"\tCANCELLED\x10\a\x12\x11\n" +
	"\rFORCE_FORFEIT\x10\b*-\n" +
	"\bGameMode\x12\r\n" +
	"\tREAL_TIME\x10\x00\x12\x12\n" +
	"\x0eCORRESPONDENCE\x10\x01*#\n" +
	"\n" +
	"RatingMode\x12\t\n" +
	"\x05RATED\x10\x00\x12\n" +
	"\n" +
	"\x06CASUAL\x10\x01*5\n" +
	"\bGameType\x12\n" +
	"\n" +
	"\x06NATIVE\x10\x00\x12\r\n" +
	"\tANNOTATED\x10\x01\x12\x0e\n" +
	"\n" +
	"BOT_VS_BOT\x10\x02*R\n" +
	"\tPlayState\x12\v\n" +
	"\aPLAYING\x10\x00\x12\x1a\n" +
	"\x16WAITING_FOR_FINAL_PASS\x10\x01\x12\r\n" +
	"\tGAME_OVER\x10\x02\x12\r\n" +
	"\tUNSTARTED\x10\x03*\xb0\x01\n" +
	"\rChallengeRule\x12\x16\n" +
	"\x12ChallengeRule_VOID\x10\x00\x12\x18\n" +
	"\x14ChallengeRule_SINGLE\x10\x01\x12\x18\n" +
	"\x14ChallengeRule_DOUBLE\x10\x02\x12\x1c\n" +
	"\x18ChallengeRule_FIVE_POINT\x10\x03\x12\x1b\n" +
	"\x17ChallengeRule_TEN_POINT\x10\x04\x12\x18\n" +
	"\x14ChallengeRule_TRIPLE\x10\x05Bu\n" +
	"\acom.ipcB\rOmgwordsProtoP\x01Z/github.com/woogles-io/liwords/rpc/api/proto/ipc\xa2\x02\x03IXX\xaa\x02\x03Ipc\xca\x02\x03Ipc\xe2\x02\x0fIpc\\GPBMetadata\xea\x02\x03Ipcb\x06proto3"

var (
	file_proto_ipc_omgwords_proto_rawDescOnce sync.Once
	file_proto_ipc_omgwords_proto_rawDescData []byte
)

func file_proto_ipc_omgwords_proto_rawDescGZIP() []byte {
	file_proto_ipc_omgwords_proto_rawDescOnce.Do(func() {
		file_proto_ipc_omgwords_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_ipc_omgwords_proto_rawDesc), len(file_proto_ipc_omgwords_proto_rawDesc)))
	})
	return file_proto_ipc_omgwords_proto_rawDescData
}

var file_proto_ipc_omgwords_proto_enumTypes = make([]protoimpl.EnumInfo, 10)
var file_proto_ipc_omgwords_proto_msgTypes = make([]protoimpl.MessageInfo, 33)
var file_proto_ipc_omgwords_proto_goTypes = []any{
	(GameEndReason)(0),                     // 0: ipc.GameEndReason
	(GameMode)(0),                          // 1: ipc.GameMode
	(RatingMode)(0),                        // 2: ipc.RatingMode
	(GameType)(0),                          // 3: ipc.GameType
	(PlayState)(0),                         // 4: ipc.PlayState
	(ChallengeRule)(0),                     // 5: ipc.ChallengeRule
	(ClientGameplayEvent_EventType)(0),     // 6: ipc.ClientGameplayEvent.EventType
	(GameMetaEvent_EventType)(0),           // 7: ipc.GameMetaEvent.EventType
	(GameEvent_Type)(0),                    // 8: ipc.GameEvent.Type
	(GameEvent_Direction)(0),               // 9: ipc.GameEvent.Direction
	(*ClientGameplayEvent)(nil),            // 10: ipc.ClientGameplayEvent
	(*GameRules)(nil),                      // 11: ipc.GameRules
	(*GameRequest)(nil),                    // 12: ipc.GameRequest
	(*GameMetaEvent)(nil),                  // 13: ipc.GameMetaEvent
	(*GameHistoryRefresher)(nil),           // 14: ipc.GameHistoryRefresher
	(*GameDocumentEvent)(nil),              // 15: ipc.GameDocumentEvent
	(*TournamentDataForGame)(nil),          // 16: ipc.TournamentDataForGame
	(*PlayerInfo)(nil),                     // 17: ipc.PlayerInfo
	(*GameInfoResponse)(nil),               // 18: ipc.GameInfoResponse
	(*GameInfoResponses)(nil),              // 19: ipc.GameInfoResponses
	(*InstantiateGame)(nil),                // 20: ipc.InstantiateGame
	(*GameDeletion)(nil),                   // 21: ipc.GameDeletion
	(*ActiveGamePlayer)(nil),               // 22: ipc.ActiveGamePlayer
	(*ActiveGameEntry)(nil),                // 23: ipc.ActiveGameEntry
	(*ReadyForGame)(nil),                   // 24: ipc.ReadyForGame
	(*ServerGameplayEvent)(nil),            // 25: ipc.ServerGameplayEvent
	(*ServerOMGWordsEvent)(nil),            // 26: ipc.ServerOMGWordsEvent
	(*ServerChallengeResultEvent)(nil),     // 27: ipc.ServerChallengeResultEvent
	(*OMGWordsChallengeResultEvent)(nil),   // 28: ipc.OMGWordsChallengeResultEvent
	(*GameEndedEvent)(nil),                 // 29: ipc.GameEndedEvent
	(*RematchStartedEvent)(nil),            // 30: ipc.RematchStartedEvent
	(*NewGameEvent)(nil),                   // 31: ipc.NewGameEvent
	(*TimedOut)(nil),                       // 32: ipc.TimedOut
	(*GameEvent)(nil),                      // 33: ipc.GameEvent
	(*Timers)(nil),                         // 34: ipc.Timers
	(*MetaEventData)(nil),                  // 35: ipc.MetaEventData
	(*GameBoard)(nil),                      // 36: ipc.GameBoard
	(*Bag)(nil),                            // 37: ipc.Bag
	(*GameDocument)(nil),                   // 38: ipc.GameDocument
	nil,                                    // 39: ipc.GameEndedEvent.ScoresEntry
	nil,                                    // 40: ipc.GameEndedEvent.NewRatingsEntry
	nil,                                    // 41: ipc.GameEndedEvent.RatingDeltasEntry
	(*GameDocument_MinimalPlayerInfo)(nil), // 42: ipc.GameDocument.MinimalPlayerInfo
	(macondo.ChallengeRule)(0),             // 43: macondo.ChallengeRule
	(macondo.BotRequest_BotCode)(0),        // 44: macondo.BotRequest.BotCode
	(*timestamppb.Timestamp)(nil),          // 45: google.protobuf.Timestamp
	(*macondo.GameHistory)(nil),            // 46: macondo.GameHistory
	(*macondo.GameEvent)(nil),              // 47: macondo.GameEvent
	(macondo.PlayState)(0),                 // 48: macondo.PlayState
}
var file_proto_ipc_omgwords_proto_depIdxs = []int32{
	6,  // 0: ipc.ClientGameplayEvent.type:type_name -> ipc.ClientGameplayEvent.EventType
	11, // 1: ipc.GameRequest.rules:type_name -> ipc.GameRules
	43, // 2: ipc.GameRequest.challenge_rule:type_name -> macondo.ChallengeRule
	1,  // 3: ipc.GameRequest.game_mode:type_name -> ipc.GameMode
	2,  // 4: ipc.GameRequest.rating_mode:type_name -> ipc.RatingMode
	44, // 5: ipc.GameRequest.bot_type:type_name -> macondo.BotRequest.BotCode
	45, // 6: ipc.GameMetaEvent.timestamp:type_name -> google.protobuf.Timestamp
	7,  // 7: ipc.GameMetaEvent.type:type_name -> ipc.GameMetaEvent.EventType
	46, // 8: ipc.GameHistoryRefresher.history:type_name -> macondo.GameHistory
	13, // 9: ipc.GameHistoryRefresher.outstanding_event:type_name -> ipc.GameMetaEvent
	38, // 10: ipc.GameDocumentEvent.doc:type_name -> ipc.GameDocument
	17, // 11: ipc.GameInfoResponse.players:type_name -> ipc.PlayerInfo
	0,  // 12: ipc.GameInfoResponse.game_end_reason:type_name -> ipc.GameEndReason
	45, // 13: ipc.GameInfoResponse.created_at:type_name -> google.protobuf.Timestamp
	45, // 14: ipc.GameInfoResponse.last_update:type_name -> google.protobuf.Timestamp
	12, // 15: ipc.GameInfoResponse.game_request:type_name -> ipc.GameRequest
	3,  // 16: ipc.GameInfoResponse.type:type_name -> ipc.GameType
	18, // 17: ipc.GameInfoResponses.game_info:type_name -> ipc.GameInfoResponse
	12, // 18: ipc.InstantiateGame.game_request:type_name -> ipc.GameRequest
	16, // 19: ipc.InstantiateGame.tournament_data:type_name -> ipc.TournamentDataForGame
	22, // 20: ipc.ActiveGameEntry.player:type_name -> ipc.ActiveGamePlayer
	47, // 21: ipc.ServerGameplayEvent.event:type_name -> macondo.GameEvent
	48, // 22: ipc.ServerGameplayEvent.playing:type_name -> macondo.PlayState
	33, // 23: ipc.ServerOMGWordsEvent.event:type_name -> ipc.GameEvent
	4,  // 24: ipc.ServerOMGWordsEvent.playing:type_name -> ipc.PlayState
	43, // 25: ipc.ServerChallengeResultEvent.challenge_rule:type_name -> macondo.ChallengeRule
	5,  // 26: ipc.OMGWordsChallengeResultEvent.challenge_rule:type_name -> ipc.ChallengeRule
	39, // 27: ipc.GameEndedEvent.scores:type_name -> ipc.GameEndedEvent.ScoresEntry
	40, // 28: ipc.GameEndedEvent.new_ratings:type_name -> ipc.GameEndedEvent.NewRatingsEntry
	0,  // 29: ipc.GameEndedEvent.end_reason:type_name -> ipc.GameEndReason
	41, // 30: ipc.GameEndedEvent.rating_deltas:type_name -> ipc.GameEndedEvent.RatingDeltasEntry
	46, // 31: ipc.GameEndedEvent.history:type_name -> macondo.GameHistory
	8,  // 32: ipc.GameEvent.type:type_name -> ipc.GameEvent.Type
	9,  // 33: ipc.GameEvent.direction:type_name -> ipc.GameEvent.Direction
	13, // 34: ipc.MetaEventData.events:type_name -> ipc.GameMetaEvent
	42, // 35: ipc.GameDocument.players:type_name -> ipc.GameDocument.MinimalPlayerInfo
	33, // 36: ipc.GameDocument.events:type_name -> ipc.GameEvent
	5,  // 37: ipc.GameDocument.challenge_rule:type_name -> ipc.ChallengeRule
	4,  // 38: ipc.GameDocument.play_state:type_name -> ipc.PlayState
	3,  // 39: ipc.GameDocument.type:type_name -> ipc.GameType
	0,  // 40: ipc.GameDocument.end_reason:type_name -> ipc.GameEndReason
	35, // 41: ipc.GameDocument.meta_event_data:type_name -> ipc.MetaEventData
	45, // 42: ipc.GameDocument.created_at:type_name -> google.protobuf.Timestamp
	36, // 43: ipc.GameDocument.board:type_name -> ipc.GameBoard
	37, // 44: ipc.GameDocument.bag:type_name -> ipc.Bag
	34, // 45: ipc.GameDocument.timers:type_name -> ipc.Timers
	46, // [46:46] is the sub-list for method output_type
	46, // [46:46] is the sub-list for method input_type
	46, // [46:46] is the sub-list for extension type_name
	46, // [46:46] is the sub-list for extension extendee
	0,  // [0:46] is the sub-list for field type_name
}

func init() { file_proto_ipc_omgwords_proto_init() }
func file_proto_ipc_omgwords_proto_init() {
	if File_proto_ipc_omgwords_proto != nil {
		return
	}
	file_proto_ipc_omgwords_proto_msgTypes[8].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_ipc_omgwords_proto_rawDesc), len(file_proto_ipc_omgwords_proto_rawDesc)),
			NumEnums:      10,
			NumMessages:   33,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_ipc_omgwords_proto_goTypes,
		DependencyIndexes: file_proto_ipc_omgwords_proto_depIdxs,
		EnumInfos:         file_proto_ipc_omgwords_proto_enumTypes,
		MessageInfos:      file_proto_ipc_omgwords_proto_msgTypes,
	}.Build()
	File_proto_ipc_omgwords_proto = out.File
	file_proto_ipc_omgwords_proto_goTypes = nil
	file_proto_ipc_omgwords_proto_depIdxs = nil
}
