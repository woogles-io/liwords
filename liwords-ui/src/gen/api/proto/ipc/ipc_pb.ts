// ipc is used for inter-process communication between the different
// services.
// This package will define many types that the different services should use,
// and should be roughly split up into different files by function.

// @generated by protoc-gen-es v2.10.1 with parameter "target=ts"
// @generated from file proto/ipc/ipc.proto (package ipc, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file proto/ipc/ipc.proto.
 */
export const file_proto_ipc_ipc: GenFile = /*@__PURE__*/
  fileDesc("ChNwcm90by9pcGMvaXBjLnByb3RvEgNpcGMiNQoUUmVnaXN0ZXJSZWFsbVJlcXVlc3QSDAoEcGF0aBgBIAEoCRIPCgd1c2VyX2lkGAIgASgJIicKFVJlZ2lzdGVyUmVhbG1SZXNwb25zZRIOCgZyZWFsbXMYAiADKAkiMAoNSW5pdFJlYWxtSW5mbxIPCgd1c2VyX2lkGAIgASgJEg4KBnJlYWxtcxgDIAMoCSIgCg5MYWdNZWFzdXJlbWVudBIOCgZsYWdfbXMYASABKAUiEwoEUG9uZxILCgNpcHMYASABKAkiIAoNU2VydmVyTWVzc2FnZRIPCgdtZXNzYWdlGAEgASgJIhgKCEpvaW5QYXRoEgwKBHBhdGgYASABKAkiDQoLVW5qb2luUmVhbG0iMgoJSGFuZHNoYWtlEiUKB3ZlcnNpb24YASABKA4yFC5pcGMuUHJvdG9jb2xWZXJzaW9uIl0KDEhhbmRzaGFrZUFjaxIlCgd2ZXJzaW9uGAEgASgOMhQuaXBjLlByb3RvY29sVmVyc2lvbhIPCgdzdWNjZXNzGAIgASgIEhUKDWVycm9yX21lc3NhZ2UYAyABKAkiIAoQU3Vic2NyaWJlUmVxdWVzdBIMCgRwYXRoGAEgASgJIk0KEVN1YnNjcmliZVJlc3BvbnNlEg8KB3N1Y2Nlc3MYASABKAgSEAoIY2hhbm5lbHMYAiADKAkSFQoNZXJyb3JfbWVzc2FnZRgDIAEoCSIiChJVbnN1YnNjcmliZVJlcXVlc3QSDAoEcGF0aBgBIAEoCSrECwoLTWVzc2FnZVR5cGUSEAoMU0VFS19SRVFVRVNUEAASEQoNTUFUQ0hfUkVRVUVTVBABEh0KGVNPVUdIVF9HQU1FX1BST0NFU1NfRVZFTlQQAhIZChVDTElFTlRfR0FNRVBMQVlfRVZFTlQQAxIZChVTRVJWRVJfR0FNRVBMQVlfRVZFTlQQBBIUChBHQU1FX0VOREVEX0VWRU5UEAUSGgoWR0FNRV9ISVNUT1JZX1JFRlJFU0hFUhAGEhEKDUVSUk9SX01FU1NBR0UQBxISCg5ORVdfR0FNRV9FVkVOVBAIEiEKHVNFUlZFUl9DSEFMTEVOR0VfUkVTVUxUX0VWRU5UEAkSEQoNU0VFS19SRVFVRVNUUxAKEhYKEk9OR09JTkdfR0FNRV9FVkVOVBAMEg0KCVRJTUVEX09VVBANEhEKDU9OR09JTkdfR0FNRVMQDhIdChlSRUFEWV9GT1JfVE9VUk5BTUVOVF9HQU1FEA8SHAoYVE9VUk5BTUVOVF9ST1VORF9TVEFSVEVEEBASEQoNR0FNRV9ERUxFVElPThAREhIKDk1BVENIX1JFUVVFU1RTEBISGAoUREVDTElORV9TRUVLX1JFUVVFU1QQExIQCgxDSEFUX01FU1NBR0UQFBIYChRDSEFUX01FU1NBR0VfREVMRVRFRBAVEhEKDVVTRVJfUFJFU0VOQ0UQFhISCg5VU0VSX1BSRVNFTkNFUxAXEhIKDlNFUlZFUl9NRVNTQUdFEBgSEgoOUkVBRFlfRk9SX0dBTUUQGRITCg9MQUdfTUVBU1VSRU1FTlQQGhIfChtUT1VSTkFNRU5UX0dBTUVfRU5ERURfRVZFTlQQGxIWChJUT1VSTkFNRU5UX01FU1NBR0UQHBITCg9SRU1BVENIX1NUQVJURUQQHRIfChtUT1VSTkFNRU5UX0RJVklTSU9OX01FU1NBR0UQHhInCiNUT1VSTkFNRU5UX0RJVklTSU9OX0RFTEVURURfTUVTU0FHRRAfEiUKIVRPVVJOQU1FTlRfRlVMTF9ESVZJU0lPTlNfTUVTU0FHRRAgEi4KKlRPVVJOQU1FTlRfRElWSVNJT05fUk9VTkRfQ09OVFJPTFNfTUVTU0FHRRAiEigKJFRPVVJOQU1FTlRfRElWSVNJT05fUEFJUklOR1NfTUVTU0FHRRAjEigKJFRPVVJOQU1FTlRfRElWSVNJT05fQ09OVFJPTFNfTUVTU0FHRRAkEi0KKVRPVVJOQU1FTlRfRElWSVNJT05fUExBWUVSX0NIQU5HRV9NRVNTQUdFECUSHwobVE9VUk5BTUVOVF9GSU5JU0hFRF9NRVNTQUdFECYSMAosVE9VUk5BTUVOVF9ESVZJU0lPTl9QQUlSSU5HU19ERUxFVEVEX01FU1NBR0UQJxISCg5QUkVTRU5DRV9FTlRSWRAoEhUKEUFDVElWRV9HQU1FX0VOVFJZECkSEwoPR0FNRV9NRVRBX0VWRU5UECoSGAoUUFJPRklMRV9VUERBVEVfRVZFTlQQKxIbChdPTUdXT1JEU19HQU1FUExBWV9FVkVOVBAsEhkKFU9NR1dPUkRTX0dBTUVET0NVTUVOVBAtEh0KGVRPVVJOQU1FTlRfUExBWUVSX0NIRUNLSU4QLhIcChhPVVJfQ09SUkVTUE9OREVOQ0VfR0FNRVMQLxIcChhPVVJfQ09SUkVTUE9OREVOQ0VfU0VFS1MQMBIjCh9NT05JVE9SSU5HX1NUUkVBTV9TVEFUVVNfVVBEQVRFEDESIwofT1VSX0xFQUdVRV9DT1JSRVNQT05ERU5DRV9HQU1FUxAyEg0KCUhBTkRTSEFLRRA8EhEKDUhBTkRTSEFLRV9BQ0sQPRIVChFTVUJTQ1JJQkVfUkVRVUVTVBA+EhYKElNVQlNDUklCRV9SRVNQT05TRRA/EhcKE1VOU1VCU0NSSUJFX1JFUVVFU1QQQCozCg9Qcm90b2NvbFZlcnNpb24SDwoLUFJPVE9DT0xfVjEQABIPCgtQUk9UT0NPTF9WMhABQnAKB2NvbS5pcGNCCElwY1Byb3RvUAFaL2dpdGh1Yi5jb20vd29vZ2xlcy1pby9saXdvcmRzL3JwYy9hcGkvcHJvdG8vaXBjogIDSVhYqgIDSXBjygIDSXBj4gIPSXBjXEdQQk1ldGFkYXRh6gIDSXBjYgZwcm90bzM");

/**
 * @generated from message ipc.RegisterRealmRequest
 */
export type RegisterRealmRequest = Message<"ipc.RegisterRealmRequest"> & {
  /**
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * @generated from field: string user_id = 2;
   */
  userId: string;
};

/**
 * Describes the message ipc.RegisterRealmRequest.
 * Use `create(RegisterRealmRequestSchema)` to create a new message.
 */
export const RegisterRealmRequestSchema: GenMessage<RegisterRealmRequest> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 0);

/**
 * @generated from message ipc.RegisterRealmResponse
 */
export type RegisterRealmResponse = Message<"ipc.RegisterRealmResponse"> & {
  /**
   * realm should be made obsolete. RegisterRealmResponse should always
   * return a list of realms.
   *
   * @generated from field: repeated string realms = 2;
   */
  realms: string[];
};

/**
 * Describes the message ipc.RegisterRealmResponse.
 * Use `create(RegisterRealmResponseSchema)` to create a new message.
 */
export const RegisterRealmResponseSchema: GenMessage<RegisterRealmResponse> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 1);

/**
 * InitRealmInfo is a request for the API server to send back information
 * about that realm back to the user. For example, for the lobby realm,
 * we would like lists of active games, chats, etc; for game realms, we would
 * like the game history.
 *
 * @generated from message ipc.InitRealmInfo
 */
export type InitRealmInfo = Message<"ipc.InitRealmInfo"> & {
  /**
   * @generated from field: string user_id = 2;
   */
  userId: string;

  /**
   * @generated from field: repeated string realms = 3;
   */
  realms: string[];
};

/**
 * Describes the message ipc.InitRealmInfo.
 * Use `create(InitRealmInfoSchema)` to create a new message.
 */
export const InitRealmInfoSchema: GenMessage<InitRealmInfo> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 2);

/**
 * @generated from message ipc.LagMeasurement
 */
export type LagMeasurement = Message<"ipc.LagMeasurement"> & {
  /**
   * @generated from field: int32 lag_ms = 1;
   */
  lagMs: number;
};

/**
 * Describes the message ipc.LagMeasurement.
 * Use `create(LagMeasurementSchema)` to create a new message.
 */
export const LagMeasurementSchema: GenMessage<LagMeasurement> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 3);

/**
 * @generated from message ipc.Pong
 */
export type Pong = Message<"ipc.Pong"> & {
  /**
   * @generated from field: string ips = 1;
   */
  ips: string;
};

/**
 * Describes the message ipc.Pong.
 * Use `create(PongSchema)` to create a new message.
 */
export const PongSchema: GenMessage<Pong> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 4);

/**
 * @generated from message ipc.ServerMessage
 */
export type ServerMessage = Message<"ipc.ServerMessage"> & {
  /**
   * @generated from field: string message = 1;
   */
  message: string;
};

/**
 * Describes the message ipc.ServerMessage.
 * Use `create(ServerMessageSchema)` to create a new message.
 */
export const ServerMessageSchema: GenMessage<ServerMessage> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 5);

/**
 * When we go to a new path in our SPA, we send a JoinPath. When we leave the
 * path, we send an Unjoin realm. d
 *
 * @generated from message ipc.JoinPath
 */
export type JoinPath = Message<"ipc.JoinPath"> & {
  /**
   * @generated from field: string path = 1;
   */
  path: string;
};

/**
 * Describes the message ipc.JoinPath.
 * Use `create(JoinPathSchema)` to create a new message.
 */
export const JoinPathSchema: GenMessage<JoinPath> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 6);

/**
 * @generated from message ipc.UnjoinRealm
 */
export type UnjoinRealm = Message<"ipc.UnjoinRealm"> & {
};

/**
 * Describes the message ipc.UnjoinRealm.
 * Use `create(UnjoinRealmSchema)` to create a new message.
 */
export const UnjoinRealmSchema: GenMessage<UnjoinRealm> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 7);

/**
 * Sent by client as first message after connecting with v=2
 *
 * @generated from message ipc.Handshake
 */
export type Handshake = Message<"ipc.Handshake"> & {
  /**
   * @generated from field: ipc.ProtocolVersion version = 1;
   */
  version: ProtocolVersion;
};

/**
 * Describes the message ipc.Handshake.
 * Use `create(HandshakeSchema)` to create a new message.
 */
export const HandshakeSchema: GenMessage<Handshake> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 8);

/**
 * Server acknowledges handshake
 *
 * @generated from message ipc.HandshakeAck
 */
export type HandshakeAck = Message<"ipc.HandshakeAck"> & {
  /**
   * @generated from field: ipc.ProtocolVersion version = 1;
   */
  version: ProtocolVersion;

  /**
   * @generated from field: bool success = 2;
   */
  success: boolean;

  /**
   * @generated from field: string error_message = 3;
   */
  errorMessage: string;
};

/**
 * Describes the message ipc.HandshakeAck.
 * Use `create(HandshakeAckSchema)` to create a new message.
 */
export const HandshakeAckSchema: GenMessage<HandshakeAck> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 9);

/**
 * Client requests to subscribe using URL path as identifier
 * Server parses path and determines appropriate channels
 *
 * @generated from message ipc.SubscribeRequest
 */
export type SubscribeRequest = Message<"ipc.SubscribeRequest"> & {
  /**
   * "/game/abc123", "/tournament/xyz", "/"
   *
   * @generated from field: string path = 1;
   */
  path: string;
};

/**
 * Describes the message ipc.SubscribeRequest.
 * Use `create(SubscribeRequestSchema)` to create a new message.
 */
export const SubscribeRequestSchema: GenMessage<SubscribeRequest> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 10);

/**
 * Server responds with subscription result
 *
 * @generated from message ipc.SubscribeResponse
 */
export type SubscribeResponse = Message<"ipc.SubscribeResponse"> & {
  /**
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * Actual channels subscribed to
   *
   * @generated from field: repeated string channels = 2;
   */
  channels: string[];

  /**
   * @generated from field: string error_message = 3;
   */
  errorMessage: string;
};

/**
 * Describes the message ipc.SubscribeResponse.
 * Use `create(SubscribeResponseSchema)` to create a new message.
 */
export const SubscribeResponseSchema: GenMessage<SubscribeResponse> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 11);

/**
 * Client requests to unsubscribe
 *
 * @generated from message ipc.UnsubscribeRequest
 */
export type UnsubscribeRequest = Message<"ipc.UnsubscribeRequest"> & {
  /**
   * Path to unsubscribe from, or empty for "unsubscribe all"
   *
   * @generated from field: string path = 1;
   */
  path: string;
};

/**
 * Describes the message ipc.UnsubscribeRequest.
 * Use `create(UnsubscribeRequestSchema)` to create a new message.
 */
export const UnsubscribeRequestSchema: GenMessage<UnsubscribeRequest> = /*@__PURE__*/
  messageDesc(file_proto_ipc_ipc, 12);

/**
 * In order to make socket messages as small and simple as possible,
 * we should include the message type with the socket message.
 * Whenever we add a new client <-> server socket message type,
 * add it to this list.
 *
 * @generated from enum ipc.MessageType
 */
export enum MessageType {
  /**
   * @generated from enum value: SEEK_REQUEST = 0;
   */
  SEEK_REQUEST = 0,

  /**
   * @generated from enum value: MATCH_REQUEST = 1;
   */
  MATCH_REQUEST = 1,

  /**
   * @generated from enum value: SOUGHT_GAME_PROCESS_EVENT = 2;
   */
  SOUGHT_GAME_PROCESS_EVENT = 2,

  /**
   * @generated from enum value: CLIENT_GAMEPLAY_EVENT = 3;
   */
  CLIENT_GAMEPLAY_EVENT = 3,

  /**
   * deprecate soon
   *
   * @generated from enum value: SERVER_GAMEPLAY_EVENT = 4;
   */
  SERVER_GAMEPLAY_EVENT = 4,

  /**
   * @generated from enum value: GAME_ENDED_EVENT = 5;
   */
  GAME_ENDED_EVENT = 5,

  /**
   * @generated from enum value: GAME_HISTORY_REFRESHER = 6;
   */
  GAME_HISTORY_REFRESHER = 6,

  /**
   * @generated from enum value: ERROR_MESSAGE = 7;
   */
  ERROR_MESSAGE = 7,

  /**
   * @generated from enum value: NEW_GAME_EVENT = 8;
   */
  NEW_GAME_EVENT = 8,

  /**
   * @generated from enum value: SERVER_CHALLENGE_RESULT_EVENT = 9;
   */
  SERVER_CHALLENGE_RESULT_EVENT = 9,

  /**
   * @generated from enum value: SEEK_REQUESTS = 10;
   */
  SEEK_REQUESTS = 10,

  /**
   * @generated from enum value: ONGOING_GAME_EVENT = 12;
   */
  ONGOING_GAME_EVENT = 12,

  /**
   * @generated from enum value: TIMED_OUT = 13;
   */
  TIMED_OUT = 13,

  /**
   * @generated from enum value: ONGOING_GAMES = 14;
   */
  ONGOING_GAMES = 14,

  /**
   * @generated from enum value: READY_FOR_TOURNAMENT_GAME = 15;
   */
  READY_FOR_TOURNAMENT_GAME = 15,

  /**
   * @generated from enum value: TOURNAMENT_ROUND_STARTED = 16;
   */
  TOURNAMENT_ROUND_STARTED = 16,

  /**
   * @generated from enum value: GAME_DELETION = 17;
   */
  GAME_DELETION = 17,

  /**
   * @generated from enum value: MATCH_REQUESTS = 18;
   */
  MATCH_REQUESTS = 18,

  /**
   * @generated from enum value: DECLINE_SEEK_REQUEST = 19;
   */
  DECLINE_SEEK_REQUEST = 19,

  /**
   * @generated from enum value: CHAT_MESSAGE = 20;
   */
  CHAT_MESSAGE = 20,

  /**
   * @generated from enum value: CHAT_MESSAGE_DELETED = 21;
   */
  CHAT_MESSAGE_DELETED = 21,

  /**
   * @generated from enum value: USER_PRESENCE = 22;
   */
  USER_PRESENCE = 22,

  /**
   * @generated from enum value: USER_PRESENCES = 23;
   */
  USER_PRESENCES = 23,

  /**
   * @generated from enum value: SERVER_MESSAGE = 24;
   */
  SERVER_MESSAGE = 24,

  /**
   * @generated from enum value: READY_FOR_GAME = 25;
   */
  READY_FOR_GAME = 25,

  /**
   * @generated from enum value: LAG_MEASUREMENT = 26;
   */
  LAG_MEASUREMENT = 26,

  /**
   * @generated from enum value: TOURNAMENT_GAME_ENDED_EVENT = 27;
   */
  TOURNAMENT_GAME_ENDED_EVENT = 27,

  /**
   * used for TournamentDataResponse (metadata)
   *
   * @generated from enum value: TOURNAMENT_MESSAGE = 28;
   */
  TOURNAMENT_MESSAGE = 28,

  /**
   * @generated from enum value: REMATCH_STARTED = 29;
   */
  REMATCH_STARTED = 29,

  /**
   * @generated from enum value: TOURNAMENT_DIVISION_MESSAGE = 30;
   */
  TOURNAMENT_DIVISION_MESSAGE = 30,

  /**
   * @generated from enum value: TOURNAMENT_DIVISION_DELETED_MESSAGE = 31;
   */
  TOURNAMENT_DIVISION_DELETED_MESSAGE = 31,

  /**
   * @generated from enum value: TOURNAMENT_FULL_DIVISIONS_MESSAGE = 32;
   */
  TOURNAMENT_FULL_DIVISIONS_MESSAGE = 32,

  /**
   * @generated from enum value: TOURNAMENT_DIVISION_ROUND_CONTROLS_MESSAGE = 34;
   */
  TOURNAMENT_DIVISION_ROUND_CONTROLS_MESSAGE = 34,

  /**
   * @generated from enum value: TOURNAMENT_DIVISION_PAIRINGS_MESSAGE = 35;
   */
  TOURNAMENT_DIVISION_PAIRINGS_MESSAGE = 35,

  /**
   * @generated from enum value: TOURNAMENT_DIVISION_CONTROLS_MESSAGE = 36;
   */
  TOURNAMENT_DIVISION_CONTROLS_MESSAGE = 36,

  /**
   * @generated from enum value: TOURNAMENT_DIVISION_PLAYER_CHANGE_MESSAGE = 37;
   */
  TOURNAMENT_DIVISION_PLAYER_CHANGE_MESSAGE = 37,

  /**
   * @generated from enum value: TOURNAMENT_FINISHED_MESSAGE = 38;
   */
  TOURNAMENT_FINISHED_MESSAGE = 38,

  /**
   * @generated from enum value: TOURNAMENT_DIVISION_PAIRINGS_DELETED_MESSAGE = 39;
   */
  TOURNAMENT_DIVISION_PAIRINGS_DELETED_MESSAGE = 39,

  /**
   * @generated from enum value: PRESENCE_ENTRY = 40;
   */
  PRESENCE_ENTRY = 40,

  /**
   * @generated from enum value: ACTIVE_GAME_ENTRY = 41;
   */
  ACTIVE_GAME_ENTRY = 41,

  /**
   * @generated from enum value: GAME_META_EVENT = 42;
   */
  GAME_META_EVENT = 42,

  /**
   * @generated from enum value: PROFILE_UPDATE_EVENT = 43;
   */
  PROFILE_UPDATE_EVENT = 43,

  /**
   * Add more events here. The total number of events should fit in a byte.
   * We should definitely not be using anywhere close to 255 events, and
   * in order to enforce that I'll be forcing the event type header to just be
   * a byte long.
   *
   * @generated from enum value: OMGWORDS_GAMEPLAY_EVENT = 44;
   */
  OMGWORDS_GAMEPLAY_EVENT = 44,

  /**
   * @generated from enum value: OMGWORDS_GAMEDOCUMENT = 45;
   */
  OMGWORDS_GAMEDOCUMENT = 45,

  /**
   * @generated from enum value: TOURNAMENT_PLAYER_CHECKIN = 46;
   */
  TOURNAMENT_PLAYER_CHECKIN = 46,

  /**
   * @generated from enum value: OUR_CORRESPONDENCE_GAMES = 47;
   */
  OUR_CORRESPONDENCE_GAMES = 47,

  /**
   * @generated from enum value: OUR_CORRESPONDENCE_SEEKS = 48;
   */
  OUR_CORRESPONDENCE_SEEKS = 48,

  /**
   * @generated from enum value: MONITORING_STREAM_STATUS_UPDATE = 49;
   */
  MONITORING_STREAM_STATUS_UPDATE = 49,

  /**
   * @generated from enum value: OUR_LEAGUE_CORRESPONDENCE_GAMES = 50;
   */
  OUR_LEAGUE_CORRESPONDENCE_GAMES = 50,

  /**
   * Protocol V2 messages for persistent socket connections
   *
   * Client -> Server (first message for v2)
   *
   * @generated from enum value: HANDSHAKE = 60;
   */
  HANDSHAKE = 60,

  /**
   * Server -> Client
   *
   * @generated from enum value: HANDSHAKE_ACK = 61;
   */
  HANDSHAKE_ACK = 61,

  /**
   * Client -> Server
   *
   * @generated from enum value: SUBSCRIBE_REQUEST = 62;
   */
  SUBSCRIBE_REQUEST = 62,

  /**
   * Server -> Client
   *
   * @generated from enum value: SUBSCRIBE_RESPONSE = 63;
   */
  SUBSCRIBE_RESPONSE = 63,

  /**
   * Client -> Server
   *
   * @generated from enum value: UNSUBSCRIBE_REQUEST = 64;
   */
  UNSUBSCRIBE_REQUEST = 64,
}

/**
 * Describes the enum ipc.MessageType.
 */
export const MessageTypeSchema: GenEnum<MessageType> = /*@__PURE__*/
  enumDesc(file_proto_ipc_ipc, 0);

/**
 * @generated from enum ipc.ProtocolVersion
 */
export enum ProtocolVersion {
  /**
   * Legacy: 2-byte length prefix, reconnect per page
   *
   * @generated from enum value: PROTOCOL_V1 = 0;
   */
  PROTOCOL_V1 = 0,

  /**
   * New: 3-byte length prefix, dynamic subscriptions
   *
   * @generated from enum value: PROTOCOL_V2 = 1;
   */
  PROTOCOL_V2 = 1,
}

/**
 * Describes the enum ipc.ProtocolVersion.
 */
export const ProtocolVersionSchema: GenEnum<ProtocolVersion> = /*@__PURE__*/
  enumDesc(file_proto_ipc_ipc, 1);

