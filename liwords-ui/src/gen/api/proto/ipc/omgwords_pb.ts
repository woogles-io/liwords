// messages related to the omgwords game, used mainly by IPC
// note: omgwords is the crossword board game, and includes variants dogworms,
// superomgwords, etc etc

// @generated by protoc-gen-es v2.6.3 with parameter "target=ts"
// @generated from file proto/ipc/omgwords.proto (package ipc, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { BotRequest_BotCode, ChallengeRule as ChallengeRule$1, GameEvent as GameEvent$1, GameHistory, PlayState as PlayState$1 } from "../../vendor/macondo/macondo_pb";
import { file_vendor_macondo_macondo } from "../../vendor/macondo/macondo_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file proto/ipc/omgwords.proto.
 */
export const file_proto_ipc_omgwords: GenFile = /*@__PURE__*/
  fileDesc("Chhwcm90by9pcGMvb21nd29yZHMucHJvdG8SA2lwYyL2AQoTQ2xpZW50R2FtZXBsYXlFdmVudBIwCgR0eXBlGAEgASgOMiIuaXBjLkNsaWVudEdhbWVwbGF5RXZlbnQuRXZlbnRUeXBlEg8KB2dhbWVfaWQYAiABKAkSFwoPcG9zaXRpb25fY29vcmRzGAMgASgJEhEKBXRpbGVzGAQgASgJQgIYARIXCg9tYWNoaW5lX2xldHRlcnMYBSABKAwiVwoJRXZlbnRUeXBlEhIKDlRJTEVfUExBQ0VNRU5UEAASCAoEUEFTUxABEgwKCEVYQ0hBTkdFEAISEgoOQ0hBTExFTkdFX1BMQVkQAxIKCgZSRVNJR04QBCJeCglHYW1lUnVsZXMSGQoRYm9hcmRfbGF5b3V0X25hbWUYASABKAkSIAoYbGV0dGVyX2Rpc3RyaWJ1dGlvbl9uYW1lGAIgASgJEhQKDHZhcmlhbnRfbmFtZRgDIAEoCSKDAwoLR2FtZVJlcXVlc3QSDwoHbGV4aWNvbhgBIAEoCRIdCgVydWxlcxgCIAEoCzIOLmlwYy5HYW1lUnVsZXMSHAoUaW5pdGlhbF90aW1lX3NlY29uZHMYAyABKAUSGQoRaW5jcmVtZW50X3NlY29uZHMYBCABKAUSLgoOY2hhbGxlbmdlX3J1bGUYBSABKA4yFi5tYWNvbmRvLkNoYWxsZW5nZVJ1bGUSIAoJZ2FtZV9tb2RlGAYgASgOMg0uaXBjLkdhbWVNb2RlEiQKC3JhdGluZ19tb2RlGAcgASgOMg8uaXBjLlJhdGluZ01vZGUSEgoKcmVxdWVzdF9pZBgIIAEoCRIcChRtYXhfb3ZlcnRpbWVfbWludXRlcxgJIAEoBRIVCg1wbGF5ZXJfdnNfYm90GAogASgIEhsKE29yaWdpbmFsX3JlcXVlc3RfaWQYCyABKAkSLQoIYm90X3R5cGUYDCABKA4yGy5tYWNvbmRvLkJvdFJlcXVlc3QuQm90Q29kZSK2AwoNR2FtZU1ldGFFdmVudBIVCg1vcmlnX2V2ZW50X2lkGAEgASgJEi0KCXRpbWVzdGFtcBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASKgoEdHlwZRgDIAEoDjIcLmlwYy5HYW1lTWV0YUV2ZW50LkV2ZW50VHlwZRIRCglwbGF5ZXJfaWQYBCABKAkSDwoHZ2FtZV9pZBgFIAEoCRIOCgZleHBpcnkYBiABKAUi/gEKCUV2ZW50VHlwZRIRCg1SRVFVRVNUX0FCT1JUEAASGAoUUkVRVUVTVF9BREpVRElDQVRJT04QARIQCgxSRVFVRVNUX1VORE8QAhITCg9SRVFVRVNUX0FESk9VUk4QAxISCg5BQk9SVF9BQ0NFUFRFRBAEEhAKDEFCT1JUX0RFTklFRBAFEhkKFUFESlVESUNBVElPTl9BQ0NFUFRFRBAGEhcKE0FESlVESUNBVElPTl9ERU5JRUQQBxIRCg1VTkRPX0FDQ0VQVEVEEAgSDwoLVU5ET19ERU5JRUQQCRIMCghBRERfVElNRRAKEhEKDVRJTUVSX0VYUElSRUQQCyK2AQoUR2FtZUhpc3RvcnlSZWZyZXNoZXISJQoHaGlzdG9yeRgBIAEoCzIULm1hY29uZG8uR2FtZUhpc3RvcnkSFAoMdGltZV9wbGF5ZXIxGAIgASgFEhQKDHRpbWVfcGxheWVyMhgDIAEoBRIcChRtYXhfb3ZlcnRpbWVfbWludXRlcxgEIAEoBRItChFvdXRzdGFuZGluZ19ldmVudBgFIAEoCzISLmlwYy5HYW1lTWV0YUV2ZW50IjMKEUdhbWVEb2N1bWVudEV2ZW50Eh4KA2RvYxgBIAEoCzIRLmlwYy5HYW1lRG9jdW1lbnQiWQoVVG91cm5hbWVudERhdGFGb3JHYW1lEgsKA3RpZBgBIAEoCRIQCghkaXZpc2lvbhgCIAEoCRINCgVyb3VuZBgDIAEoBRISCgpnYW1lX2luZGV4GAQgASgFIpoBCgpQbGF5ZXJJbmZvEg8KB3VzZXJfaWQYASABKAkSEAoIbmlja25hbWUYAiABKAkSEQoJZnVsbF9uYW1lGAMgASgJEhQKDGNvdW50cnlfY29kZRgEIAEoCRIOCgZyYXRpbmcYBSABKAkSDQoFdGl0bGUYBiABKAkSDgoGaXNfYm90GAggASgIEhEKBWZpcnN0GAkgASgIQgIYASLAAwoQR2FtZUluZm9SZXNwb25zZRIgCgdwbGF5ZXJzGAEgAygLMg8uaXBjLlBsYXllckluZm8SGQoRdGltZV9jb250cm9sX25hbWUYBCABKAkSFQoNdG91cm5hbWVudF9pZBgGIAEoCRIrCg9nYW1lX2VuZF9yZWFzb24YCyABKA4yEi5pcGMuR2FtZUVuZFJlYXNvbhIOCgZzY29yZXMYDSADKAUSDgoGd2lubmVyGA4gASgFEi4KCmNyZWF0ZWRfYXQYDyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEg8KB2dhbWVfaWQYECABKAkSLwoLbGFzdF91cGRhdGUYEiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiYKDGdhbWVfcmVxdWVzdBgTIAEoCzIQLmlwYy5HYW1lUmVxdWVzdBIbChN0b3VybmFtZW50X2RpdmlzaW9uGBQgASgJEhgKEHRvdXJuYW1lbnRfcm91bmQYFSABKAUSHQoVdG91cm5hbWVudF9nYW1lX2luZGV4GBYgASgFEhsKBHR5cGUYFyABKA4yDS5pcGMuR2FtZVR5cGUiPQoRR2FtZUluZm9SZXNwb25zZXMSKAoJZ2FtZV9pbmZvGAEgAygLMhUuaXBjLkdhbWVJbmZvUmVzcG9uc2UimAEKD0luc3RhbnRpYXRlR2FtZRIQCgh1c2VyX2lkcxgBIAMoCRImCgxnYW1lX3JlcXVlc3QYAiABKAsyEC5pcGMuR2FtZVJlcXVlc3QSFgoOYXNzaWduZWRfZmlyc3QYAyABKAUSMwoPdG91cm5hbWVudF9kYXRhGAQgASgLMhouaXBjLlRvdXJuYW1lbnREYXRhRm9yR2FtZSIaCgxHYW1lRGVsZXRpb24SCgoCaWQYASABKAkiNQoQQWN0aXZlR2FtZVBsYXllchIQCgh1c2VybmFtZRgBIAEoCRIPCgd1c2VyX2lkGAIgASgJIlEKD0FjdGl2ZUdhbWVFbnRyeRIKCgJpZBgBIAEoCRIlCgZwbGF5ZXIYAiADKAsyFS5pcGMuQWN0aXZlR2FtZVBsYXllchILCgN0dGwYAyABKAMiHwoMUmVhZHlGb3JHYW1lEg8KB2dhbWVfaWQYASABKAkiqQEKE1NlcnZlckdhbWVwbGF5RXZlbnQSIQoFZXZlbnQYASABKAsyEi5tYWNvbmRvLkdhbWVFdmVudBIPCgdnYW1lX2lkGAIgASgJEhAKCG5ld19yYWNrGAMgASgJEhYKDnRpbWVfcmVtYWluaW5nGAQgASgFEiMKB3BsYXlpbmcYBSABKA4yEi5tYWNvbmRvLlBsYXlTdGF0ZRIPCgd1c2VyX2lkGAYgASgJIqEBChNTZXJ2ZXJPTUdXb3Jkc0V2ZW50Eh0KBWV2ZW50GAEgASgLMg4uaXBjLkdhbWVFdmVudBIPCgdnYW1lX2lkGAIgASgJEhAKCG5ld19yYWNrGAMgASgMEhYKDnRpbWVfcmVtYWluaW5nGAQgASgFEh8KB3BsYXlpbmcYBSABKA4yDi5pcGMuUGxheVN0YXRlEg8KB3VzZXJfaWQYBiABKAkihwEKGlNlcnZlckNoYWxsZW5nZVJlc3VsdEV2ZW50Eg0KBXZhbGlkGAEgASgIEhIKCmNoYWxsZW5nZXIYAiABKAkSLgoOY2hhbGxlbmdlX3J1bGUYAyABKA4yFi5tYWNvbmRvLkNoYWxsZW5nZVJ1bGUSFgoOcmV0dXJuZWRfdGlsZXMYBCABKAkihQEKHE9NR1dvcmRzQ2hhbGxlbmdlUmVzdWx0RXZlbnQSDQoFdmFsaWQYASABKAgSEgoKY2hhbGxlbmdlchgCIAEoCRIqCg5jaGFsbGVuZ2VfcnVsZRgDIAEoDjISLmlwYy5DaGFsbGVuZ2VSdWxlEhYKDnJldHVybmVkX3RpbGVzGAQgASgMItkDCg5HYW1lRW5kZWRFdmVudBIvCgZzY29yZXMYASADKAsyHy5pcGMuR2FtZUVuZGVkRXZlbnQuU2NvcmVzRW50cnkSOAoLbmV3X3JhdGluZ3MYAiADKAsyIy5pcGMuR2FtZUVuZGVkRXZlbnQuTmV3UmF0aW5nc0VudHJ5EiYKCmVuZF9yZWFzb24YAyABKA4yEi5pcGMuR2FtZUVuZFJlYXNvbhIOCgZ3aW5uZXIYBCABKAkSDQoFbG9zZXIYBSABKAkSCwoDdGllGAYgASgIEgwKBHRpbWUYByABKAMSPAoNcmF0aW5nX2RlbHRhcxgIIAMoCzIlLmlwYy5HYW1lRW5kZWRFdmVudC5SYXRpbmdEZWx0YXNFbnRyeRIlCgdoaXN0b3J5GAkgASgLMhQubWFjb25kby5HYW1lSGlzdG9yeRotCgtTY29yZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAU6AjgBGjEKD05ld1JhdGluZ3NFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAU6AjgBGjMKEVJhdGluZ0RlbHRhc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoBToCOAEiLgoTUmVtYXRjaFN0YXJ0ZWRFdmVudBIXCg9yZW1hdGNoX2dhbWVfaWQYASABKAkiTAoMTmV3R2FtZUV2ZW50Eg8KB2dhbWVfaWQYASABKAkSFQoNcmVxdWVzdGVyX2NpZBgCIAEoCRIUCgxhY2NlcHRlcl9jaWQYAyABKAkiLAoIVGltZWRPdXQSDwoHZ2FtZV9pZBgBIAEoCRIPCgd1c2VyX2lkGAIgASgJIsUFCglHYW1lRXZlbnQSDAoEbm90ZRgCIAEoCRIMCgRyYWNrGAMgASgMEiEKBHR5cGUYBCABKA4yEy5pcGMuR2FtZUV2ZW50LlR5cGUSEgoKY3VtdWxhdGl2ZRgFIAEoBRILCgNyb3cYBiABKAUSDgoGY29sdW1uGAcgASgFEisKCWRpcmVjdGlvbhgIIAEoDjIYLmlwYy5HYW1lRXZlbnQuRGlyZWN0aW9uEhAKCHBvc2l0aW9uGAkgASgJEhQKDHBsYXllZF90aWxlcxgKIAEoDBIRCglleGNoYW5nZWQYCyABKAwSDQoFc2NvcmUYDCABKAUSDQoFYm9udXMYDSABKAUSFwoPZW5kX3JhY2tfcG9pbnRzGA4gASgFEhIKCmxvc3Rfc2NvcmUYDyABKAUSEAoIaXNfYmluZ28YECABKAgSFAoMd29yZHNfZm9ybWVkGBEgAygMEhgKEG1pbGxpc19yZW1haW5pbmcYEiABKAUSFAoMcGxheWVyX2luZGV4GBMgASgNEh0KFXdvcmRzX2Zvcm1lZF9mcmllbmRseRgUIAMoCSLyAQoEVHlwZRIXChNUSUxFX1BMQUNFTUVOVF9NT1ZFEAASGAoUUEhPTllfVElMRVNfUkVUVVJORUQQARIICgRQQVNTEAISEwoPQ0hBTExFTkdFX0JPTlVTEAMSDAoIRVhDSEFOR0UQBBIQCgxFTkRfUkFDS19QVFMQBRIQCgxUSU1FX1BFTkFMVFkQBhIUChBFTkRfUkFDS19QRU5BTFRZEAcSJAogVU5TVUNDRVNTRlVMX0NIQUxMRU5HRV9UVVJOX0xPU1MQCBINCglDSEFMTEVOR0UQCRINCglUSU1FRF9PVVQQChIMCghSRVNJR05FRBALIikKCURpcmVjdGlvbhIOCgpIT1JJWk9OVEFMEAASDAoIVkVSVElDQUwQASK8AQoGVGltZXJzEhsKE3RpbWVfb2ZfbGFzdF91cGRhdGUYASABKAMSFAoMdGltZV9zdGFydGVkGAIgASgDEhYKDnRpbWVfcmVtYWluaW5nGAMgAygDEhQKDG1heF9vdmVydGltZRgEIAEoBRIZChFpbmNyZW1lbnRfc2Vjb25kcxgFIAEoBRIlCh1yZXNldF90b19pbmNyZW1lbnRfYWZ0ZXJfdHVybhgGIAEoCBIPCgd1bnRpbWVkGAcgASgIIjMKDU1ldGFFdmVudERhdGESIgoGZXZlbnRzGAEgAygLMhIuaXBjLkdhbWVNZXRhRXZlbnQiUAoJR2FtZUJvYXJkEhAKCG51bV9yb3dzGAEgASgFEhAKCG51bV9jb2xzGAIgASgFEg0KBXRpbGVzGAMgASgMEhAKCGlzX2VtcHR5GAQgASgIIhQKA0JhZxINCgV0aWxlcxgBIAEoDCKKBgoMR2FtZURvY3VtZW50EjQKB3BsYXllcnMYASADKAsyIy5pcGMuR2FtZURvY3VtZW50Lk1pbmltYWxQbGF5ZXJJbmZvEh4KBmV2ZW50cxgCIAMoCzIOLmlwYy5HYW1lRXZlbnQSDwoHdmVyc2lvbhgDIAEoDRIPCgdsZXhpY29uGAQgASgJEgsKA3VpZBgFIAEoCRITCgtkZXNjcmlwdGlvbhgGIAEoCRINCgVyYWNrcxgHIAMoDBIqCg5jaGFsbGVuZ2VfcnVsZRgIIAEoDjISLmlwYy5DaGFsbGVuZ2VSdWxlEiIKCnBsYXlfc3RhdGUYCSABKA4yDi5pcGMuUGxheVN0YXRlEhYKDmN1cnJlbnRfc2NvcmVzGAogAygFEg8KB3ZhcmlhbnQYCyABKAkSDgoGd2lubmVyGAwgASgFEhQKDGJvYXJkX2xheW91dBgNIAEoCRIbChNsZXR0ZXJfZGlzdHJpYnV0aW9uGA4gASgJEhsKBHR5cGUYDyABKA4yDS5pcGMuR2FtZVR5cGUSFgoOdGltZXJzX3N0YXJ0ZWQYECABKAgSJgoKZW5kX3JlYXNvbhgRIAEoDjISLmlwYy5HYW1lRW5kUmVhc29uEisKD21ldGFfZXZlbnRfZGF0YRgSIAEoCzISLmlwYy5NZXRhRXZlbnREYXRhEi4KCmNyZWF0ZWRfYXQYEyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEh0KBWJvYXJkGBQgASgLMg4uaXBjLkdhbWVCb2FyZBIVCgNiYWcYFSABKAsyCC5pcGMuQmFnEhcKD3Njb3JlbGVzc190dXJucxgWIAEoDRIWCg5wbGF5ZXJfb25fdHVybhgXIAEoDRIbCgZ0aW1lcnMYGCABKAsyCy5pcGMuVGltZXJzGlcKEU1pbmltYWxQbGF5ZXJJbmZvEhAKCG5pY2tuYW1lGAEgASgJEhEKCXJlYWxfbmFtZRgCIAEoCRIPCgd1c2VyX2lkGAMgASgJEgwKBHF1aXQYBCABKAgqnAEKDUdhbWVFbmRSZWFzb24SCAoETk9ORRAAEggKBFRJTUUQARIMCghTVEFOREFSRBACEhYKEkNPTlNFQ1VUSVZFX1pFUk9FUxADEgwKCFJFU0lHTkVEEAQSCwoHQUJPUlRFRBAFEhQKEFRSSVBMRV9DSEFMTEVOR0UQBhINCglDQU5DRUxMRUQQBxIRCg1GT1JDRV9GT1JGRUlUEAgqLQoIR2FtZU1vZGUSDQoJUkVBTF9USU1FEAASEgoOQ09SUkVTUE9OREVOQ0UQASojCgpSYXRpbmdNb2RlEgkKBVJBVEVEEAASCgoGQ0FTVUFMEAEqNQoIR2FtZVR5cGUSCgoGTkFUSVZFEAASDQoJQU5OT1RBVEVEEAESDgoKQk9UX1ZTX0JPVBACKlIKCVBsYXlTdGF0ZRILCgdQTEFZSU5HEAASGgoWV0FJVElOR19GT1JfRklOQUxfUEFTUxABEg0KCUdBTUVfT1ZFUhACEg0KCVVOU1RBUlRFRBADKrABCg1DaGFsbGVuZ2VSdWxlEhYKEkNoYWxsZW5nZVJ1bGVfVk9JRBAAEhgKFENoYWxsZW5nZVJ1bGVfU0lOR0xFEAESGAoUQ2hhbGxlbmdlUnVsZV9ET1VCTEUQAhIcChhDaGFsbGVuZ2VSdWxlX0ZJVkVfUE9JTlQQAxIbChdDaGFsbGVuZ2VSdWxlX1RFTl9QT0lOVBAEEhgKFENoYWxsZW5nZVJ1bGVfVFJJUExFEAVCdQoHY29tLmlwY0INT21nd29yZHNQcm90b1ABWi9naXRodWIuY29tL3dvb2dsZXMtaW8vbGl3b3Jkcy9ycGMvYXBpL3Byb3RvL2lwY6ICA0lYWKoCA0lwY8oCA0lwY+ICD0lwY1xHUEJNZXRhZGF0YeoCA0lwY2IGcHJvdG8z", [file_vendor_macondo_macondo, file_google_protobuf_timestamp]);

/**
 * @generated from message ipc.ClientGameplayEvent
 */
export type ClientGameplayEvent = Message<"ipc.ClientGameplayEvent"> & {
  /**
   * @generated from field: ipc.ClientGameplayEvent.EventType type = 1;
   */
  type: ClientGameplayEvent_EventType;

  /**
   * @generated from field: string game_id = 2;
   */
  gameId: string;

  /**
   * position coordinates, like H8 or G10. Only matters for TILE_PLACEMENT.
   *
   * @generated from field: string position_coords = 3;
   */
  positionCoords: string;

  /**
   * tiles that are being played (or exchanged). The `.` character is used
   * for thru, and lowercase characters are used for blanks.
   *
   * @generated from field: string tiles = 4 [deprecated = true];
   * @deprecated
   */
  tiles: string;

  /**
   * machine_letters is tiles, but in binary.
   *
   * @generated from field: bytes machine_letters = 5;
   */
  machineLetters: Uint8Array;
};

/**
 * Describes the message ipc.ClientGameplayEvent.
 * Use `create(ClientGameplayEventSchema)` to create a new message.
 */
export const ClientGameplayEventSchema: GenMessage<ClientGameplayEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 0);

/**
 * @generated from enum ipc.ClientGameplayEvent.EventType
 */
export enum ClientGameplayEvent_EventType {
  /**
   * @generated from enum value: TILE_PLACEMENT = 0;
   */
  TILE_PLACEMENT = 0,

  /**
   * @generated from enum value: PASS = 1;
   */
  PASS = 1,

  /**
   * @generated from enum value: EXCHANGE = 2;
   */
  EXCHANGE = 2,

  /**
   * @generated from enum value: CHALLENGE_PLAY = 3;
   */
  CHALLENGE_PLAY = 3,

  /**
   * @generated from enum value: RESIGN = 4;
   */
  RESIGN = 4,
}

/**
 * Describes the enum ipc.ClientGameplayEvent.EventType.
 */
export const ClientGameplayEvent_EventTypeSchema: GenEnum<ClientGameplayEvent_EventType> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 0, 0);

/**
 * A GameRules is just the name of a board layout + the name of a letter
 * distribution. These must exist in a database or file somewhere.
 *
 * @generated from message ipc.GameRules
 */
export type GameRules = Message<"ipc.GameRules"> & {
  /**
   * The supported board layout names are CrosswordGame and SuperCrosswordGame
   *
   * @generated from field: string board_layout_name = 1;
   */
  boardLayoutName: string;

  /**
   * The supported letter distributions are english, french, norwegian, german,
   * catalan, spanish. There are more to come!
   *
   * @generated from field: string letter_distribution_name = 2;
   */
  letterDistributionName: string;

  /**
   * Use "classic" for our classic game, otherwise it could be some other game
   * (a is worth 100, dogworms, etc.)
   *
   * @generated from field: string variant_name = 3;
   */
  variantName: string;
};

/**
 * Describes the message ipc.GameRules.
 * Use `create(GameRulesSchema)` to create a new message.
 */
export const GameRulesSchema: GenMessage<GameRules> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 1);

/**
 * @generated from message ipc.GameRequest
 */
export type GameRequest = Message<"ipc.GameRequest"> & {
  /**
   * @generated from field: string lexicon = 1;
   */
  lexicon: string;

  /**
   * @generated from field: ipc.GameRules rules = 2;
   */
  rules?: GameRules;

  /**
   * @generated from field: int32 initial_time_seconds = 3;
   */
  initialTimeSeconds: number;

  /**
   * @generated from field: int32 increment_seconds = 4;
   */
  incrementSeconds: number;

  /**
   * @generated from field: macondo.ChallengeRule challenge_rule = 5;
   */
  challengeRule: ChallengeRule$1;

  /**
   * @generated from field: ipc.GameMode game_mode = 6;
   */
  gameMode: GameMode;

  /**
   * @generated from field: ipc.RatingMode rating_mode = 7;
   */
  ratingMode: RatingMode;

  /**
   * @generated from field: string request_id = 8;
   */
  requestId: string;

  /**
   * @generated from field: int32 max_overtime_minutes = 9;
   */
  maxOvertimeMinutes: number;

  /**
   * @generated from field: bool player_vs_bot = 10;
   */
  playerVsBot: boolean;

  /**
   * @generated from field: string original_request_id = 11;
   */
  originalRequestId: string;

  /**
   * @generated from field: macondo.BotRequest.BotCode bot_type = 12;
   */
  botType: BotRequest_BotCode;
};

/**
 * Describes the message ipc.GameRequest.
 * Use `create(GameRequestSchema)` to create a new message.
 */
export const GameRequestSchema: GenMessage<GameRequest> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 2);

/**
 * GameMetaEvent defines how we serialize meta events to the database.
 *
 * @generated from message ipc.GameMetaEvent
 */
export type GameMetaEvent = Message<"ipc.GameMetaEvent"> & {
  /**
   * @generated from field: string orig_event_id = 1;
   */
  origEventId: string;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: ipc.GameMetaEvent.EventType type = 3;
   */
  type: GameMetaEvent_EventType;

  /**
   * the player that performed the event.
   *
   * @generated from field: string player_id = 4;
   */
  playerId: string;

  /**
   * @generated from field: string game_id = 5;
   */
  gameId: string;

  /**
   * how long should this event remain active, in milliseconds?
   *
   * @generated from field: int32 expiry = 6;
   */
  expiry: number;
};

/**
 * Describes the message ipc.GameMetaEvent.
 * Use `create(GameMetaEventSchema)` to create a new message.
 */
export const GameMetaEventSchema: GenMessage<GameMetaEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 3);

/**
 * @generated from enum ipc.GameMetaEvent.EventType
 */
export enum GameMetaEvent_EventType {
  /**
   * These are "original events"
   *
   * @generated from enum value: REQUEST_ABORT = 0;
   */
  REQUEST_ABORT = 0,

  /**
   * Adjudication is just seen as a "nudge" on the front end.
   *
   * @generated from enum value: REQUEST_ADJUDICATION = 1;
   */
  REQUEST_ADJUDICATION = 1,

  /**
   * @generated from enum value: REQUEST_UNDO = 2;
   */
  REQUEST_UNDO = 2,

  /**
   * Are we going to implement this someday?
   *
   * @generated from enum value: REQUEST_ADJOURN = 3;
   */
  REQUEST_ADJOURN = 3,

  /**
   * And these are responses:
   * A user can accept an abort, or the client will auto-accept when time
   * expires:
   *
   * @generated from enum value: ABORT_ACCEPTED = 4;
   */
  ABORT_ACCEPTED = 4,

  /**
   * @generated from enum value: ABORT_DENIED = 5;
   */
  ABORT_DENIED = 5,

  /**
   * A user would not accept an adjudication. The client auto-accepts this
   * when time expires
   *
   * @generated from enum value: ADJUDICATION_ACCEPTED = 6;
   */
  ADJUDICATION_ACCEPTED = 6,

  /**
   * An adjudication is denied when the receiver responds positively to a
   * nudge.
   *
   * @generated from enum value: ADJUDICATION_DENIED = 7;
   */
  ADJUDICATION_DENIED = 7,

  /**
   * @generated from enum value: UNDO_ACCEPTED = 8;
   */
  UNDO_ACCEPTED = 8,

  /**
   * @generated from enum value: UNDO_DENIED = 9;
   */
  UNDO_DENIED = 9,

  /**
   * More:
   *
   * add X seconds at a time (30?) to opponent's clock
   *
   * @generated from enum value: ADD_TIME = 10;
   */
  ADD_TIME = 10,

  /**
   * Some meta events have a timer associated with them. Send this with the
   * original event id after time has expired.
   *
   * @generated from enum value: TIMER_EXPIRED = 11;
   */
  TIMER_EXPIRED = 11,
}

/**
 * Describes the enum ipc.GameMetaEvent.EventType.
 */
export const GameMetaEvent_EventTypeSchema: GenEnum<GameMetaEvent_EventType> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 3, 0);

/**
 * A GameHistoryRefresher is sent to both players when the game starts,
 * and any observers at the time that they begin observing. It can also be sent
 * to a player who reconnects in the middle of a game.
 *
 * @generated from message ipc.GameHistoryRefresher
 */
export type GameHistoryRefresher = Message<"ipc.GameHistoryRefresher"> & {
  /**
   * The history contains all the moves, points, as well as the last known racks
   * of each player. It also implicitly contains whose turn it is at the moment,
   * by the events / turns in the history.
   * The front-end is responsible for showing all this information in a nice
   * format.
   * Note: the racks of each player should not be sent to both players, only
   * to observers. The back-end will have to be smart enough to overwrite
   * this information with a blank string before sending it. It might not
   * even be that great of a big deal, as I'm sure people can devise other ways
   * to cheat, but shrug.
   *
   * @generated from field: macondo.GameHistory history = 1;
   */
  history?: GameHistory;

  /**
   * These represent how much time each player has remaining on their clock
   * as of the "refresher", in milliseconds.
   * player1 is the player who is listed first in the game history, regardless
   * of whether they went first.
   *
   * @generated from field: int32 time_player1 = 2;
   */
  timePlayer1: number;

  /**
   * @generated from field: int32 time_player2 = 3;
   */
  timePlayer2: number;

  /**
   * @generated from field: int32 max_overtime_minutes = 4;
   */
  maxOvertimeMinutes: number;

  /**
   * outstanding_event refers to any possible outstanding game meta event that
   * has not yet been responded to or expired.
   *
   * @generated from field: ipc.GameMetaEvent outstanding_event = 5;
   */
  outstandingEvent?: GameMetaEvent;
};

/**
 * Describes the message ipc.GameHistoryRefresher.
 * Use `create(GameHistoryRefresherSchema)` to create a new message.
 */
export const GameHistoryRefresherSchema: GenMessage<GameHistoryRefresher> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 4);

/**
 * A GameDocumentEvent should eventually replace the GameHistoryRefresher. For
 * now, it will be used for annotated games.
 *
 * @generated from message ipc.GameDocumentEvent
 */
export type GameDocumentEvent = Message<"ipc.GameDocumentEvent"> & {
  /**
   * @generated from field: ipc.GameDocument doc = 1;
   */
  doc?: GameDocument;
};

/**
 * Describes the message ipc.GameDocumentEvent.
 * Use `create(GameDocumentEventSchema)` to create a new message.
 */
export const GameDocumentEventSchema: GenMessage<GameDocumentEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 5);

/**
 * @generated from message ipc.TournamentDataForGame
 */
export type TournamentDataForGame = Message<"ipc.TournamentDataForGame"> & {
  /**
   * The ID of the tournament
   *
   * @generated from field: string tid = 1;
   */
  tid: string;

  /**
   * @generated from field: string division = 2;
   */
  division: string;

  /**
   * @generated from field: int32 round = 3;
   */
  round: number;

  /**
   * @generated from field: int32 game_index = 4;
   */
  gameIndex: number;
};

/**
 * Describes the message ipc.TournamentDataForGame.
 * Use `create(TournamentDataForGameSchema)` to create a new message.
 */
export const TournamentDataForGameSchema: GenMessage<TournamentDataForGame> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 6);

/**
 * Meta information about the player of a particular game.
 *
 * @generated from message ipc.PlayerInfo
 */
export type PlayerInfo = Message<"ipc.PlayerInfo"> & {
  /**
   * @generated from field: string user_id = 1;
   */
  userId: string;

  /**
   * @generated from field: string nickname = 2;
   */
  nickname: string;

  /**
   * @generated from field: string full_name = 3;
   */
  fullName: string;

  /**
   * @generated from field: string country_code = 4;
   */
  countryCode: string;

  /**
   * Rating for the particular mode of the game. String because it could be
   * provisional or some other strings.
   *
   * @generated from field: string rating = 5;
   */
  rating: string;

  /**
   * @generated from field: string title = 6;
   */
  title: string;

  /**
   * string avatar_url = 7; // the UserService now offers Avatar info
   *
   * @generated from field: bool is_bot = 8;
   */
  isBot: boolean;

  /**
   * first is true if the player went first. This is deprecated because it
   * is assumed the player listed first went first.
   *
   * @generated from field: bool first = 9 [deprecated = true];
   * @deprecated
   */
  first: boolean;
};

/**
 * Describes the message ipc.PlayerInfo.
 * Use `create(PlayerInfoSchema)` to create a new message.
 */
export const PlayerInfoSchema: GenMessage<PlayerInfo> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 7);

/**
 * @generated from message ipc.GameInfoResponse
 */
export type GameInfoResponse = Message<"ipc.GameInfoResponse"> & {
  /**
   * @generated from field: repeated ipc.PlayerInfo players = 1;
   */
  players: PlayerInfo[];

  /**
   * @generated from field: string time_control_name = 4;
   */
  timeControlName: string;

  /**
   * @generated from field: string tournament_id = 6;
   */
  tournamentId: string;

  /**
   * done - is game done?
   * bool done = 9;
   *
   * @generated from field: ipc.GameEndReason game_end_reason = 11;
   */
  gameEndReason: GameEndReason;

  /**
   * @generated from field: repeated int32 scores = 13;
   */
  scores: number[];

  /**
   * @generated from field: int32 winner = 14;
   */
  winner: number;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 15;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: string game_id = 16;
   */
  gameId: string;

  /**
   * @generated from field: google.protobuf.Timestamp last_update = 18;
   */
  lastUpdate?: Timestamp;

  /**
   * @generated from field: ipc.GameRequest game_request = 19;
   */
  gameRequest?: GameRequest;

  /**
   * @generated from field: string tournament_division = 20;
   */
  tournamentDivision: string;

  /**
   * @generated from field: int32 tournament_round = 21;
   */
  tournamentRound: number;

  /**
   * a game index within a round.
   *
   * @generated from field: int32 tournament_game_index = 22;
   */
  tournamentGameIndex: number;

  /**
   * @generated from field: ipc.GameType type = 23;
   */
  type: GameType;
};

/**
 * Describes the message ipc.GameInfoResponse.
 * Use `create(GameInfoResponseSchema)` to create a new message.
 */
export const GameInfoResponseSchema: GenMessage<GameInfoResponse> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 8);

/**
 * @generated from message ipc.GameInfoResponses
 */
export type GameInfoResponses = Message<"ipc.GameInfoResponses"> & {
  /**
   * @generated from field: repeated ipc.GameInfoResponse game_info = 1;
   */
  gameInfo: GameInfoResponse[];
};

/**
 * Describes the message ipc.GameInfoResponses.
 * Use `create(GameInfoResponsesSchema)` to create a new message.
 */
export const GameInfoResponsesSchema: GenMessage<GameInfoResponses> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 9);

/**
 * InstantiateGame is an internal message passed to gamesvc in order to
 * instantiate a game.
 *
 * @generated from message ipc.InstantiateGame
 */
export type InstantiateGame = Message<"ipc.InstantiateGame"> & {
  /**
   * @generated from field: repeated string user_ids = 1;
   */
  userIds: string[];

  /**
   * @generated from field: ipc.GameRequest game_request = 2;
   */
  gameRequest?: GameRequest;

  /**
   * assigned_first is -1 if random, or the player index in user_ids otherwise
   *
   * @generated from field: int32 assigned_first = 3;
   */
  assignedFirst: number;

  /**
   * @generated from field: ipc.TournamentDataForGame tournament_data = 4;
   */
  tournamentData?: TournamentDataForGame;
};

/**
 * Describes the message ipc.InstantiateGame.
 * Use `create(InstantiateGameSchema)` to create a new message.
 */
export const InstantiateGameSchema: GenMessage<InstantiateGame> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 10);

/**
 * @generated from message ipc.GameDeletion
 */
export type GameDeletion = Message<"ipc.GameDeletion"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message ipc.GameDeletion.
 * Use `create(GameDeletionSchema)` to create a new message.
 */
export const GameDeletionSchema: GenMessage<GameDeletion> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 11);

/**
 * @generated from message ipc.ActiveGamePlayer
 */
export type ActiveGamePlayer = Message<"ipc.ActiveGamePlayer"> & {
  /**
   * @generated from field: string username = 1;
   */
  username: string;

  /**
   * @generated from field: string user_id = 2;
   */
  userId: string;
};

/**
 * Describes the message ipc.ActiveGamePlayer.
 * Use `create(ActiveGamePlayerSchema)` to create a new message.
 */
export const ActiveGamePlayerSchema: GenMessage<ActiveGamePlayer> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 12);

/**
 * @generated from message ipc.ActiveGameEntry
 */
export type ActiveGameEntry = Message<"ipc.ActiveGameEntry"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: repeated ipc.ActiveGamePlayer player = 2;
   */
  player: ActiveGamePlayer[];

  /**
   * time to live, in seconds
   *
   * @generated from field: int64 ttl = 3;
   */
  ttl: bigint;
};

/**
 * Describes the message ipc.ActiveGameEntry.
 * Use `create(ActiveGameEntrySchema)` to create a new message.
 */
export const ActiveGameEntrySchema: GenMessage<ActiveGameEntry> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 13);

/**
 * @generated from message ipc.ReadyForGame
 */
export type ReadyForGame = Message<"ipc.ReadyForGame"> & {
  /**
   * @generated from field: string game_id = 1;
   */
  gameId: string;
};

/**
 * Describes the message ipc.ReadyForGame.
 * Use `create(ReadyForGameSchema)` to create a new message.
 */
export const ReadyForGameSchema: GenMessage<ReadyForGame> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 14);

/**
 * The server will send back a ServerGameplayEvent to a ClientGameplayEvent.
 * The server will also send these asynchronously for opponent gameplay
 * events.
 * XXX: This message type is obsolete and will be replaced by
 * ServerOMGWordsEvent
 *
 * @generated from message ipc.ServerGameplayEvent
 */
export type ServerGameplayEvent = Message<"ipc.ServerGameplayEvent"> & {
  /**
   * XXX: move to ipc.GameEvent
   *
   * @generated from field: macondo.GameEvent event = 1;
   */
  event?: GameEvent$1;

  /**
   * @generated from field: string game_id = 2;
   */
  gameId: string;

  /**
   * @generated from field: string new_rack = 3;
   */
  newRack: string;

  /**
   * @generated from field: int32 time_remaining = 4;
   */
  timeRemaining: number;

  /**
   * XXX: move to ipc.PlayState
   *
   * @generated from field: macondo.PlayState playing = 5;
   */
  playing: PlayState$1;

  /**
   * the event has the nickname, but not the userid.
   *
   * @generated from field: string user_id = 6;
   */
  userId: string;
};

/**
 * Describes the message ipc.ServerGameplayEvent.
 * Use `create(ServerGameplayEventSchema)` to create a new message.
 */
export const ServerGameplayEventSchema: GenMessage<ServerGameplayEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 15);

/**
 * ServerOMGWordsEvent is a new event type.
 *
 * @generated from message ipc.ServerOMGWordsEvent
 */
export type ServerOMGWordsEvent = Message<"ipc.ServerOMGWordsEvent"> & {
  /**
   * @generated from field: ipc.GameEvent event = 1;
   */
  event?: GameEvent;

  /**
   * @generated from field: string game_id = 2;
   */
  gameId: string;

  /**
   * @generated from field: bytes new_rack = 3;
   */
  newRack: Uint8Array;

  /**
   * @generated from field: int32 time_remaining = 4;
   */
  timeRemaining: number;

  /**
   * @generated from field: ipc.PlayState playing = 5;
   */
  playing: PlayState;

  /**
   * @generated from field: string user_id = 6;
   */
  userId: string;
};

/**
 * Describes the message ipc.ServerOMGWordsEvent.
 * Use `create(ServerOMGWordsEventSchema)` to create a new message.
 */
export const ServerOMGWordsEventSchema: GenMessage<ServerOMGWordsEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 16);

/**
 * The server will send back a challenge result event only in the case of
 * a challenge. In all other cases, the server will send back a
 * ServerGameplayEvent.
 * A ServerChallengeResultEvent is sent back along with a list of
 * ServerGameplayEvents, instead of trying to reconstruct and send the
 * right incremental events. The reason is that the logic is complex and
 * has many special cases, and is already fully implemented in Macondo.
 * We don't wish to re-implement it both in this repo's backend and frontend.
 * XXX: This message type is obsolete, and will be replaced by
 * OMGWordsChallengeResultEvent
 *
 * @generated from message ipc.ServerChallengeResultEvent
 */
export type ServerChallengeResultEvent = Message<"ipc.ServerChallengeResultEvent"> & {
  /**
   * @generated from field: bool valid = 1;
   */
  valid: boolean;

  /**
   * @generated from field: string challenger = 2;
   */
  challenger: string;

  /**
   * @generated from field: macondo.ChallengeRule challenge_rule = 3;
   */
  challengeRule: ChallengeRule$1;

  /**
   * @generated from field: string returned_tiles = 4;
   */
  returnedTiles: string;
};

/**
 * Describes the message ipc.ServerChallengeResultEvent.
 * Use `create(ServerChallengeResultEventSchema)` to create a new message.
 */
export const ServerChallengeResultEventSchema: GenMessage<ServerChallengeResultEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 17);

/**
 * @generated from message ipc.OMGWordsChallengeResultEvent
 */
export type OMGWordsChallengeResultEvent = Message<"ipc.OMGWordsChallengeResultEvent"> & {
  /**
   * @generated from field: bool valid = 1;
   */
  valid: boolean;

  /**
   * @generated from field: string challenger = 2;
   */
  challenger: string;

  /**
   * @generated from field: ipc.ChallengeRule challenge_rule = 3;
   */
  challengeRule: ChallengeRule;

  /**
   * @generated from field: bytes returned_tiles = 4;
   */
  returnedTiles: Uint8Array;
};

/**
 * Describes the message ipc.OMGWordsChallengeResultEvent.
 * Use `create(OMGWordsChallengeResultEventSchema)` to create a new message.
 */
export const OMGWordsChallengeResultEventSchema: GenMessage<OMGWordsChallengeResultEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 18);

/**
 * GameEndedEvent is always sent from the server to both clients.
 *
 * @generated from message ipc.GameEndedEvent
 */
export type GameEndedEvent = Message<"ipc.GameEndedEvent"> & {
  /**
   * @generated from field: map<string, int32> scores = 1;
   */
  scores: { [key: string]: number };

  /**
   * @generated from field: map<string, int32> new_ratings = 2;
   */
  newRatings: { [key: string]: number };

  /**
   * @generated from field: ipc.GameEndReason end_reason = 3;
   */
  endReason: GameEndReason;

  /**
   * The winner is not always the highest scoring player; one player can
   * time out. The end_reason should make it clear what happened.
   *
   * @generated from field: string winner = 4;
   */
  winner: string;

  /**
   * @generated from field: string loser = 5;
   */
  loser: string;

  /**
   * If it was a tie, the winner and loser above can be interchanged.
   *
   * @generated from field: bool tie = 6;
   */
  tie: boolean;

  /**
   * Time that the game ended
   *
   * @generated from field: int64 time = 7;
   */
  time: bigint;

  /**
   * @generated from field: map<string, int32> rating_deltas = 8;
   */
  ratingDeltas: { [key: string]: number };

  /**
   * Send the full game history again. This will have rack information in it.
   *
   * @generated from field: macondo.GameHistory history = 9;
   */
  history?: GameHistory;
};

/**
 * Describes the message ipc.GameEndedEvent.
 * Use `create(GameEndedEventSchema)` to create a new message.
 */
export const GameEndedEventSchema: GenMessage<GameEndedEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 19);

/**
 * RematchStartedEvent gets sent to a game for which there is a rematch.
 * It notifies that observers of the game that a rematch has started.
 *
 * @generated from message ipc.RematchStartedEvent
 */
export type RematchStartedEvent = Message<"ipc.RematchStartedEvent"> & {
  /**
   * rematch_game_id is the new game ID.
   *
   * @generated from field: string rematch_game_id = 1;
   */
  rematchGameId: string;
};

/**
 * Describes the message ipc.RematchStartedEvent.
 * Use `create(RematchStartedEventSchema)` to create a new message.
 */
export const RematchStartedEventSchema: GenMessage<RematchStartedEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 20);

/**
 * A NewGameEvent gets sent from the server to the involved clients when a new
 * game is about to begin. It should follow a SoughtGameProcessEvent.
 *
 * @generated from message ipc.NewGameEvent
 */
export type NewGameEvent = Message<"ipc.NewGameEvent"> & {
  /**
   * @generated from field: string game_id = 1;
   */
  gameId: string;

  /**
   * These are the connection IDs of the requesting and accepting users.
   *
   * @generated from field: string requester_cid = 2;
   */
  requesterCid: string;

  /**
   * @generated from field: string accepter_cid = 3;
   */
  accepterCid: string;
};

/**
 * Describes the message ipc.NewGameEvent.
 * Use `create(NewGameEventSchema)` to create a new message.
 */
export const NewGameEventSchema: GenMessage<NewGameEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 21);

/**
 * @generated from message ipc.TimedOut
 */
export type TimedOut = Message<"ipc.TimedOut"> & {
  /**
   * @generated from field: string game_id = 1;
   */
  gameId: string;

  /**
   * @generated from field: string user_id = 2;
   */
  userId: string;
};

/**
 * Describes the message ipc.TimedOut.
 * Use `create(TimedOutSchema)` to create a new message.
 */
export const TimedOutSchema: GenMessage<TimedOut> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 22);

/**
 * GameEvent is an internal game event, saved in the GameDocument.
 *
 * @generated from message ipc.GameEvent
 */
export type GameEvent = Message<"ipc.GameEvent"> & {
  /**
   * @generated from field: string note = 2;
   */
  note: string;

  /**
   * @generated from field: bytes rack = 3;
   */
  rack: Uint8Array;

  /**
   * @generated from field: ipc.GameEvent.Type type = 4;
   */
  type: GameEvent_Type;

  /**
   * @generated from field: int32 cumulative = 5;
   */
  cumulative: number;

  /**
   * @generated from field: int32 row = 6;
   */
  row: number;

  /**
   * @generated from field: int32 column = 7;
   */
  column: number;

  /**
   * @generated from field: ipc.GameEvent.Direction direction = 8;
   */
  direction: GameEvent_Direction;

  /**
   * @generated from field: string position = 9;
   */
  position: string;

  /**
   * @generated from field: bytes played_tiles = 10;
   */
  playedTiles: Uint8Array;

  /**
   * An event will not have all of these; it depends on the type of the event.
   *
   * @generated from field: bytes exchanged = 11;
   */
  exchanged: Uint8Array;

  /**
   * @generated from field: int32 score = 12;
   */
  score: number;

  /**
   * @generated from field: int32 bonus = 13;
   */
  bonus: number;

  /**
   * @generated from field: int32 end_rack_points = 14;
   */
  endRackPoints: number;

  /**
   * @generated from field: int32 lost_score = 15;
   */
  lostScore: number;

  /**
   * @generated from field: bool is_bingo = 16;
   */
  isBingo: boolean;

  /**
   * words_formed is a list of all words made by this play
   *
   * @generated from field: repeated bytes words_formed = 17;
   */
  wordsFormed: Uint8Array[];

  /**
   * @generated from field: int32 millis_remaining = 18;
   */
  millisRemaining: number;

  /**
   * The player who played this move is encoded in player_index. This should
   * be the index in GameDocument.players.
   *
   * @generated from field: uint32 player_index = 19;
   */
  playerIndex: number;

  /**
   * @generated from field: repeated string words_formed_friendly = 20;
   */
  wordsFormedFriendly: string[];
};

/**
 * Describes the message ipc.GameEvent.
 * Use `create(GameEventSchema)` to create a new message.
 */
export const GameEventSchema: GenMessage<GameEvent> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 23);

/**
 * @generated from enum ipc.GameEvent.Type
 */
export enum GameEvent_Type {
  /**
   * @generated from enum value: TILE_PLACEMENT_MOVE = 0;
   */
  TILE_PLACEMENT_MOVE = 0,

  /**
   * @generated from enum value: PHONY_TILES_RETURNED = 1;
   */
  PHONY_TILES_RETURNED = 1,

  /**
   * @generated from enum value: PASS = 2;
   */
  PASS = 2,

  /**
   * @generated from enum value: CHALLENGE_BONUS = 3;
   */
  CHALLENGE_BONUS = 3,

  /**
   * @generated from enum value: EXCHANGE = 4;
   */
  EXCHANGE = 4,

  /**
   * @generated from enum value: END_RACK_PTS = 5;
   */
  END_RACK_PTS = 5,

  /**
   * @generated from enum value: TIME_PENALTY = 6;
   */
  TIME_PENALTY = 6,

  /**
   * Only for international rules (or after 6 zeroes)
   *
   * @generated from enum value: END_RACK_PENALTY = 7;
   */
  END_RACK_PENALTY = 7,

  /**
   * Lose a turn for challenging a word incorrectly (only for double
   * challenge)
   *
   * @generated from enum value: UNSUCCESSFUL_CHALLENGE_TURN_LOSS = 8;
   */
  UNSUCCESSFUL_CHALLENGE_TURN_LOSS = 8,

  /**
   * Issue a challenge
   *
   * @generated from enum value: CHALLENGE = 9;
   */
  CHALLENGE = 9,

  /**
   * @generated from enum value: TIMED_OUT = 10;
   */
  TIMED_OUT = 10,

  /**
   * @generated from enum value: RESIGNED = 11;
   */
  RESIGNED = 11,
}

/**
 * Describes the enum ipc.GameEvent.Type.
 */
export const GameEvent_TypeSchema: GenEnum<GameEvent_Type> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 23, 0);

/**
 * @generated from enum ipc.GameEvent.Direction
 */
export enum GameEvent_Direction {
  /**
   * @generated from enum value: HORIZONTAL = 0;
   */
  HORIZONTAL = 0,

  /**
   * @generated from enum value: VERTICAL = 1;
   */
  VERTICAL = 1,
}

/**
 * Describes the enum ipc.GameEvent.Direction.
 */
export const GameEvent_DirectionSchema: GenEnum<GameEvent_Direction> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 23, 1);

/**
 * @generated from message ipc.Timers
 */
export type Timers = Message<"ipc.Timers"> & {
  /**
   * time_of_last_update is the timestamp of the last update, in milliseconds
   * If no update has been made, this defaults to timeStarted.
   *
   * @generated from field: int64 time_of_last_update = 1;
   */
  timeOfLastUpdate: bigint;

  /**
   * time_started is a unix timestamp, in milliseconds.
   *
   * @generated from field: int64 time_started = 2;
   */
  timeStarted: bigint;

  /**
   * time_remaining is an array of remaining time per player, in milliseconds
   *
   * @generated from field: repeated int64 time_remaining = 3;
   */
  timeRemaining: bigint[];

  /**
   * max_overtime is the number of minutes that the game is allowed to go
   * overtime
   *
   * @generated from field: int32 max_overtime = 4;
   */
  maxOvertime: number;

  /**
   * increment_seconds is the amount of seconds that is added to the timer
   * after every move
   *
   * @generated from field: int32 increment_seconds = 5;
   */
  incrementSeconds: number;

  /**
   * reset_to_increment_after_turn sets the timer for the player to
   * increment_seconds. this can be used for correspondence games; for example,
   * time_remaining and increment_seconds can be set to the same number of
   * seconds (let's say 5 days) at the beginning, and this flag can be set to
   * on. Then we should always have 5 days to make any move.
   *
   * @generated from field: bool reset_to_increment_after_turn = 6;
   */
  resetToIncrementAfterTurn: boolean;

  /**
   * If untimed is true, then Timers are not updated at all.
   *
   * @generated from field: bool untimed = 7;
   */
  untimed: boolean;
};

/**
 * Describes the message ipc.Timers.
 * Use `create(TimersSchema)` to create a new message.
 */
export const TimersSchema: GenMessage<Timers> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 24);

/**
 * @generated from message ipc.MetaEventData
 */
export type MetaEventData = Message<"ipc.MetaEventData"> & {
  /**
   * @generated from field: repeated ipc.GameMetaEvent events = 1;
   */
  events: GameMetaEvent[];
};

/**
 * Describes the message ipc.MetaEventData.
 * Use `create(MetaEventDataSchema)` to create a new message.
 */
export const MetaEventDataSchema: GenMessage<MetaEventData> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 25);

/**
 * @generated from message ipc.GameBoard
 */
export type GameBoard = Message<"ipc.GameBoard"> & {
  /**
   * @generated from field: int32 num_rows = 1;
   */
  numRows: number;

  /**
   * @generated from field: int32 num_cols = 2;
   */
  numCols: number;

  /**
   * tiles are laid out in row-major form
   *
   * @generated from field: bytes tiles = 3;
   */
  tiles: Uint8Array;

  /**
   *   repeated int32 h_cross_scores = 4;
   *   repeated int32 v_cross_scores = 5;
   *
   * @generated from field: bool is_empty = 4;
   */
  isEmpty: boolean;
};

/**
 * Describes the message ipc.GameBoard.
 * Use `create(GameBoardSchema)` to create a new message.
 */
export const GameBoardSchema: GenMessage<GameBoard> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 26);

/**
 * @generated from message ipc.Bag
 */
export type Bag = Message<"ipc.Bag"> & {
  /**
   * @generated from field: bytes tiles = 1;
   */
  tiles: Uint8Array;
};

/**
 * Describes the message ipc.Bag.
 * Use `create(BagSchema)` to create a new message.
 */
export const BagSchema: GenMessage<Bag> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 27);

/**
 * A GameDocument encodes the entire state of a game. It includes a history
 * of events, as well as information about the current state of the bag,
 * timers, etc. It should be possible to recreate an entire omgwords game
 * from a GameDocument state at any given time.
 *
 * @generated from message ipc.GameDocument
 */
export type GameDocument = Message<"ipc.GameDocument"> & {
  /**
   * players are in order of who went first.
   *
   * @generated from field: repeated ipc.GameDocument.MinimalPlayerInfo players = 1;
   */
  players: GameDocument_MinimalPlayerInfo[];

  /**
   * @generated from field: repeated ipc.GameEvent events = 2;
   */
  events: GameEvent[];

  /**
   * @generated from field: uint32 version = 3;
   */
  version: number;

  /**
   * @generated from field: string lexicon = 4;
   */
  lexicon: string;

  /**
   * @generated from field: string uid = 5;
   */
  uid: string;

  /**
   * @generated from field: string description = 6;
   */
  description: string;

  /**
   * @generated from field: repeated bytes racks = 7;
   */
  racks: Uint8Array[];

  /**
   * @generated from field: ipc.ChallengeRule challenge_rule = 8;
   */
  challengeRule: ChallengeRule;

  /**
   * @generated from field: ipc.PlayState play_state = 9;
   */
  playState: PlayState;

  /**
   * @generated from field: repeated int32 current_scores = 10;
   */
  currentScores: number[];

  /**
   * @generated from field: string variant = 11;
   */
  variant: string;

  /**
   * The index of the player who won, or -1 if it was a tie.
   *
   * @generated from field: int32 winner = 12;
   */
  winner: number;

  /**
   * The board layout is just the name for the layout of the board.
   * It should have a sensible default, if blank.
   *
   * @generated from field: string board_layout = 13;
   */
  boardLayout: string;

  /**
   * The letter distribution is the name of the distribution of tiles used for
   * this game. If blank, should default to "english".
   *
   * @generated from field: string letter_distribution = 14;
   */
  letterDistribution: string;

  /**
   * @generated from field: ipc.GameType type = 15;
   */
  type: GameType;

  /**
   * @generated from field: bool timers_started = 16;
   */
  timersStarted: boolean;

  /**
   * @generated from field: ipc.GameEndReason end_reason = 17;
   */
  endReason: GameEndReason;

  /**
   * @generated from field: ipc.MetaEventData meta_event_data = 18;
   */
  metaEventData?: MetaEventData;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 19;
   */
  createdAt?: Timestamp;

  /**
   * gameplay-specific structures:
   * board is the current state of the board
   *
   * @generated from field: ipc.GameBoard board = 20;
   */
  board?: GameBoard;

  /**
   * bag is the current tiles in the bag.
   *
   * @generated from field: ipc.Bag bag = 21;
   */
  bag?: Bag;

  /**
   * @generated from field: uint32 scoreless_turns = 22;
   */
  scorelessTurns: number;

  /**
   * The index of the player on turn
   *
   * @generated from field: uint32 player_on_turn = 23;
   */
  playerOnTurn: number;

  /**
   * @generated from field: ipc.Timers timers = 24;
   */
  timers?: Timers;
};

/**
 * Describes the message ipc.GameDocument.
 * Use `create(GameDocumentSchema)` to create a new message.
 */
export const GameDocumentSchema: GenMessage<GameDocument> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 28);

/**
 * @generated from message ipc.GameDocument.MinimalPlayerInfo
 */
export type GameDocument_MinimalPlayerInfo = Message<"ipc.GameDocument.MinimalPlayerInfo"> & {
  /**
   * @generated from field: string nickname = 1;
   */
  nickname: string;

  /**
   * @generated from field: string real_name = 2;
   */
  realName: string;

  /**
   * user_id is an internal, unchangeable user ID, whereas the other two user
   * identifiers might possibly be mutable.
   *
   * @generated from field: string user_id = 3;
   */
  userId: string;

  /**
   * @generated from field: bool quit = 4;
   */
  quit: boolean;
};

/**
 * Describes the message ipc.GameDocument.MinimalPlayerInfo.
 * Use `create(GameDocument_MinimalPlayerInfoSchema)` to create a new message.
 */
export const GameDocument_MinimalPlayerInfoSchema: GenMessage<GameDocument_MinimalPlayerInfo> = /*@__PURE__*/
  messageDesc(file_proto_ipc_omgwords, 28, 0);

/**
 * @generated from enum ipc.GameEndReason
 */
export enum GameEndReason {
  /**
   * NONE: the game has not yet ended!
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * TIME: one person timed out (and lost)
   *
   * @generated from enum value: TIME = 1;
   */
  TIME = 1,

  /**
   * WENT_OUT: game ended regularly, with one person having zero tiles on their
   * rack.
   *
   * @generated from enum value: STANDARD = 2;
   */
  STANDARD = 2,

  /**
   * 6 consecutive zeroes ends the game.
   *
   * @generated from enum value: CONSECUTIVE_ZEROES = 3;
   */
  CONSECUTIVE_ZEROES = 3,

  /**
   * @generated from enum value: RESIGNED = 4;
   */
  RESIGNED = 4,

  /**
   * Aborted games are aborted by mutual agreement.
   *
   * @generated from enum value: ABORTED = 5;
   */
  ABORTED = 5,

  /**
   * @generated from enum value: TRIPLE_CHALLENGE = 6;
   */
  TRIPLE_CHALLENGE = 6,

  /**
   * CANCELLED means the game never started. Game start signal was not sent.
   *
   * @generated from enum value: CANCELLED = 7;
   */
  CANCELLED = 7,

  /**
   * FORCE_FORFEIT is a way to force an opponent to take a loss if they left a
   * game early without resigning.
   *
   * @generated from enum value: FORCE_FORFEIT = 8;
   */
  FORCE_FORFEIT = 8,
}

/**
 * Describes the enum ipc.GameEndReason.
 */
export const GameEndReasonSchema: GenEnum<GameEndReason> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 0);

/**
 * @generated from enum ipc.GameMode
 */
export enum GameMode {
  /**
   * @generated from enum value: REAL_TIME = 0;
   */
  REAL_TIME = 0,

  /**
   * @generated from enum value: CORRESPONDENCE = 1;
   */
  CORRESPONDENCE = 1,
}

/**
 * Describes the enum ipc.GameMode.
 */
export const GameModeSchema: GenEnum<GameMode> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 1);

/**
 * @generated from enum ipc.RatingMode
 */
export enum RatingMode {
  /**
   * @generated from enum value: RATED = 0;
   */
  RATED = 0,

  /**
   * @generated from enum value: CASUAL = 1;
   */
  CASUAL = 1,
}

/**
 * Describes the enum ipc.RatingMode.
 */
export const RatingModeSchema: GenEnum<RatingMode> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 2);

/**
 * @generated from enum ipc.GameType
 */
export enum GameType {
  /**
   * A NATIVE game is the default OMGWords game (or its variants)
   * created on the woogles site, between two players or between a player
   * and a bot.
   *
   * @generated from enum value: NATIVE = 0;
   */
  NATIVE = 0,

  /**
   * An ANNOTATED game does not feature Woogles players, but is instead
   * created by a broadcaster/annotator to represent a real-life game.
   * It is created using the liwords "editor" mode or by importing a GCG.
   *
   * @generated from enum value: ANNOTATED = 1;
   */
  ANNOTATED = 1,

  /**
   * @generated from enum value: BOT_VS_BOT = 2;
   */
  BOT_VS_BOT = 2,
}

/**
 * Describes the enum ipc.GameType.
 */
export const GameTypeSchema: GenEnum<GameType> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 3);

/**
 * @generated from enum ipc.PlayState
 */
export enum PlayState {
  /**
   * @generated from enum value: PLAYING = 0;
   */
  PLAYING = 0,

  /**
   * @generated from enum value: WAITING_FOR_FINAL_PASS = 1;
   */
  WAITING_FOR_FINAL_PASS = 1,

  /**
   * @generated from enum value: GAME_OVER = 2;
   */
  GAME_OVER = 2,

  /**
   * @generated from enum value: UNSTARTED = 3;
   */
  UNSTARTED = 3,
}

/**
 * Describes the enum ipc.PlayState.
 */
export const PlayStateSchema: GenEnum<PlayState> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 4);

/**
 * @generated from enum ipc.ChallengeRule
 */
export enum ChallengeRule {
  /**
   * @generated from enum value: ChallengeRule_VOID = 0;
   */
  ChallengeRule_VOID = 0,

  /**
   * @generated from enum value: ChallengeRule_SINGLE = 1;
   */
  ChallengeRule_SINGLE = 1,

  /**
   * @generated from enum value: ChallengeRule_DOUBLE = 2;
   */
  ChallengeRule_DOUBLE = 2,

  /**
   * @generated from enum value: ChallengeRule_FIVE_POINT = 3;
   */
  ChallengeRule_FIVE_POINT = 3,

  /**
   * @generated from enum value: ChallengeRule_TEN_POINT = 4;
   */
  ChallengeRule_TEN_POINT = 4,

  /**
   * @generated from enum value: ChallengeRule_TRIPLE = 5;
   */
  ChallengeRule_TRIPLE = 5,
}

/**
 * Describes the enum ipc.ChallengeRule.
 */
export const ChallengeRuleSchema: GenEnum<ChallengeRule> = /*@__PURE__*/
  enumDesc(file_proto_ipc_omgwords, 5);

