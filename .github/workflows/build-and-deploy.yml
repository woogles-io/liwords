name: Build and Deploy

# Workflow optimization:
# - detect_changes job identifies which parts of the codebase changed
# - Backend jobs (build_api_srv, deploy_api_docker, run_db_migration) only run if backend files changed
# - Frontend jobs (build_fe, deploy_fe) only run if liwords-ui/ changed
# - Migration job only runs if db/ folder changed (in addition to backend changes)
# This significantly speeds up deployments that only touch one part of the codebase

on:
  push:
    branches:
      - "*"

permissions:
  packages: write

jobs:
  detect_changes:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend_any_changed }}
      frontend: ${{ steps.filter.outputs.frontend_any_changed }}
      migrations: ${{ steps.filter.outputs.migrations_any_changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get changed files
        uses: tj-actions/changed-files@24d32ffd492484c1d75e0c0b894501ddb9d30d62 # v47
        id: filter
        with:
          files_yaml: |
            backend:
              - "api/**"
              - "services/**"
              - "rpc/**"
              - "db/**"
              - "cmd/**"
              - "deploy/**"
              - "pkg/**"
              - "go.mod"
              - "go.sum"
              - "scripts/**"
            frontend:
              - "liwords-ui/**"
            migrations:
              - "db/migrations/**"
              - "scripts/run-migration-task.sh"

  build_api_srv:
    runs-on: ubuntu-latest
    needs: detect_changes
    if: ${{ needs.detect_changes.outputs.backend == 'true' }}
    env:
      MACONDO_DATA_PATH: ${{ github.workspace }}/data
      TEST_DB_HOST: localhost
      TEST_DB_PREFIX: liwords_test
      DB_PORT: 5432
      DB_USER: postgres
      DB_PASSWORD: pass
      DB_SSL_MODE: disable
      DB_MIGRATIONS_PATH: file:///${{ github.workspace }}/db/migrations
      REDIS_URL: redis://localhost:6379
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 3s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
      postgres:
        # Docker Hub image
        image: postgres
        # Provide the password for postgres
        env:
          POSTGRES_PASSWORD: pass
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 5s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps tcp port 5432 on service container to the host
          - 5432:5432

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # - name: Clone macondo
      #   uses: actions/checkout@v4
      #   with:
      #     repository: domino14/macondo
      #     path: macondo

      # - run: mv $GITHUB_WORKSPACE/macondo /opt/macondo

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ">=1.22"

      - name: Build API
        run: cd cmd/liwords-api && go build

      - name: Test API
        run: go test -race ./...

      - name: Build Puzzle Generator
        run: cd cmd/puzzlegen && go build

      - name: Build Maintenance
        run: cd cmd/maintenance && go build

      - name: Build Socket Server
        run: cd cmd/socketsrv && go build

      - name: Discord notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: ./scripts/utilities/notify-discord.sh "liwords backend built successfully for branch {{GITHUB_REF_NAME}}."
        continue-on-error: true

  deploy_api_docker:
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/master' }}
    needs: build_api_srv
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log in to the container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: domino14
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Tag Docker Image
        run: cd deploy && ./build-and-tag.sh

      - name: Discord notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          DISCORD_EMBEDS: |
            [{
              "title": "ðŸŽ‰ Docker Images Built & Tagged",
              "fields": [
                { "name": "Repository", "value": "[${{github.event.repository.name}}](${{github.event.repository.clone_url}})", "inline": true },
                { "name": "Branch", "value": "[${{github.ref_name}}](https://github.com/${{github.repository}}/tree/${{github.ref_name}})", "inline": true },
                { "name": "APITag", "value": "ghcr.io/woogles-io/liwords-api:${{github.ref_name}}-gh${{github.run_number}}"},
                { "name": "SocketTag", "value": "ghcr.io/woogles-io/liwords-socket:${{github.ref_name}}-gh${{github.run_number}}"}
              ],
              "color": 1127128
            }]
        run: ./scripts/utilities/notify-discord.sh
        continue-on-error: true

  run_db_migration:
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/master' }}
    needs:
      - deploy_api_docker
      - detect_changes
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-2
      ECS_CLUSTER: woogles-prod
      TASK_DEFINITION: liwords-db-migration
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-2

      - name: Run Database Migration Task
        if: ${{ needs.detect_changes.outputs.migrations == 'true' }}
        run: |
          echo "Starting database migration task..."

          # Calculate the Docker image tag (matches deploy/build-and-tag.sh format)
          IMAGE_TAG="${GITHUB_REF_NAME}-gh${GITHUB_RUN_NUMBER}"
          DOCKER_IMAGE="ghcr.io/woogles-io/liwords-api:${IMAGE_TAG}"

          echo "Using Docker image: $DOCKER_IMAGE"

          # For EC2 launch type, we need to register a new task definition revision
          # Get the current task definition
          TASK_DEF_JSON=$(aws ecs describe-task-definition \
            --task-definition $TASK_DEFINITION \
            --region $AWS_REGION \
            --query 'taskDefinition')

          # Update the image in the task definition
          NEW_TASK_DEF=$(echo $TASK_DEF_JSON | jq \
            --arg IMAGE "$DOCKER_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')

          # Register the new task definition revision
          echo "Registering new task definition with updated image..."
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --region $AWS_REGION \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "New task definition: $NEW_TASK_DEF_ARN"

          # Run the ECS task with the new task definition revision
          TASK_OUTPUT=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $NEW_TASK_DEF_ARN \
            --launch-type EC2 \
            --region $AWS_REGION)

          # Extract task ARN
          TASK_ARN=$(echo $TASK_OUTPUT | jq -r '.tasks[0].taskArn')

          if [[ -z "$TASK_ARN" ]] || [[ "$TASK_ARN" == "null" ]]; then
            echo "ERROR: Failed to start migration task"
            echo "$TASK_OUTPUT" | jq .
            exit 1
          fi

          TASK_ID=$(echo $TASK_ARN | awk -F/ '{print $NF}')
          echo "Migration task started: $TASK_ID"
          echo "Task ARN: $TASK_ARN"

          # Wait for task to complete (10 minute timeout)
          TIMEOUT=600
          ELAPSED=0
          POLL_INTERVAL=10

          while [ $ELAPSED -lt $TIMEOUT ]; do
            TASK_STATUS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $TASK_ARN \
              --region $AWS_REGION \
              --query 'tasks[0].lastStatus' \
              --output text)

            echo "[${ELAPSED}s] Migration task status: $TASK_STATUS"

            if [ "$TASK_STATUS" == "STOPPED" ]; then
              EXIT_CODE=$(aws ecs describe-tasks \
                --cluster $ECS_CLUSTER \
                --tasks $TASK_ARN \
                --region $AWS_REGION \
                --query 'tasks[0].containers[0].exitCode' \
                --output text)

              STOP_REASON=$(aws ecs describe-tasks \
                --cluster $ECS_CLUSTER \
                --tasks $TASK_ARN \
                --region $AWS_REGION \
                --query 'tasks[0].stoppedReason' \
                --output text)

              echo "Migration task completed with exit code: $EXIT_CODE"
              echo "Stop reason: $STOP_REASON"

              if [ "$EXIT_CODE" == "0" ]; then
                echo "âœ“ Database migration completed successfully!"
                exit 0
              else
                echo "âœ— Database migration failed!"

                # Try to fetch logs
                LOG_GROUP="/ecs/liwords-db-migration"
                echo "Fetching CloudWatch logs from $LOG_GROUP..."

                LOG_STREAM=$(aws logs describe-log-streams \
                  --log-group-name $LOG_GROUP \
                  --region $AWS_REGION \
                  --order-by LastEventTime \
                  --descending \
                  --max-items 1 \
                  --query 'logStreams[0].logStreamName' \
                  --output text 2>/dev/null || echo "")

                if [[ -n "$LOG_STREAM" ]] && [[ "$LOG_STREAM" != "None" ]]; then
                  echo "Recent logs:"
                  aws logs get-log-events \
                    --log-group-name $LOG_GROUP \
                    --log-stream-name $LOG_STREAM \
                    --region $AWS_REGION \
                    --limit 100 \
                    --query 'events[*].message' \
                    --output text 2>/dev/null || echo "Could not fetch logs"
                fi

                exit 1
              fi
            fi

            sleep $POLL_INTERVAL
            ELAPSED=$((ELAPSED + POLL_INTERVAL))
          done

          echo "âœ— Migration task timeout reached after ${TIMEOUT}s"
          exit 1

      - name: Discord notification (success)
        if: ${{ success() && needs.detect_changes.outputs.migrations == 'true' }}
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: ./scripts/utilities/notify-discord.sh "âœ“ Database migration completed successfully for branch {{GITHUB_REF_NAME}}."
        continue-on-error: true

      - name: Discord notification (failure)
        if: ${{ failure() && needs.detect_changes.outputs.migrations == 'true' }}
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: ./scripts/utilities/notify-discord.sh "âœ— Database migration FAILED for branch {{GITHUB_REF_NAME}}. Check GitHub Actions logs."
        continue-on-error: true

  build_fe:
    runs-on: ubuntu-latest
    needs: detect_changes
    if: ${{ needs.detect_changes.outputs.frontend == 'true' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          check-latest: true

      - name: Install Dependencies
        run: cd liwords-ui && npm ci

      - name: Test Frontend
        run: cd liwords-ui && npm run test

      - name: Build Frontend
        run: cd liwords-ui && npm run build

      - name: Persist Dist Directory
        uses: actions/upload-artifact@v4
        with:
          path: liwords-ui/dist

      - name: Discord notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: ./scripts/utilities/notify-discord.sh "liwords front-end built successfully for branch {{GITHUB_REF_NAME}}."
        continue-on-error: true

  deploy_fe:
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/master' }}
    needs: build_fe
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-2
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Dist Directory
        uses: actions/download-artifact@v4
        with:
          path: /tmp/liwords-ui

      - name: Calculate UI Hash
        run: |
          ls -al /tmp/liwords-ui/artifact
          UI_HASH=$(find /tmp/liwords-ui/artifact -type f -exec md5sum {} \; | sort -k 2 | md5sum | head -c 32)
          echo $UI_HASH
          sed -i "s:unknown:${UI_HASH}:" /tmp/liwords-ui/artifact/config.js
          echo "UI_HASH=$UI_HASH" >> $GITHUB_ENV

      - name: Sync to S3 (Cache Everything)
        run: |
          cd /tmp/liwords-ui/artifact &&
          aws s3 sync --cache-control 'max-age=3024000' \
          --exclude index.html --exclude config.js --exclude '*.wasm' \
          --metadata FEHash=${UI_HASH} \
          . s3://woogles.io

      - name: Sync to S3 (No Cache Except Wasm)
        run: |
          cd /tmp/liwords-ui/artifact &&
          aws s3 sync --cache-control 'no-cache' --exclude '*.wasm' \
          --metadata FEHash=${UI_HASH} \
          . s3://woogles.io

      - name: Cache Wasm File Separately
        run: |
          cd /tmp/liwords-ui/artifact &&
          aws s3 sync --cache-control 'max-age=3024000' --exclude '*' --include '*.wasm' \
          --metadata FEHash=${UI_HASH} \
          --content-type 'application/wasm' . s3://woogles.io

      - name: Update Frontend Hash
        run: |
          echo "Updating frontend hash to: $UI_HASH"
          response=$(curl -f -X POST -H "Content-Type: application/json" \
          -H "X-Api-Key: ${{ secrets.ADMIN_WOOGLES_API_KEY }}" \
          https://woogles.io/api/config_service.ConfigService/SetFEHash \
          -d "{\"hash\": \"$UI_HASH\"}" -w "\n%{http_code}")
          http_code=$(echo "$response" | tail -n1)
          if [ "$http_code" -ne 200 ]; then
            echo "Failed to update frontend hash. HTTP status: $http_code"
            echo "Response: $response"
            exit 1
          fi
          echo "Frontend hash updated successfully"

      - name: Discord notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: ./scripts/utilities/notify-discord.sh "liwords front-end deployed successfully for branch {{GITHUB_REF_NAME}}."
        continue-on-error: true
